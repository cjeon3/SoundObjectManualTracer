<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Contour Tracer | UCI Hearing & Speech Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * { -webkit-tap-highlight-color: transparent; }
        body { min-height: 100vh; font-family: ui-sans-serif, system-ui, sans-serif; background: #f3f4f6; }
        #canvas-container {
            max-width: 100%;
            width: 100%;
            /* Constrain to the smaller of viewport width or height so the full
               square grid is always visible regardless of orientation. */
            max-height: min(calc(100svh - 44px), 100vw);
            max-width: min(calc(100svh - 44px), 100vw);
            margin: 0 auto;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            border-radius: 0.75rem;
            overflow: hidden;
            background: #fff;
            touch-action: none;
            aspect-ratio: 1;
            position: relative;
        }
        #drawing-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: crosshair;
            transform-origin: 0 0;
        }
        /* Zoom indicator badge */
        #zoom-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 6px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.25s;
            z-index: 10;
        }
        #zoom-indicator.visible { opacity: 1; }
        /* Reset zoom button */
        #reset-zoom {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.55);
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            z-index: 10;
            display: none;
        }
        #reset-zoom:hover { background: rgba(0,0,0,0.75); }
        input[type="range"] { -webkit-appearance: none; background: transparent; cursor: pointer; width: 100%; height: 40px; }
        input[type="range"]::-webkit-slider-runnable-track { background: linear-gradient(to right, #3b82f6, #8b5cf6); height: 8px; border-radius: 4px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; background: #000; border: 3px solid #fff; border-radius: 50%; cursor: grab; margin-top: -8px; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
        input[type="range"]::-moz-range-track { background: linear-gradient(to right, #3b82f6, #8b5cf6); height: 8px; border-radius: 4px; }
        input[type="range"]::-moz-range-thumb { height: 24px; width: 24px; background: #000; border: 3px solid #fff; border-radius: 50%; cursor: grab; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
        .slider-labels { display: flex; justify-content: space-between; font-size: 11px; color: #6b7280; margin-top: 4px; }
        .tab-btn { transition: all 0.2s; }
        .tab-btn.active { background: linear-gradient(to right, #3b82f6, #8b5cf6) !important; color: white !important; transform: scale(1.05); }
        .trial-btn.active { background: linear-gradient(to right, #10b981, #059669) !important; color: white !important; }
        .freq-btn.active { background: linear-gradient(to right, #f59e0b, #d97706) !important; color: white !important; }
        .color-button.selected { border: 4px solid white !important; box-shadow: 0 0 0 4px #3b82f6 !important; transform: scale(1.15) !important; }
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s; }
        .modal.active { opacity: 1; visibility: visible; }
        .modal-content { background: white; border-radius: 16px; padding: 1.5rem; max-width: 900px; width: 95%; max-height: 90vh; overflow-y: auto; }
        .checkbox-grid { display: grid; gap: 0.5rem; max-height: 200px; overflow-y: auto; }
        .checkbox-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8fafc; border-radius: 6px; cursor: pointer; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .data-table th { background: #f1f5f9; padding: 0.5rem; text-align: left; font-weight: 600; }
        .data-table td { padding: 0.5rem; border-bottom: 1px solid #e2e8f0; font-family: monospace; }
        /* Responsive: on small screens, reduce body padding and header size */
        @media (max-width: 768px) {
            body { padding: 0.5rem !important; }
            header h1 { font-size: 1.5rem; }
            header p { font-size: 0.85rem; }
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="max-w-6xl mx-auto px-0 sm:px-2">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-blue-800 mb-2">Sound Object Contour Tracer</h1>
            <p class="text-xl font-semibold text-gray-600">UCI Hearing & Speech Lab</p>
            <p class="text-sm text-gray-400 mt-1">v5.3 ‚Äî Last updated: February 5, 2026</p>
        </header>
        
        <!-- Upload -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-lg font-bold text-gray-800 mb-4">üìÅ Upload Images or Import Data</h2>
            <div class="flex flex-wrap gap-3">
                <label class="px-6 py-2.5 rounded-xl font-bold text-sm bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg cursor-pointer">üìÅ Upload ZIP<input type="file" id="zip-upload" accept=".zip" class="hidden"></label>
                <label class="px-6 py-2.5 rounded-xl font-bold text-sm bg-gradient-to-r from-purple-500 to-purple-600 text-white shadow-lg cursor-pointer">üñºÔ∏è Single PNG<input type="file" id="single-upload" accept="image/png" class="hidden"></label>
                <label class="px-6 py-2.5 rounded-xl font-bold text-sm bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-lg cursor-pointer">üì• Import JSON<input type="file" id="json-import" accept=".json" class="hidden"></label>
            </div>
            <p class="mt-3 text-sm text-gray-500">Supports nested ZIPs. Structure: ParticipantName/TrialFolder/filename.png</p>
            <div id="upload-log" class="mt-3 text-xs text-gray-600 font-mono max-h-64 overflow-y-auto border border-gray-200 rounded-lg p-2 bg-gray-50 hidden"></div>
        </div>
        
        <!-- Participant Tabs -->
        <div id="participant-section" class="bg-white p-4 rounded-xl shadow-lg mb-4 hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-3">Select Participant</h2>
            <div id="participant-tabs" class="flex flex-wrap gap-2"></div>
        </div>
        
        <!-- Trial Tabs -->
        <div id="trial-section" class="bg-white p-4 rounded-xl shadow-lg mb-4 hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-3">Select Trial</h2>
            <div id="trial-tabs" class="flex flex-wrap gap-2"></div>
        </div>
        
        <!-- Frequency Tabs -->
        <div id="frequency-section" class="bg-white p-4 rounded-xl shadow-lg mb-4 hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-3">Select Frequency</h2>
            <div id="frequency-tabs" class="flex flex-wrap gap-2"></div>
        </div>
        
        <!-- Drawing Toolbar: color, brush, undo/redo/clear ‚Äî directly above the canvas -->
        <div id="drawing-toolbar" class="bg-white p-3 rounded-xl shadow-lg mb-2 hidden">
            <div class="flex flex-wrap items-center gap-3">
                <!-- Color buttons -->
                <div class="flex items-center gap-2">
                    <span class="font-bold text-gray-700 text-sm">Color</span>
                    <button id="color-red" class="color-button w-10 h-10 rounded-full shadow-md border-4 border-gray-200 selected" style="background:#ef4444;"></button>
                    <button id="color-blue" class="color-button w-10 h-10 rounded-full shadow-md border-4 border-gray-200" style="background:#3b82f6;"></button>
                </div>
                <!-- Brush size -->
                <div class="flex items-center gap-2 flex-1 min-w-[140px] max-w-[260px]">
                    <span class="font-bold text-gray-700 text-sm whitespace-nowrap">Brush: <span id="brush-val" class="text-blue-600">5</span></span>
                    <input id="brush-slider" type="range" min="1" max="10" value="5" class="flex-1">
                </div>
                <!-- Divider -->
                <div class="hidden sm:block w-px h-8 bg-gray-300"></div>
                <!-- Action buttons -->
                <div class="flex flex-wrap gap-1.5">
                    <button id="toggle-draw" class="px-3 py-1.5 rounded-lg font-bold text-xs bg-green-500 text-white shadow">‚úèÔ∏è ON</button>
                    <button id="undo-btn" disabled class="px-3 py-1.5 rounded-lg font-bold text-xs bg-yellow-400 text-gray-900 shadow disabled:opacity-50">‚Ü©Ô∏è Undo</button>
                    <button id="redo-btn" disabled class="px-3 py-1.5 rounded-lg font-bold text-xs bg-yellow-400 text-gray-900 shadow disabled:opacity-50">‚Ü™Ô∏è Redo</button>
                    <button id="clear-btn" class="px-3 py-1.5 rounded-lg font-bold text-xs bg-red-500 text-white shadow">üóëÔ∏è Clear</button>
                    <button id="grid-btn" class="px-3 py-1.5 rounded-lg font-bold text-xs bg-gray-500 text-white shadow">üìê Grid</button>
                </div>
            </div>
        </div>
        
        <!-- Canvas -->
        <div id="canvas-container" class="bg-white rounded-xl shadow-2xl mb-4">
            <canvas id="drawing-canvas"></canvas>
            <span id="zoom-indicator">100%</span>
            <button id="reset-zoom">Reset Zoom</button>
        </div>
        
        <!-- Tracing Statistics Section -->
        <div id="stats-section" class="bg-gradient-to-r from-gray-50 to-slate-50 p-4 rounded-xl shadow-lg mb-6 border border-gray-200 hidden">
            <h3 class="font-bold text-gray-700 mb-3">üìä Tracing Statistics</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="bg-white p-3 rounded-lg border border-red-200">
                    <h4 class="font-semibold text-red-600 mb-2">Red (0¬∞ IPD)</h4>
                    <div class="text-sm space-y-1">
                        <div>Shapes traced: <span id="stats-red-shapes" class="font-mono font-bold">0</span></div>
                        <div>Total points: <span id="stats-red-points" class="font-mono font-bold">0</span></div>
                        <div>Image overlap: <span id="stats-red-overlap" class="font-mono font-bold">-</span></div>
                        <div class="w-full bg-gray-200 rounded-full h-2 mt-1">
                            <div id="stats-red-bar" class="bg-red-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="bg-white p-3 rounded-lg border border-blue-200">
                    <h4 class="font-semibold text-blue-600 mb-2">Blue (90¬∞ right-leading IPD)</h4>
                    <div class="text-sm space-y-1">
                        <div>Shapes traced: <span id="stats-blue-shapes" class="font-mono font-bold">0</span></div>
                        <div>Total points: <span id="stats-blue-points" class="font-mono font-bold">0</span></div>
                        <div>Image overlap: <span id="stats-blue-overlap" class="font-mono font-bold">-</span></div>
                        <div class="w-full bg-gray-200 rounded-full h-2 mt-1">
                            <div id="stats-blue-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            </div>
            <p class="text-xs text-gray-500 mt-3">Overlap measures how well traced contours match the original drawing pixels (higher = better match).</p>
        </div>
        
        <!-- Advanced Controls -->
        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 space-y-4">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="bg-blue-50 p-4 rounded-xl">
                    <label class="font-bold text-gray-800">Resample Rate: <span id="resample-val" class="text-xl text-blue-600">1000</span></label>
                    <input id="resample-slider" type="range" min="500" max="10000" step="250" value="1000">
                    <div class="slider-labels"><span>500</span><span>5000</span><span>10000</span></div>
                </div>
                <div class="bg-purple-50 p-4 rounded-xl">
                    <label class="font-bold text-gray-800">Image Opacity: <span id="img-opacity-val" class="text-xl text-purple-600">50%</span></label>
                    <input id="img-opacity-slider" type="range" min="0" max="100" value="50">
                    <div class="slider-labels"><span>0%</span><span>50%</span><span>100%</span></div>
                </div>
                <div class="bg-green-50 p-4 rounded-xl">
                    <label class="font-bold text-gray-800">Shape Opacity: <span id="shape-opacity-val" class="text-xl text-green-600">30%</span></label>
                    <input id="shape-opacity-slider" type="range" min="0" max="100" value="30">
                    <div class="slider-labels"><span>0%</span><span>50%</span><span>100%</span></div>
                </div>
                <div class="bg-orange-50 p-4 rounded-xl">
                    <label class="font-bold text-gray-800">Radial Resolution: <span id="radial-res-val" class="text-xl text-orange-600">720</span></label>
                    <input id="radial-res-slider" type="range" min="36" max="3600" step="36" value="720">
                    <div class="slider-labels"><span>36</span><span>720</span><span>3600</span></div>
                </div>
            </div>
            <div id="status" class="text-sm text-gray-500 pt-2 border-t">Ready. Upload images to begin.</div>
            <div class="pt-2 border-t text-sm">
                <span class="font-semibold">Current:</span>
                <span id="info-p" class="font-mono text-gray-700">-</span> |
                <span id="info-t" class="font-mono text-gray-700">-</span> |
                <span id="info-f" class="font-mono text-gray-700">-</span> |
                Red: <span id="info-r" class="font-mono font-bold text-red-500">0</span> |
                Blue: <span id="info-b" class="font-mono font-bold text-blue-500">0</span>
            </div>
        </div>
        
        <!-- Generate Average Shapes Section - Below Controls, Above Export -->
        <div class="bg-gradient-to-r from-emerald-50 to-teal-50 p-6 rounded-xl shadow-lg mb-6 border-2 border-emerald-200">
            <h2 class="font-bold text-emerald-800 mb-4">Generate Composite Images</h2>
            <p class="text-xs text-gray-500 mb-4">Generate average shapes across ALL participants for each frequency. Shows all individual traced shapes at low opacity with the calculated average shape on top.</p>
            
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
                <button id="gen-freq-avg" class="px-4 py-2 rounded-xl font-bold text-sm bg-teal-600 text-white shadow">Generate Averages</button>
                <button id="bulk-avg" class="px-4 py-2 rounded-xl font-bold text-sm bg-indigo-500 text-white shadow">Select Frequencies...</button>
                <button id="export-freq-png" class="px-4 py-2 rounded-xl font-bold text-sm bg-cyan-600 text-white shadow">Export PNGs</button>
                <button id="clear-avg" class="px-4 py-2 rounded-xl font-bold text-sm bg-orange-400 text-white shadow">Clear Averages</button>
            </div>
            <div id="freq-avg-status" class="text-xs text-gray-500 mb-4"></div>
            
            <!-- Frequency Composites Gallery -->
            <div id="freq-composites-gallery" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <div class="border-2 border-dashed border-emerald-200 rounded-xl p-6 text-center text-gray-400 text-sm">Click "Generate Averages" to create composite images</div>
            </div>
            
            <!-- Centroid Analysis Panel: mean-of-centroids vs centroid-of-average -->
            <div id="centroid-analysis" class="hidden mt-6 border-t-2 border-emerald-300 pt-4">
                <h3 class="font-bold text-emerald-800 mb-2">Centroid Shift Analysis</h3>
                <p class="text-xs text-gray-500 mb-3">Compares two methods of computing centroid shift between red (0¬∞ IPD) and blue (90¬∞ IPD) shapes. The mean-of-individual-centroids reflects per-shape centroid positions averaged arithmetically. The centroid-of-average-contour is the geometric centroid of the equal-weight average shape. Discrepancies indicate that shape asymmetries in the averaged contour shift the centroid beyond what per-shape centroids predict.</p>
                <div id="centroid-analysis-table" class="overflow-x-auto"></div>
            </div>
            
            <!-- Circle Approximation & Shift Analysis -->
            <div id="circle-approx-analysis" class="hidden mt-6 border-t-2 border-emerald-300 pt-4">
                <h3 class="font-bold text-emerald-800 mb-2">Circle Approximation &amp; Shift Analysis</h3>
                <p class="text-xs text-gray-500 mb-3">For each frequency, the area of each average contour (red and blue) is used to derive the radius of an equivalent perfect circle: r = sqrt(area / pi). The centroid of each average contour serves as the circle center. The shift is the Euclidean distance between the red and blue circle centers. This provides a simplified geometric summary for comparison against raw spreadsheet data.</p>
                <div id="circle-approx-table" class="overflow-x-auto"></div>
            </div>
        </div>
        
        <!-- Cloud Collaboration -->
        <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-6 rounded-xl shadow-lg mb-6 border-2 border-indigo-200">
            <h3 class="font-bold text-indigo-800 mb-3">‚òÅÔ∏è Cloud Collaboration (Google Sheets)</h3>
            <p class="text-xs text-gray-600 mb-4">Multiple tracers can save/load progress. Each person's work is stored separately and can be merged.</p>
            
            <div class="mb-4">
                <label class="block text-sm font-semibold text-gray-700 mb-1">Apps Script URL</label>
                <input id="cloud-url" placeholder="https://script.google.com/macros/s/..." class="w-full px-3 py-2 border-2 border-indigo-300 rounded-xl text-sm">
            </div>
            
            <div class="mb-4">
                <label class="block text-sm font-semibold text-gray-700 mb-1">Your Tracer Name</label>
                <input id="tracer-name" placeholder="e.g., James, Sarah, Lab_Assistant_1" class="w-full px-3 py-2 border-2 border-indigo-300 rounded-xl text-sm">
            </div>
            
            <div class="grid grid-cols-2 gap-3 mb-4">
                <button id="cloud-save" class="px-4 py-2 rounded-xl font-bold text-sm bg-green-500 text-white shadow">üíæ Save to Cloud</button>
                <button id="cloud-load" class="px-4 py-2 rounded-xl font-bold text-sm bg-blue-500 text-white shadow">üìÇ Load My Progress</button>
            </div>
            
            <div class="border-t border-indigo-200 pt-4 mt-4">
                <h4 class="font-semibold text-gray-700 mb-2">Team Collaboration</h4>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <button id="cloud-list" class="px-4 py-2 rounded-xl font-bold text-sm bg-indigo-500 text-white shadow">üë• List Tracers</button>
                    <button id="cloud-load-all" class="px-4 py-2 rounded-xl font-bold text-sm bg-purple-500 text-white shadow">üì• Load All (excl. Final)</button>
                </div>
                <div class="flex gap-2 mb-2">
                    <select id="tracer-select" class="flex-1 px-3 py-2 border-2 border-indigo-300 rounded-xl text-sm">
                        <option value="">-- Select tracer to load --</option>
                    </select>
                    <button id="cloud-load-other" class="px-4 py-2 rounded-xl font-bold text-sm bg-cyan-500 text-white shadow">Load</button>
                    <button id="cloud-add-other" class="px-4 py-2 rounded-xl font-bold text-sm bg-teal-500 text-white shadow">+ Add</button>
                </div>
                <p class="text-xs text-gray-500">Load = replace current data | Add = merge with current data</p>
            </div>
            
            <div class="border-t border-indigo-200 pt-4 mt-4">
                <div class="flex items-center gap-3">
                    <button id="auto-cloud-toggle" class="px-4 py-2 rounded-xl font-bold text-sm bg-amber-500 text-white shadow">‚ö° Auto-Save: OFF</button>
                    <span class="text-xs text-gray-500">Auto-saves to cloud after each shape</span>
                </div>
            </div>
            
            <!-- Final Frequency Replacement -->
            <div class="border-t border-indigo-200 pt-4 mt-4">
                <h4 class="font-semibold text-red-700 mb-2">‚ö†Ô∏è Final: Replace Frequency Data</h4>
                <p class="text-xs text-gray-600 mb-2">Replace ALL existing data for a specific frequency in the "Final" tracer. Use this to fix incorrect traces.</p>
                <div class="flex gap-2 mb-2">
                    <select id="final-freq-select" class="flex-1 px-3 py-2 border-2 border-red-300 rounded-xl text-sm">
                        <option value="">-- Select frequency to replace --</option>
                    </select>
                    <button id="final-replace-btn" class="px-4 py-2 rounded-xl font-bold text-sm bg-red-600 text-white shadow">üîÑ Replace in Final</button>
                </div>
                <p class="text-xs text-red-500">Warning: This will DELETE all existing data for the selected frequency in Final and replace it with current local data.</p>
            </div>
            
            <p id="cloud-status" class="text-xs text-gray-500 mt-3"></p>
        </div>
        
        <!-- Gallery -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h3 class="font-bold text-gray-800 mb-4">Average Shapes Gallery</h3>
            <div id="gallery" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"><div class="border-2 border-dashed border-gray-200 rounded-xl p-8 text-center text-gray-400">No averages yet</div></div>
        </div>
        
        <!-- Coordinate Data Table (moved to bottom) -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <div class="flex justify-between mb-4">
                <h2 class="font-bold text-blue-700">Coordinate Data</h2>
                <button id="toggle-data" class="px-4 py-1 rounded-lg text-sm bg-gray-100">Show/Hide</button>
            </div>
            <div id="data-box" class="hidden max-h-80 overflow-auto">
                <table class="data-table"><thead><tr><th>Participant</th><th>Trial</th><th>Freq</th><th>Color</th><th>#</th><th>Pts</th><th>Sample</th></tr></thead><tbody id="data-body"><tr><td colspan="7" class="text-center text-gray-400 py-8">No data</td></tr></tbody></table>
            </div>
            <p class="text-xs text-gray-500 mt-2">Grid: 1000√ó1000px canvas, 20√ó20 units (-10 to +10), 50px per unit. Images align 1:1 with grid.</p>
        </div>
        
        <!-- Export Data (moved to bottom) -->
        <div class="bg-white p-6 rounded-xl shadow-lg">
            <h3 class="font-bold text-gray-800 mb-4">Export Data</h3>
            <div class="grid grid-cols-2 gap-3">
                <button id="exp-csv" class="px-4 py-2 rounded-xl font-bold text-sm bg-teal-500 text-white shadow">CSV</button>
                <button id="exp-json" class="px-4 py-2 rounded-xl font-bold text-sm bg-purple-500 text-white shadow">JSON</button>
            </div>
        </div>
    </div>
    
    <!-- Frequency Selection Modal -->
    <div id="modal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="flex justify-between mb-4">
                <h2 class="font-bold text-xl">Select Frequencies for Composite</h2>
                <button id="close-modal" class="p-2 hover:bg-gray-100 rounded">‚úï</button>
            </div>
            <p class="text-sm text-gray-600 mb-4">Choose which frequencies to include in the composite image generation.</p>
            <div class="mb-4">
                <div class="flex justify-between items-center mb-2">
                    <h4 class="font-semibold">Frequencies</h4>
                    <button id="sel-all-f" class="text-xs text-blue-600 hover:underline">Select All</button>
                </div>
                <div id="mod-f" class="checkbox-grid grid-cols-2"></div>
            </div>
            <div class="flex justify-end gap-2">
                <button id="cancel-modal" class="px-4 py-2 rounded-xl bg-gray-200 font-bold">Cancel</button>
                <button id="do-bulk" class="px-4 py-2 rounded-xl bg-emerald-500 text-white font-bold">Generate Composites</button>
            </div>
        </div>
    </div>
    
    <!-- Cloud Save Progress Popup -->
    <div id="cloud-progress-modal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="text-center">
                <div id="cloud-progress-icon" class="text-5xl mb-4">‚òÅÔ∏è</div>
                <h2 id="cloud-progress-title" class="font-bold text-xl mb-2">Saving to Cloud...</h2>
                <p id="cloud-progress-message" class="text-gray-600 mb-4">Uploading your traced data</p>
                
                <!-- Progress bar -->
                <div class="w-full bg-gray-200 rounded-full h-3 mb-4">
                    <div id="cloud-progress-bar" class="bg-gradient-to-r from-blue-500 to-purple-500 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                
                <p id="cloud-progress-details" class="text-sm text-gray-500"></p>
                
                <!-- Success/Error details (hidden initially) -->
                <div id="cloud-progress-result" class="hidden mt-4 p-4 rounded-xl">
                    <p id="cloud-result-text" class="font-semibold"></p>
                    <p id="cloud-result-details" class="text-sm mt-2"></p>
                </div>
                
                <!-- Close button (hidden during progress) -->
                <button id="cloud-progress-close" class="hidden mt-4 px-6 py-2 rounded-xl font-bold text-sm bg-gray-500 text-white shadow">Close</button>
            </div>
        </div>
    </div>

<script>
/**
 * Sound Object Contour Tracer v5.3
 * UCI Hearing & Speech Lab - February 2026
 * 
 * Application for manually tracing sound object contours from participant drawings.
 * Supports loading participant images, tracing shapes in red (0¬∞ IPD) and blue (90¬∞ IPD),
 * computing frequency-based averages, and cloud collaboration via Google Sheets.
 * 
 * COORDINATE SYSTEM (matching original drawing app):
 * - Canvas: 1000x1000 pixels
 * - Grid: 20x20 units (-10 to +10 on both axes)
 * - SCALE_FACTOR: 50 pixels per unit
 * - Origin (0,0): Center of canvas (pixel 500, 500)
 * - Y-axis: Positive upward (mathematical convention, inverted from canvas)
 * 
 * AREA CALCULATION:
 * Uses pixel-based area calculation matching the original drawing app methodology:
 * - Scans a grid at configurable resolution (default 0.1 units)
 * - For closed shapes: counts cells inside polygon OR within brush radius of path
 * - For open shapes: counts cells within brush radius of path segments
 * - Brush radius = brushSize / SCALE_FACTOR / 2 (default: 5 / 50 / 2 = 0.05 units)
 * - For closed shapes: subtracts outline area = perimeter * brushRadius * 2 * 0.50
 * 
 * CENTROID CALCULATION:
 * Uses uniform path resampling to eliminate drawing-speed bias:
 * - Resamples path to uniform spacing along arc length
 * - Returns arithmetic mean of resampled points
 * 
 * CLOUD COLLABORATION:
 * - Each tracer saves/loads independently via Google Apps Script
 * - "Final" tracer supports incremental saves (only new shapes sent)
 * - "Final: Replace Frequency" feature allows complete replacement of a specific
 *   frequency's data to fix incorrect traces
 */

// ============================================
// CONSTANTS - MATCHING ORIGINAL DRAWING APP
// ============================================
const CANVAS_SIZE = 1000;
const UNIT_RANGE = 10;
const SCALE_FACTOR = CANVAS_SIZE / (UNIT_RANGE * 2); // = 50
const CENTER = CANVAS_SIZE / 2; // = 500
const BACKGROUND_CIRCLE_RADIUS = 3; // units

const FREQUENCIES = [
    { hz: 62.5, db: 100 },
    { hz: 125, db: 90 },
    { hz: 250, db: 85 },
    { hz: 500, db: 80 },
    { hz: 1000, db: 80 },
    { hz: 2000, db: 80 }
];

const COLORS = { red: '#ef4444', blue: '#3b82f6' };

// ============================================
// STATE
// ============================================
let canvas, ctx;
let showGrid = true, drawingOn = true, isDrawing = false;
let selColor = 'red', brushSize = 5, resampleRate = 1000;
let IMAGE_OPACITY = 0.5;
let SHAPE_OPACITY = 0.3; // Opacity for background traced shapes (0-1)
let radialResolution = 720; // Number of angles for radial averaging (higher = more precise)
let curPath = [];
let allData = {}, images = {}, trialMapping = {};
let curParticipant = null, curTrial = null, curFreq = null;
let undoStack = [], redoStack = [];

// Snapshot of Final data as it existed on the server at load time.
// Used to diff against allData when saving as Final so we only send new shapes.
let _finalSnapshot = null;

// ============================================
// COORDINATE TRANSFORMS - EXACT MATCH
// ============================================
function canvasToUnit(x, y) {
    return {
        x: (x - CENTER) / SCALE_FACTOR,
        y: (CENTER - y) / SCALE_FACTOR
    };
}

function unitToCanvas(x, y) {
    return {
        x: x * SCALE_FACTOR + CENTER,
        y: CENTER - y * SCALE_FACTOR
    };
}

// ============================================
// HELPERS
// ============================================
const fKey = f => `${f.hz}Hz_${f.db}dB`;
const dataKey = () => curParticipant && curTrial && curFreq ? `${curParticipant}|${curTrial}|${fKey(curFreq)}` : null;
const status = m => document.getElementById('status').textContent = m;
const log = m => { const el = document.getElementById('upload-log'); el.classList.remove('hidden'); el.innerHTML += m + '<br>'; el.scrollTop = el.scrollHeight; };

function ensureData(p, t, f) {
    if (!allData[p]) allData[p] = {};
    if (!allData[p][t]) allData[p][t] = {};
    if (!allData[p][t][f]) allData[p][t][f] = { red: [], blue: [], redAvg: null, blueAvg: null };
    return allData[p][t][f];
}

function curData() {
    return curParticipant && curTrial && curFreq ? ensureData(curParticipant, curTrial, fKey(curFreq)) : null;
}

/**
 * Epsilon-tolerant comparison of two shape arrays.
 * Returns true if both have the same length and every point matches within eps.
 */
function shapesMatch(a, b, eps = 1e-4) {
    if (!a || !b) return false;
    if (a.length !== b.length) return false;
    if (a.length === 0) return true;
    for (let i = 0; i < a.length; i++) {
        if (Math.abs(a[i].x - b[i].x) > eps || Math.abs(a[i].y - b[i].y) > eps) return false;
    }
    return true;
}

/**
 * Given current allData and _finalSnapshot, return a new object containing
 * only shapes that are NOT already in the snapshot. Averages are included
 * only if they differ from the snapshot.
 * If snapshot is null (no prior load from Final), returns allData as-is.
 */
function extractNewShapes(current, snapshot) {
    if (!snapshot) return current;
    const diff = {};
    let hasAnything = false;

    for (const p of Object.keys(current)) {
        for (const t of Object.keys(current[p])) {
            for (const f of Object.keys(current[p][t])) {
                const cur = current[p][t][f];
                const snap = snapshot[p] && snapshot[p][t] && snapshot[p][t][f]
                    ? snapshot[p][t][f]
                    : { red: [], blue: [], redAvg: null, blueAvg: null };

                const newRed = [];
                if (cur.red) {
                    cur.red.forEach(shape => {
                        if (!shape || shape.length === 0) return;
                        const inSnap = snap.red && snap.red.some(s => shapesMatch(s, shape));
                        if (!inSnap) newRed.push(shape);
                    });
                }

                const newBlue = [];
                if (cur.blue) {
                    cur.blue.forEach(shape => {
                        if (!shape || shape.length === 0) return;
                        const inSnap = snap.blue && snap.blue.some(s => shapesMatch(s, shape));
                        if (!inSnap) newBlue.push(shape);
                    });
                }

                // Include averages only if they changed
                const redAvgChanged = cur.redAvg && !shapesMatch(cur.redAvg, snap.redAvg);
                const blueAvgChanged = cur.blueAvg && !shapesMatch(cur.blueAvg, snap.blueAvg);

                if (newRed.length > 0 || newBlue.length > 0 || redAvgChanged || blueAvgChanged) {
                    if (!diff[p]) diff[p] = {};
                    if (!diff[p][t]) diff[p][t] = {};
                    diff[p][t][f] = {
                        red: newRed,
                        blue: newBlue,
                        redAvg: redAvgChanged ? cur.redAvg : null,
                        blueAvg: blueAvgChanged ? cur.blueAvg : null
                    };
                    hasAnything = true;
                }
            }
        }
    }
    return hasAnything ? diff : null;
}

// ============================================
// RESAMPLING
// ============================================
function resample(pts, n) {
    if (pts.length < 2) return pts;
    let len = 0;
    const segs = [];
    for (let i = 0; i < pts.length - 1; i++) {
        const d = Math.hypot(pts[i+1].x - pts[i].x, pts[i+1].y - pts[i].y);
        segs.push(d);
        len += d;
    }
    if (len === 0) return [pts[0]];
    const res = [{ ...pts[0] }];
    const iv = len / (n - 1);
    let cd = 0, si = 0;
    for (let i = 1; i < n - 1; i++) {
        const td = i * iv;
        while (si < segs.length && cd + segs[si] < td) cd += segs[si++];
        if (si >= segs.length) break;
        const pr = (td - cd) / segs[si];
        res.push({ x: pts[si].x + (pts[si+1].x - pts[si].x) * pr, y: pts[si].y + (pts[si+1].y - pts[si].y) * pr });
    }
    res.push({ ...pts[pts.length - 1] });
    return res;
}

// ============================================
// DRAWING - EXACT GRID MATCH
// ============================================
function drawGrid() {
    if (!showGrid) return;
    ctx.save();
    
    // Minor grid lines
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) {
        if (i === 0) continue;
        const c = unitToCanvas(i, i);
        ctx.beginPath(); ctx.moveTo(0, c.y); ctx.lineTo(CANVAS_SIZE, c.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(c.x, 0); ctx.lineTo(c.x, CANVAS_SIZE); ctx.stroke();
    }
    
    // Major axes
    ctx.strokeStyle = '#6b7280';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, CENTER); ctx.lineTo(CANVAS_SIZE, CENTER); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(CENTER, 0); ctx.lineTo(CENTER, CANVAS_SIZE); ctx.stroke();
    
    // Labels - larger, bolder, with background for visibility
    ctx.font = 'bold 18px sans-serif';
    
    // X-axis labels (horizontal) - below the axis
    ctx.textBaseline = 'top';
    for (let i = -UNIT_RANGE; i <= UNIT_RANGE; i += 2) {
        if (i === 0) continue;
        let x = unitToCanvas(i, 0).x;
        const y = CENTER + 6;
        const text = i.toString();
        const metrics = ctx.measureText(text);
        
        // Adjust edge labels so they don't get cut off
        if (i === -UNIT_RANGE) {
            ctx.textAlign = 'left';
            x = Math.max(x - metrics.width/2, 4);
        } else if (i === UNIT_RANGE) {
            ctx.textAlign = 'right';
            x = Math.min(x + metrics.width/2, CANVAS_SIZE - 4);
        } else {
            ctx.textAlign = 'center';
        }
        
        // Draw background for better visibility
        const bgX = ctx.textAlign === 'center' ? x - metrics.width/2 - 3 : 
                    ctx.textAlign === 'left' ? x - 3 : x - metrics.width - 3;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(bgX, y - 1, metrics.width + 6, 22);
        
        // Draw text
        ctx.fillStyle = '#111827';
        ctx.fillText(text, x, y);
    }
    
    // Y-axis labels (vertical) - to the right of the axis
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    for (let j = -UNIT_RANGE; j <= UNIT_RANGE; j += 2) {
        if (j === 0) continue;
        const x = CENTER + 6;
        let y = unitToCanvas(0, j).y;
        const text = j.toString();
        const metrics = ctx.measureText(text);
        
        // Adjust edge labels so they don't get cut off
        if (j === UNIT_RANGE) y = Math.max(y, 14);  // Top edge (+10)
        if (j === -UNIT_RANGE) y = Math.min(y, CANVAS_SIZE - 14);  // Bottom edge (-10)
        
        // Draw background for better visibility
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(x - 2, y - 11, metrics.width + 6, 22);
        
        // Draw text
        ctx.fillStyle = '#111827';
        ctx.fillText(text, x, y);
    }
    
    ctx.restore();
}

function drawRefCircle() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(CENTER, CENTER, BACKGROUND_CIRCLE_RADIUS * SCALE_FACTOR, 0, 2 * Math.PI);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
}

function drawShape(s, clr, op = 1, lw = null) {
    if (!s || s.length < 2) return;
    ctx.save();
    ctx.globalAlpha = op;
    ctx.strokeStyle = clr;
    ctx.lineWidth = lw || brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    const st = unitToCanvas(s[0].x, s[0].y);
    ctx.moveTo(st.x, st.y);
    for (let i = 1; i < s.length; i++) {
        const p = unitToCanvas(s[i].x, s[i].y);
        ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();
}

function drawAvgShape(s, clr) {
    if (!s || s.length < 2) return;
    ctx.save();
    ctx.strokeStyle = clr === COLORS.red ? '#991b1b' : '#1e3a8a';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    const st = unitToCanvas(s[0].x, s[0].y);
    ctx.moveTo(st.x, st.y);
    for (let i = 1; i < s.length; i++) {
        const p = unitToCanvas(s[i].x, s[i].y);
        ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();
}

function redraw() {
    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    
    // Layer 1: Background image at configurable opacity
    const ik = curParticipant && curTrial && curFreq ? `${curParticipant}|${curTrial}|${fKey(curFreq)}` : null;
    if (ik && images[ik]) {
        ctx.save();
        ctx.globalAlpha = IMAGE_OPACITY;
        
        const img = images[ik];
        if (img.naturalWidth === CANVAS_SIZE && img.naturalHeight === CANVAS_SIZE) {
            ctx.drawImage(img, 0, 0);
        } else {
            const scale = Math.min(CANVAS_SIZE / img.naturalWidth, CANVAS_SIZE / img.naturalHeight);
            const scaledW = img.naturalWidth * scale;
            const scaledH = img.naturalHeight * scale;
            const offsetX = (CANVAS_SIZE - scaledW) / 2;
            const offsetY = (CANVAS_SIZE - scaledH) / 2;
            ctx.drawImage(img, offsetX, offsetY, scaledW, scaledH);
        }
        
        ctx.restore();
    }
    
    // Layer 2: Reference circle
    drawRefCircle();
    
    // Layer 3: Traced shapes with configurable opacity (in background)
    const d = curData();
    if (d) {
        // Traced shapes at configurable opacity
        d.red.forEach(s => drawShape(s, COLORS.red, SHAPE_OPACITY));
        d.blue.forEach(s => drawShape(s, COLORS.blue, SHAPE_OPACITY));
    }
    
    // Layer 4: Average shapes at full opacity on top
    if (d) {
        if (d.redAvg) drawAvgShape(d.redAvg, COLORS.red);
        if (d.blueAvg) drawAvgShape(d.blueAvg, COLORS.blue);
    }
    
    // Layer 5: Grid on top of everything
    drawGrid();
    updateInfo();
    updateStatistics();
}

function updateInfo() {
    document.getElementById('info-p').textContent = curParticipant || '-';
    document.getElementById('info-t').textContent = curTrial || '-';
    document.getElementById('info-f').textContent = curFreq ? `${curFreq.hz} Hz` : '-';
    const d = curData();
    document.getElementById('info-r').textContent = d ? d.red.length : 0;
    document.getElementById('info-b').textContent = d ? d.blue.length : 0;
}

// ============================================
// TRACING STATISTICS
// ============================================
function updateStatistics() {
    const statsSection = document.getElementById('stats-section');
    const d = curData();
    const ik = curParticipant && curTrial && curFreq ? `${curParticipant}|${curTrial}|${fKey(curFreq)}` : null;
    const img = ik ? images[ik] : null;
    
    // Show/hide stats section based on whether we have data
    if (!d || (!d.red.length && !d.blue.length)) {
        statsSection.classList.add('hidden');
        return;
    }
    
    statsSection.classList.remove('hidden');
    
    // Count shapes and points
    const redShapes = d.red.length;
    const blueShapes = d.blue.length;
    const redPoints = d.red.reduce((sum, s) => sum + (s ? s.length : 0), 0);
    const bluePoints = d.blue.reduce((sum, s) => sum + (s ? s.length : 0), 0);
    
    document.getElementById('stats-red-shapes').textContent = redShapes;
    document.getElementById('stats-blue-shapes').textContent = blueShapes;
    document.getElementById('stats-red-points').textContent = redPoints;
    document.getElementById('stats-blue-points').textContent = bluePoints;
    
    // Calculate overlap with original image if available
    if (img) {
        const overlap = calculateImageOverlap(img, d);
        
        document.getElementById('stats-red-overlap').textContent = overlap.red !== null ? `${overlap.red.toFixed(1)}%` : 'N/A';
        document.getElementById('stats-blue-overlap').textContent = overlap.blue !== null ? `${overlap.blue.toFixed(1)}%` : 'N/A';
        document.getElementById('stats-red-bar').style.width = overlap.red !== null ? `${overlap.red}%` : '0%';
        document.getElementById('stats-blue-bar').style.width = overlap.blue !== null ? `${overlap.blue}%` : '0%';
    } else {
        document.getElementById('stats-red-overlap').textContent = 'No image';
        document.getElementById('stats-blue-overlap').textContent = 'No image';
        document.getElementById('stats-red-bar').style.width = '0%';
        document.getElementById('stats-blue-bar').style.width = '0%';
    }
}

/**
 * Calculate how well traced contours overlap with original image pixels
 * Returns percentage of traced pixels that overlap with non-white pixels in the original
 */
function calculateImageOverlap(img, data) {
    // Create temporary canvas to analyze the image
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = CANVAS_SIZE;
    tempCanvas.height = CANVAS_SIZE;
    const tempCtx = tempCanvas.getContext('2d');
    
    // Draw the original image
    tempCtx.fillStyle = '#fff';
    tempCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    
    if (img.naturalWidth === CANVAS_SIZE && img.naturalHeight === CANVAS_SIZE) {
        tempCtx.drawImage(img, 0, 0);
    } else {
        const scale = Math.min(CANVAS_SIZE / img.naturalWidth, CANVAS_SIZE / img.naturalHeight);
        const scaledW = img.naturalWidth * scale;
        const scaledH = img.naturalHeight * scale;
        const offsetX = (CANVAS_SIZE - scaledW) / 2;
        const offsetY = (CANVAS_SIZE - scaledH) / 2;
        tempCtx.drawImage(img, offsetX, offsetY, scaledW, scaledH);
    }
    
    // Get image data
    const imageData = tempCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    const pixels = imageData.data;
    
    // Helper to get RGB values at a pixel
    function getRGB(x, y) {
        if (x < 0 || x >= CANVAS_SIZE || y < 0 || y >= CANVAS_SIZE) return null;
        const idx = (Math.floor(y) * CANVAS_SIZE + Math.floor(x)) * 4;
        return { r: pixels[idx], g: pixels[idx + 1], b: pixels[idx + 2] };
    }
    
    // Check if pixel is canvas/grid (black, gray, or white) - should be ignored
    function isCanvasOrGrid(r, g, b) {
        // Check for grayscale (r ‚âà g ‚âà b)
        const maxDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b));
        return maxDiff < 30; // If all channels are within 30 of each other, it's grayscale
    }
    
    // Check if pixel contains red/pink color
    // Includes: red, pink, magenta, red over gray/black
    function hasRedComponent(r, g, b) {
        if (isCanvasOrGrid(r, g, b)) return false;
        
        // Pure red or red-dominant
        if (r > 150 && r > g * 1.2 && r > b * 1.2) return true;
        
        // Pink (red + white blend): high red, moderate-high green and blue but red still highest
        if (r > 180 && g > 100 && b > 100 && r > g && r > b) return true;
        
        // Magenta/pink: high red and blue, lower green
        if (r > 150 && b > 100 && r > g * 1.3 && g < 150) return true;
        
        // Red over gray: red channel elevated compared to a gray baseline
        // If it would be gray but red is boosted
        const avgGB = (g + b) / 2;
        if (r > avgGB + 40 && r > 100) return true;
        
        // Red over black: low overall but red is dominant
        if (r > 50 && r > g * 1.5 && r > b * 1.5 && g < 100 && b < 100) return true;
        
        // Light red/salmon
        if (r > 200 && g > 120 && g < 180 && b > 100 && b < 160 && r > g && r > b) return true;
        
        return false;
    }
    
    // Check if pixel contains blue color
    // Includes: blue, cyan-ish blue, blue over gray/black
    function hasBlueComponent(r, g, b) {
        if (isCanvasOrGrid(r, g, b)) return false;
        
        // Pure blue or blue-dominant
        if (b > 150 && b > r * 1.2 && b > g * 1.1) return true;
        
        // Cyan-blue: high blue and green, lower red
        if (b > 150 && g > 100 && b >= g && r < g) return true;
        
        // Light blue: high blue with moderate other channels but blue still highest
        if (b > 180 && g > 100 && r > 80 && b > r && b > g) return true;
        
        // Blue over gray: blue channel elevated compared to a gray baseline
        const avgRG = (r + g) / 2;
        if (b > avgRG + 40 && b > 100) return true;
        
        // Blue over black: low overall but blue is dominant
        if (b > 50 && b > r * 1.5 && b > g * 1.3 && r < 100) return true;
        
        // Steel blue / muted blue
        if (b > 120 && b > r && b > g * 0.9 && r < 150) return true;
        
        return false;
    }
    
    // Check if pixel is purple (counts as both red AND blue)
    function isPurple(r, g, b) {
        if (isCanvasOrGrid(r, g, b)) return false;
        
        // Purple: significant red and blue, less green
        if (r > 100 && b > 100 && r > g * 1.2 && b > g * 1.2) return true;
        
        // Magenta: high red and blue, low green
        if (r > 150 && b > 150 && g < 120) return true;
        
        // Violet: blue-dominant purple
        if (b > 120 && r > 80 && b > g && r > g && g < 150) return true;
        
        // Light purple/lavender
        if (r > 150 && b > 150 && g > 100 && g < r && g < b) return true;
        
        return false;
    }
    
    // Check if a pixel matches red criteria (including purple)
    function isRedPixel(x, y) {
        const rgb = getRGB(x, y);
        if (!rgb) return false;
        return hasRedComponent(rgb.r, rgb.g, rgb.b) || isPurple(rgb.r, rgb.g, rgb.b);
    }
    
    // Check if a pixel matches blue criteria (including purple)
    function isBluePixel(x, y) {
        const rgb = getRGB(x, y);
        if (!rgb) return false;
        return hasBlueComponent(rgb.r, rgb.g, rgb.b) || isPurple(rgb.r, rgb.g, rgb.b);
    }
    
    // Calculate overlap for red traces
    let redOverlap = null;
    if (data.red && data.red.length > 0) {
        let totalRedPoints = 0;
        let matchingRedPoints = 0;
        
        data.red.forEach(shape => {
            if (!shape) return;
            shape.forEach(pt => {
                const canvasPt = unitToCanvas(pt.x, pt.y);
                totalRedPoints++;
                
                // Check a small area around the point (brush radius)
                let found = false;
                for (let dx = -brushSize; dx <= brushSize && !found; dx++) {
                    for (let dy = -brushSize; dy <= brushSize && !found; dy++) {
                        if (isRedPixel(canvasPt.x + dx, canvasPt.y + dy)) {
                            found = true;
                        }
                    }
                }
                if (found) matchingRedPoints++;
            });
        });
        
        redOverlap = totalRedPoints > 0 ? (matchingRedPoints / totalRedPoints) * 100 : 0;
    }
    
    // Calculate overlap for blue traces
    let blueOverlap = null;
    if (data.blue && data.blue.length > 0) {
        let totalBluePoints = 0;
        let matchingBluePoints = 0;
        
        data.blue.forEach(shape => {
            if (!shape) return;
            shape.forEach(pt => {
                const canvasPt = unitToCanvas(pt.x, pt.y);
                totalBluePoints++;
                
                // Check a small area around the point (brush radius)
                let found = false;
                for (let dx = -brushSize; dx <= brushSize && !found; dx++) {
                    for (let dy = -brushSize; dy <= brushSize && !found; dy++) {
                        if (isBluePixel(canvasPt.x + dx, canvasPt.y + dy)) {
                            found = true;
                        }
                    }
                }
                if (found) matchingBluePoints++;
            });
        });
        
        blueOverlap = totalBluePoints > 0 ? (matchingBluePoints / totalBluePoints) * 100 : 0;
    }
    
    return { red: redOverlap, blue: blueOverlap };
}

// ============================================
// DRAWING EVENTS
// ============================================

// Smoothing buffer for moving-average filter (visual + stored)
// Window size of 3 balances noise reduction vs responsiveness
const SMOOTH_WINDOW = 3;
let smoothBuffer = [];

// ============================================
// PINCH-TO-ZOOM STATE
// ============================================
let zoomScale = 1;
let zoomTranslateX = 0;
let zoomTranslateY = 0;
const ZOOM_MIN = 0.5;  // Allow zooming out to 50% for small screens
const ZOOM_MAX = 5;

// Track all active pointers for gesture detection
let activePointers = new Map(); // pointerId -> {clientX, clientY}
let isPinching = false;
let pinchStartDist = 0;
let pinchStartScale = 1;
let pinchStartMidX = 0;
let pinchStartMidY = 0;
let pinchStartTransX = 0;
let pinchStartTransY = 0;
let zoomIndicatorTimeout = null;

function applyZoomTransform() {
    const container = document.getElementById('canvas-container');
    const rect = container.getBoundingClientRect();

    if (zoomScale >= 1) {
        // Zoomed in: clamp so edges stay visible
        const maxTx = (zoomScale - 1) * rect.width;
        const maxTy = (zoomScale - 1) * rect.height;
        zoomTranslateX = Math.max(-maxTx, Math.min(0, zoomTranslateX));
        zoomTranslateY = Math.max(-maxTy, Math.min(0, zoomTranslateY));
    } else {
        // Zoomed out: center the smaller canvas within the container
        const offsetX = (1 - zoomScale) * rect.width / 2;
        const offsetY = (1 - zoomScale) * rect.height / 2;
        zoomTranslateX = offsetX;
        zoomTranslateY = offsetY;
    }

    canvas.style.transform = `translate(${zoomTranslateX}px, ${zoomTranslateY}px) scale(${zoomScale})`;

    // Show/hide zoom indicator
    const indicator = document.getElementById('zoom-indicator');
    const resetBtn = document.getElementById('reset-zoom');
    indicator.textContent = Math.round(zoomScale * 100) + '%';
    indicator.classList.add('visible');
    clearTimeout(zoomIndicatorTimeout);
    zoomIndicatorTimeout = setTimeout(() => indicator.classList.remove('visible'), 1200);

    resetBtn.style.display = Math.abs(zoomScale - 1) > 0.01 ? 'block' : 'none';
}

function resetZoom() {
    zoomScale = 1;
    zoomTranslateX = 0;
    zoomTranslateY = 0;
    canvas.style.transform = '';
    document.getElementById('reset-zoom').style.display = 'none';
    const indicator = document.getElementById('zoom-indicator');
    indicator.textContent = '100%';
    indicator.classList.add('visible');
    clearTimeout(zoomIndicatorTimeout);
    zoomIndicatorTimeout = setTimeout(() => indicator.classList.remove('visible'), 1200);
}

function pointerDist(a, b) {
    return Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
}

function getPoint(e) {
    const r = canvas.getBoundingClientRect();
    let cx, cy;
    if (e.touches?.length) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
    else if (e.changedTouches?.length) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
    else { cx = e.clientX; cy = e.clientY; }

    // Account for zoom transform: the canvas CSS dimensions stay the same,
    // but the visual content is scaled and translated. We need to map the
    // screen coordinate to the unzoomed canvas pixel coordinate.
    // r already reflects the *untransformed* layout box (CSS width/height),
    // but the actual visual position is shifted by the transform.
    // The pointer coords are in screen space. The canvas element's bounding
    // rect accounts for the transform, so we can use it directly.
    return { x: (cx - r.left) * (CANVAS_SIZE / r.width), y: (cy - r.top) * (CANVAS_SIZE / r.height) };
}

/**
 * Apply moving-average smoothing to reduce stylus/touch digitizer jitter.
 * Averages the last SMOOTH_WINDOW points to produce a smoothed position.
 * The smoothing magnitude is sub-pixel (typically <1px shift) and is
 * negligible relative to the downstream resample() which re-interpolates
 * the entire path at 1000 uniform arc-length intervals.
 */
function smoothPoint(rawPt) {
    smoothBuffer.push(rawPt);
    if (smoothBuffer.length > SMOOTH_WINDOW) {
        smoothBuffer.shift();
    }
    let sx = 0, sy = 0;
    for (let i = 0; i < smoothBuffer.length; i++) {
        sx += smoothBuffer[i].x;
        sy += smoothBuffer[i].y;
    }
    return { x: sx / smoothBuffer.length, y: sy / smoothBuffer.length };
}

// Track active pointer to ignore secondary touches on tablets
let activePointerId = null;

/**
 * Unified pointer-down handler.
 *
 * Pen (stylus) input ALWAYS goes to drawing and never participates in pinch
 * detection. This prevents a common tablet issue where palm contact or an
 * intentional zoom gesture interrupts a pen stroke.
 *
 * Touch input is tracked for pinch-zoom. Two simultaneous touch pointers
 * trigger pinch mode and suppress touch-based drawing. Mouse input follows
 * the same path as touch for consistency (scroll-wheel zoom is handled
 * separately).
 */
function handlePointerDown(e) {
    // Pen: always draw, never pinch
    if (e.pointerType === 'pen') {
        // Clear stale pinch state if no touch pointers remain
        if (isPinching && activePointers.size < 2) {
            isPinching = false;
        }
        if (!isDrawing) {
            startDraw(e);
        }
        return;
    }

    // Touch / mouse: track for pinch detection
    activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

    if (activePointers.size === 2) {
        // Entering pinch mode: cancel any in-progress TOUCH stroke.
        // Pen strokes are never cancelled by finger contact.
        if (isDrawing && activePointerId !== null && activePointers.has(activePointerId)) {
            // The drawing pointer is a touch pointer tracked in activePointers,
            // so it is safe to cancel.
            isDrawing = false;
            lastDrawnPt = null;
            activePointerId = null;
            smoothBuffer = [];
            curPath = [];
        }
        isPinching = true;
        const pts = Array.from(activePointers.values());
        pinchStartDist = pointerDist(pts[0], pts[1]);
        pinchStartScale = zoomScale;
        pinchStartMidX = (pts[0].clientX + pts[1].clientX) / 2;
        pinchStartMidY = (pts[0].clientY + pts[1].clientY) / 2;
        pinchStartTransX = zoomTranslateX;
        pinchStartTransY = zoomTranslateY;
        e.preventDefault();
        return;
    }

    if (activePointers.size === 1 && !isPinching) {
        startDraw(e);
    }
}

function handlePointerMove(e) {
    // Pen: route directly to drawing
    if (e.pointerType === 'pen') {
        if (isDrawing && e.pointerId === activePointerId) {
            doDraw(e);
        }
        return;
    }

    if (!activePointers.has(e.pointerId)) return;
    activePointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

    if (isPinching && activePointers.size >= 2) {
        e.preventDefault();
        const pts = Array.from(activePointers.values());
        const dist = pointerDist(pts[0], pts[1]);
        const midX = (pts[0].clientX + pts[1].clientX) / 2;
        const midY = (pts[0].clientY + pts[1].clientY) / 2;

        // Scale
        const rawScale = pinchStartScale * (dist / pinchStartDist);
        zoomScale = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, rawScale));

        // Pan: follow the midpoint shift
        zoomTranslateX = pinchStartTransX + (midX - pinchStartMidX);
        zoomTranslateY = pinchStartTransY + (midY - pinchStartMidY);

        applyZoomTransform();
        return;
    }

    if (!isPinching) {
        doDraw(e);
    }
}

function handlePointerUp(e) {
    // Pen: route directly to end-draw
    if (e.pointerType === 'pen') {
        if (isDrawing && e.pointerId === activePointerId) {
            endDraw(e);
        }
        return;
    }

    activePointers.delete(e.pointerId);

    if (isPinching) {
        if (activePointers.size < 2) {
            isPinching = false;
        }
        // Don't pass through to endDraw; the stroke was already cancelled
        return;
    }

    endDraw(e);
}

function startDraw(e) {
    if (!drawingOn || !curParticipant) return;
    // Ignore if we're already tracking a pointer (prevents multi-touch issues)
    if (isDrawing) return;
    isDrawing = true;
    activePointerId = e.pointerId;
    smoothBuffer = [];
    const p = getPoint(e);
    const sp = smoothPoint(p);
    curPath = [sp];
    // Set up stroke style once; we will draw incremental segments
    ctx.strokeStyle = COLORS[selColor];
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    // Record last drawn position for incremental rendering
    lastDrawnPt = sp;
    e.preventDefault();
}

// Last point rendered on canvas, used for incremental segment drawing
let lastDrawnPt = null;

function doDraw(e) {
    if (!isDrawing || e.pointerId !== activePointerId) return;
    e.preventDefault();

    // Collect all points from this event.
    // getCoalescedEvents() returns intermediate positions the browser
    // batched between frames (Pointer Events API). This recovers
    // positional data that would otherwise be lost between animation frames.
    let rawPoints = [];
    if (e.getCoalescedEvents) {
        const coalesced = e.getCoalescedEvents();
        if (coalesced.length > 0) {
            for (let i = 0; i < coalesced.length; i++) {
                rawPoints.push(getPoint(coalesced[i]));
            }
        }
    }
    // Fallback: if no coalesced events, use the event itself
    if (rawPoints.length === 0) {
        rawPoints.push(getPoint(e));
    }

    // Process each raw point: smooth it, store it, draw incremental segment
    for (let i = 0; i < rawPoints.length; i++) {
        const sp = smoothPoint(rawPoints[i]);
        curPath.push(sp);

        // Draw only the new segment (constant cost, not proportional to path length)
        if (lastDrawnPt) {
            ctx.beginPath();
            ctx.moveTo(lastDrawnPt.x, lastDrawnPt.y);
            ctx.lineTo(sp.x, sp.y);
            ctx.stroke();
        }
        lastDrawnPt = sp;
    }
}

function endDraw(e) {
    if (!isDrawing) return;
    // Only end for the pointer that started the stroke
    if (e && e.pointerId !== undefined && e.pointerId !== activePointerId) return;
    isDrawing = false;
    lastDrawnPt = null;
    activePointerId = null;
    smoothBuffer = [];
    if (curPath.length > 5) {
        const d = curData();
        undoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) });
        redoStack = [];
        const up = curPath.map(p => canvasToUnit(p.x, p.y));
        const rs = resample(up, resampleRate);
        d[selColor].push(rs);
        redraw();
        updateTable();
        status(`Added ${selColor} (${rs.length} pts)`);
        
        // Trigger auto-save after each shape
        triggerAutoSave();
    }
    curPath = [];
    document.getElementById('undo-btn').disabled = !undoStack.length;
    document.getElementById('redo-btn').disabled = !redoStack.length;
}

function undo() {
    if (!undoStack.length) return;
    const st = undoStack.pop();
    const d = curData();
    if (st.key === dataKey()) {
        redoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) });
        Object.assign(d, st.data);
        redraw();
        updateTable();
    }
    document.getElementById('undo-btn').disabled = !undoStack.length;
    document.getElementById('redo-btn').disabled = !redoStack.length;
}

function redo() {
    if (!redoStack.length) return;
    const st = redoStack.pop();
    const d = curData();
    if (st.key === dataKey()) {
        undoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) });
        Object.assign(d, st.data);
        redraw();
        updateTable();
    }
    document.getElementById('undo-btn').disabled = !undoStack.length;
    document.getElementById('redo-btn').disabled = !redoStack.length;
}

// ============================================
// FILE PARSING - Filename format: "ParticipantName_FrequencyHz_LoudnessdB.png"
// ============================================
function parseParticipant(fn) {
    // Extract participant name: everything before _[number]Hz
    // Example: "Jiaxin L_62.5Hz_100dB.png" -> "Jiaxin L"
    const base = fn.replace(/\.png$/i, '');
    const m = base.match(/^(.+?)_\d+(?:\.\d+)?[Hh]z/i);
    return m ? m[1].trim() : fn.split('_')[0] || 'Unknown';
}

function parseFreq(fn) {
    // Extract frequency: number followed by Hz
    // Example: "Jiaxin L_62.5Hz_100dB.png" -> 62.5
    const m = fn.match(/(\d+(?:\.\d+)?)\s*[Hh]z/i);
    return m ? parseFloat(m[1]) : null;
}

// ============================================
// ZIP PROCESSING - NESTED SUPPORT
// Folder structure: "ParticipantName_FolderNumber_AnythingElse/filename.png"
// Example: "Jiaxin L_11_Drawings 2/Jiaxin L_62.5Hz_100dB.png"
// - Participant: "Jiaxin L"
// - Folder number: 11 (used to determine trial order)
// - Filename frequency: 62.5Hz
// Trial numbers are sorted (e.g., 3, 5, 11) and mapped to Trial 1, 2, 3
// ============================================
async function processZip(zipFile) {
    const zip = await JSZip.loadAsync(zipFile);
    const fileInfos = [];
    let nestedZipCount = 0;
    
    async function extractFromZip(z, pathPrefix = '', depth = 0) {
        const indent = '  '.repeat(depth);
        const entries = Object.entries(z.files);
        log(`${indent}Scanning ${entries.length} entries at depth ${depth}...`);
        
        for (const [path, file] of entries) {
            if (file.dir) {
                log(`${indent}  [DIR] ${path}`);
                continue;
            }
            const fullPath = pathPrefix + path;
            
            if (path.toLowerCase().endsWith('.png')) {
                const filename = path.split('/').pop();
                const pathParts = fullPath.split('/').filter(p => p.length > 0);
                
                log(`${indent}  [PNG] ${fullPath}`);
                
                // Find the participant folder with format "Name_Number_..." 
                let folderNum = null;
                let partPath = null;
                
                // Look through path parts for folder matching "ParticipantName_Number_..."
                // Example: "Jiaxin L_11_Drawings 2"
                for (let i = 0; i < pathParts.length - 1; i++) {
                    const part = pathParts[i];
                    
                    // Pattern: "Name_Number" or "Name_Number_AnythingElse"
                    // Captures: participant name, folder number
                    const match = part.match(/^(.+?)_(\d+)(?:_.*)?$/);
                    if (match) {
                        partPath = match[1].trim();
                        folderNum = parseInt(match[2]);
                        log(`${indent}    Matched folder pattern: "${part}" ‚Üí participant="${partPath}", folderNum=${folderNum}`);
                        break;
                    }
                    
                    // Also check for purely numeric folders (backup)
                    if (/^\d+$/.test(part)) {
                        folderNum = parseInt(part);
                        // Look for participant in previous folder
                        if (i > 0) {
                            partPath = pathParts[i - 1];
                        }
                        log(`${indent}    Found numeric folder: ${part} ‚Üí folderNum=${folderNum}, participant=${partPath}`);
                        break;
                    }
                }
                
                // If still no participant, get from filename
                const participant = partPath || parseParticipant(filename);
                
                fileInfos.push({
                    filename,
                    file,
                    folderNum,
                    participant,
                    fullPath
                });
                
                log(`${indent}    Result: participant="${participant}", folderNum=${folderNum}, freq=${parseFreq(filename)}Hz`);
                
            } else if (path.toLowerCase().endsWith('.zip')) {
                // Handle nested ZIP files
                nestedZipCount++;
                log(`${indent}  [NESTED ZIP] ${path}`);
                try {
                    const blob = await file.async('blob');
                    const nested = await JSZip.loadAsync(blob);
                    log(`${indent}    Successfully loaded nested ZIP, processing contents...`);
                    await extractFromZip(nested, fullPath.replace(/\.zip$/i, '/'), depth + 1);
                    log(`${indent}    Finished processing nested ZIP: ${path}`);
                } catch (e) {
                    console.warn('Nested ZIP error:', path, e);
                    log(`${indent}    ‚ùå Warning: Could not process nested ZIP: ${path} - ${e.message}`);
                }
            } else {
                // Log other file types for debugging
                log(`${indent}  [SKIP] ${path} (not PNG or ZIP)`);
            }
        }
    }
    
    await extractFromZip(zip);
    log(`=== ZIP Processing Complete: ${fileInfos.length} PNG files, ${nestedZipCount} nested ZIPs processed ===`);
    return fileInfos;
}

async function handleZip(file) {
    document.getElementById('upload-log').innerHTML = '';
    document.getElementById('upload-log').classList.remove('hidden');
    log('=== Processing ZIP file ===');
    log(`Filename: ${file.name}`);
    status('Loading ZIP...');
    
    try {
        const infos = await processZip(file);
        log(`=== Found ${infos.length} PNG files total ===`);
        
        if (!infos.length) {
            status('No PNG files found in ZIP');
            return;
        }
        
        // Build participant -> folder numbers mapping
        const partFolders = {};
        for (const i of infos) {
            const p = i.participant;
            if (!partFolders[p]) partFolders[p] = new Set();
            if (i.folderNum !== null) {
                partFolders[p].add(i.folderNum);
            }
        }
        
        // Log what we found
        log('=== Participants and their folder numbers ===');
        for (const [p, folders] of Object.entries(partFolders)) {
            log(`  ${p}: folders = [${Array.from(folders).sort((a,b)=>a-b).join(', ')}]`);
        }
        
        // Map folder numbers to trial 1, 2, 3 (sorted lowest to highest)
        trialMapping = {};
        log('=== Trial Mapping ===');
        for (const [p, folders] of Object.entries(partFolders)) {
            const sorted = Array.from(folders).sort((a, b) => a - b);
            trialMapping[p.toLowerCase()] = {};
            sorted.forEach((fn, idx) => {
                trialMapping[p.toLowerCase()][fn] = idx + 1;
            });
            if (sorted.length > 0) {
                log(`  ${p}: folders [${sorted.join(', ')}] ‚Üí Trial [${sorted.map((_, i) => i + 1).join(', ')}]`);
            } else {
                log(`  ${p}: No folder numbers found - defaulting to Trial 1`);
            }
        }
        
        // Load images and build data structure
        const participants = new Map();
        let loadedCount = 0;
        let skippedCount = 0;
        
        log('=== Loading Images ===');
        for (const info of infos) {
            const hz = parseFreq(info.filename);
            const freq = FREQUENCIES.find(f => f.hz === hz);
            
            // Only process frequencies 62.5 to 2000 Hz
            if (!freq) {
                skippedCount++;
                continue;
            }
            
            const p = info.participant;
            
            // Get trial number from mapping
            let trialNum = 1;
            if (info.folderNum !== null && trialMapping[p.toLowerCase()] && trialMapping[p.toLowerCase()][info.folderNum]) {
                trialNum = trialMapping[p.toLowerCase()][info.folderNum];
            }
            const t = `Trial ${trialNum}`;
            
            // Load image
            const blob = await info.file.async('blob');
            const img = await loadImg(URL.createObjectURL(blob));
            
            const ik = `${p}|${t}|${fKey(freq)}`;
            images[ik] = img;
            
            // Build tab structure
            if (!participants.has(p)) participants.set(p, new Map());
            if (!participants.get(p).has(t)) participants.get(p).set(t, new Set());
            participants.get(p).get(t).add(freq.hz);
            
            ensureData(p, t, fKey(freq));
            loadedCount++;
        }
        
        if (!participants.size) {
            status('No valid images found (need 62.5-2000 Hz frequencies)');
            log(`Skipped ${skippedCount} files (outside 62.5-2000 Hz range)`);
            return;
        }
        
        // Log final structure
        log('=== Final Tab Structure ===');
        for (const [p, trials] of participants) {
            const trialList = Array.from(trials.keys()).sort();
            log(`  ${p}: ${trialList.length} trials - [${trialList.join(', ')}]`);
            for (const [t, freqs] of trials) {
                log(`    ${t}: ${freqs.size} frequencies - [${Array.from(freqs).sort((a,b)=>a-b).join(', ')}]`);
            }
        }
        
        log(`=== Summary: ${loadedCount} loaded, ${skippedCount} skipped ===`);
        
        buildTabs(participants);
        status(`Loaded ${loadedCount} images from ${participants.size} participants`);
        
    } catch (e) {
        console.error(e);
        status('Error: ' + e.message);
        log('ERROR: ' + e.message);
        log(e.stack);
    }
}

function loadImg(src) {
    return new Promise((res, rej) => {
        const img = new Image();
        img.onload = () => res(img);
        img.onerror = rej;
        img.src = src;
    });
}

async function handleSingle(file) {
    try {
        const img = await loadImg(URL.createObjectURL(file));
        const p = parseParticipant(file.name) || 'Participant';
        const t = 'Trial 1';
        const hz = parseFreq(file.name);
        const freq = hz ? FREQUENCIES.find(f => f.hz === hz) : FREQUENCIES[0];
        
        const ik = `${p}|${t}|${fKey(freq || FREQUENCIES[0])}`;
        images[ik] = img;
        ensureData(p, t, fKey(freq || FREQUENCIES[0]));
        
        const parts = new Map([[p, new Map([[t, new Set([freq?.hz || 62.5])]])]]);
        buildTabs(parts);
        status(`Loaded: ${file.name}`);
    } catch (e) {
        status('Error: ' + e.message);
    }
}

/**
 * Apply loaded settings to UI sliders and state variables.
 * Used by handleJson and loadFromCloud to avoid duplication.
 */
function applySettings(settings) {
    if (!settings) return;
    if (settings.resampleRate) {
        resampleRate = settings.resampleRate;
        document.getElementById('resample-slider').value = resampleRate;
        document.getElementById('resample-val').textContent = resampleRate;
    }
    if (settings.imageOpacity !== undefined) {
        IMAGE_OPACITY = settings.imageOpacity / 100;
        document.getElementById('img-opacity-slider').value = settings.imageOpacity;
        document.getElementById('img-opacity-val').textContent = settings.imageOpacity + '%';
    }
    if (settings.shapeOpacity !== undefined) {
        SHAPE_OPACITY = settings.shapeOpacity / 100;
        document.getElementById('shape-opacity-slider').value = settings.shapeOpacity;
        document.getElementById('shape-opacity-val').textContent = settings.shapeOpacity + '%';
    }
    if (settings.brushSize) {
        brushSize = settings.brushSize;
        document.getElementById('brush-slider').value = brushSize;
        document.getElementById('brush-val').textContent = brushSize;
    }
    if (settings.radialResolution) {
        radialResolution = settings.radialResolution;
        document.getElementById('radial-res-slider').value = radialResolution;
        document.getElementById('radial-res-val').textContent = radialResolution;
    }
}

function handleJson(file) {
    const r = new FileReader();
    r.onload = e => {
        try {
            const d = JSON.parse(e.target.result);
            if (d.allData) allData = d.allData;
            applySettings(d.settings);
            rebuildTabsFromData();
            status('JSON imported');
        } catch (e) {
            status('Error: ' + e.message);
        }
    };
    r.readAsText(file);
}

// ============================================
// TAB BUILDING
// ============================================
function buildTabs(participants) {
    const pSec = document.getElementById('participant-section');
    const tSec = document.getElementById('trial-section');
    const fSec = document.getElementById('frequency-section');
    const pTabs = document.getElementById('participant-tabs');
    const tTabs = document.getElementById('trial-tabs');
    const fTabs = document.getElementById('frequency-tabs');
    
    pTabs.innerHTML = '';
    tTabs.innerHTML = '';
    fTabs.innerHTML = '';
    
    pSec.classList.remove('hidden');
    tSec.classList.remove('hidden');
    fSec.classList.remove('hidden');
    document.getElementById('drawing-toolbar').classList.remove('hidden');
    
    const sortedP = Array.from(participants.keys()).sort();
    let first = true;
    
    for (const p of sortedP) {
        const btn = document.createElement('button');
        btn.className = `tab-btn px-4 py-2 rounded-xl font-bold text-sm bg-gray-100 shadow${first ? ' active' : ''}`;
        btn.textContent = p;
        btn.onclick = () => selectParticipant(p, participants, btn);
        pTabs.appendChild(btn);
        
        if (first) {
            curParticipant = p;
            buildTrialTabs(p, participants.get(p));
            first = false;
        }
    }
}

function buildTrialTabs(p, trials) {
    const tTabs = document.getElementById('trial-tabs');
    tTabs.innerHTML = '';
    
    const sorted = Array.from(trials.keys()).sort((a, b) => {
        const na = parseInt(a.replace(/\D/g, '')) || 0;
        const nb = parseInt(b.replace(/\D/g, '')) || 0;
        return na - nb;
    });
    
    let first = true;
    for (const t of sorted) {
        const btn = document.createElement('button');
        btn.className = `trial-btn tab-btn px-4 py-2 rounded-xl font-bold text-sm bg-gray-100 shadow${first ? ' active' : ''}`;
        btn.textContent = t;
        btn.onclick = () => selectTrial(t, trials.get(t), btn);
        tTabs.appendChild(btn);
        
        if (first) {
            curTrial = t;
            buildFreqTabs(trials.get(t));
            first = false;
        }
    }
}

function buildFreqTabs(freqs) {
    const fTabs = document.getElementById('frequency-tabs');
    fTabs.innerHTML = '';
    
    let first = true;
    for (const f of FREQUENCIES) {
        const btn = document.createElement('button');
        const hasImage = freqs && freqs.has(f.hz);
        // Check if there's traced data for this frequency even without an image
        const hasTracedData = curParticipant && curTrial && allData[curParticipant] && 
            allData[curParticipant][curTrial] && allData[curParticipant][curTrial][fKey(f)] &&
            (allData[curParticipant][curTrial][fKey(f)].red.length > 0 || 
             allData[curParticipant][curTrial][fKey(f)].blue.length > 0);
        
        // Visual styling: bright if has image, medium if has traced data only, dim if empty
        let btnClass = 'freq-btn tab-btn px-4 py-2 rounded-xl font-bold text-sm shadow ';
        if (hasImage) {
            btnClass += 'bg-gray-100';
        } else if (hasTracedData) {
            btnClass += 'bg-amber-50 text-amber-700';
        } else {
            btnClass += 'bg-gray-50 text-gray-500';
        }
        
        if (first) {
            btnClass += ' active';
            curFreq = f;
            first = false;
        }
        
        btn.className = btnClass;
        btn.textContent = `${f.hz} Hz`;
        // Never disable frequency tabs - allow drawing on any frequency
        btn.disabled = false;
        btn.onclick = () => selectFreq(f, btn);
        fTabs.appendChild(btn);
    }
    
    redraw();
}

function selectParticipant(p, participants, btn) {
    curParticipant = p;
    document.querySelectorAll('#participant-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    buildTrialTabs(p, participants.get(p));
    undoStack = []; redoStack = [];
    document.getElementById('undo-btn').disabled = true;
    document.getElementById('redo-btn').disabled = true;
}

function selectTrial(t, freqs, btn) {
    curTrial = t;
    document.querySelectorAll('#trial-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    buildFreqTabs(freqs);
    undoStack = []; redoStack = [];
    document.getElementById('undo-btn').disabled = true;
    document.getElementById('redo-btn').disabled = true;
}

function selectFreq(f, btn) {
    curFreq = f;
    document.querySelectorAll('#frequency-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    undoStack = []; redoStack = [];
    document.getElementById('undo-btn').disabled = true;
    document.getElementById('redo-btn').disabled = true;
    redraw();
    updateTable();
}

// ============================================
// AVERAGE SHAPES
// ============================================
function clearAvgCur() {
    // Clear all averages
    for (const p of Object.keys(allData)) {
        for (const t of Object.keys(allData[p])) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                d.redAvg = null;
                d.blueAvg = null;
            }
        }
    }
    frequencyAverages = {};
    redraw();
    updateGallery();
    
    // Clear frequency composites gallery
    const gallery = document.getElementById('freq-composites-gallery');
    gallery.innerHTML = '<div class="border-2 border-dashed border-emerald-200 rounded-xl p-6 text-center text-gray-400 text-sm col-span-full">Click "Generate Averages" to create composite images</div>';
    
    document.getElementById('freq-avg-status').textContent = 'All averages cleared';
    
    // Hide analysis panels
    document.getElementById('centroid-analysis').classList.add('hidden');
    document.getElementById('circle-approx-analysis').classList.add('hidden');
    
    status('Cleared all averages');
}

function openModal() {
    document.getElementById('modal').classList.add('active');
    const mf = document.getElementById('mod-f');
    mf.innerHTML = '';
    
    // Count shapes per frequency to show in the modal
    const freqCounts = {};
    for (const freq of FREQUENCIES) {
        freqCounts[freq.hz] = { red: 0, blue: 0 };
    }
    
    for (const p of Object.keys(allData)) {
        for (const t of Object.keys(allData[p])) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                const hz = parseFloat(fk);
                if (freqCounts[hz]) {
                    freqCounts[hz].red += d.red ? d.red.length : 0;
                    freqCounts[hz].blue += d.blue ? d.blue.length : 0;
                }
            }
        }
    }
    
    FREQUENCIES.forEach(f => {
        const counts = freqCounts[f.hz];
        const hasData = counts.red > 0 || counts.blue > 0;
        const countStr = hasData ? ` (R:${counts.red}, B:${counts.blue})` : ' (no data)';
        mf.innerHTML += `<label class="checkbox-item ${!hasData ? 'opacity-50' : ''}">
            <input type="checkbox" value="${f.hz}" ${hasData ? 'checked' : ''}>
            <span>${f.hz} Hz${countStr}</span>
        </label>`;
    });
}

function doBulk() {
    const selF = [...document.querySelectorAll('#mod-f input:checked')].map(c => parseFloat(c.value));
    
    if (selF.length === 0) {
        alert('Please select at least one frequency');
        return;
    }
    
    document.getElementById('modal').classList.remove('active');
    
    // Generate frequency averages for selected frequencies only
    const statusEl = document.getElementById('freq-avg-status');
    statusEl.textContent = 'Generating composites for selected frequencies...';
    
    let totalRed = 0, totalBlue = 0;
    
    // Only process selected frequencies
    for (const hz of selF) {
        const freq = FREQUENCIES.find(f => f.hz === hz);
        if (!freq) continue;
        
        frequencyAverages[hz] = {
            redShapes: [],
            blueShapes: [],
            redAvg: null,
            blueAvg: null,
            redCentroid: null,
            blueCentroid: null,
            redArea: 0,
            blueArea: 0
        };
        
        // Collect shapes for this frequency from all participants/trials
        for (const p of Object.keys(allData)) {
            for (const t of Object.keys(allData[p])) {
                for (const dataFk of Object.keys(allData[p][t])) {
                    const dataHz = parseFloat(dataFk);
                    if (Math.abs(dataHz - hz) < 0.1) {
                        const d = allData[p][t][dataFk];
                        if (d.red) {
                            d.red.forEach(shape => {
                                if (shape && shape.length > 2) {
                                    frequencyAverages[hz].redShapes.push(shape);
                                    totalRed++;
                                }
                            });
                        }
                        if (d.blue) {
                            d.blue.forEach(shape => {
                                if (shape && shape.length > 2) {
                                    frequencyAverages[hz].blueShapes.push(shape);
                                    totalBlue++;
                                }
                            });
                        }
                    }
                }
            }
        }
        
        // Calculate simple averages
        if (frequencyAverages[hz].redShapes.length > 0) {
            const avgShape = simpleAverageShapes(frequencyAverages[hz].redShapes);
            if (avgShape) {
                frequencyAverages[hz].redAvg = avgShape;
                frequencyAverages[hz].redCentroid = calculateCentroid(avgShape);
                frequencyAverages[hz].redArea = calculatePixelBasedArea(avgShape, brushSize);
            }
        }
        if (frequencyAverages[hz].blueShapes.length > 0) {
            const avgShape = simpleAverageShapes(frequencyAverages[hz].blueShapes);
            if (avgShape) {
                frequencyAverages[hz].blueAvg = avgShape;
                frequencyAverages[hz].blueCentroid = calculateCentroid(avgShape);
                frequencyAverages[hz].blueArea = calculatePixelBasedArea(avgShape, brushSize);
            }
        }
    }
    
    statusEl.textContent = `Generated composites for ${selF.length} frequencies (${totalRed} red, ${totalBlue} blue shapes)`;
    status(`Generated ${selF.length} frequency composites`);
    
    // Update the frequency composites gallery
    updateFreqCompositesGallery();
    updateCircleApproxAnalysis();
}

// ============================================
// CROSS-PARTICIPANT FREQUENCY AVERAGING
// ============================================

// Store frequency averages: { hz: { redAvg: [...], blueAvg: [...], redShapes: [...], blueShapes: [...] } }
let frequencyAverages = {};

/**
 * Calculate centroid using uniform path resampling to eliminate drawing-speed bias.
 * 
 * Methodology:
 * 1. Total path length is calculated
 * 2. Points are resampled at equal intervals: numSamples = max(100, totalLength / 0.1)
 * 3. Linear interpolation determines resampled positions
 * 4. Centroid is computed as arithmetic mean of resampled coordinates
 * 
 * This ensures equal contribution from all portions of the drawn path.
 * 
 * @param {Array} shape - Array of {x, y} points
 * @returns {{x: number, y: number}|null} Centroid coordinates, or null if invalid
 */
function calculateCentroid(shape) {
    // Return null for invalid input (caller should handle)
    if (!shape || shape.length === 0) return null;
    
    // Single point: centroid is that point
    if (shape.length === 1) return { x: shape[0].x, y: shape[0].y };
    
    // Step 1: Calculate total path length
    let totalLength = 0;
    const segmentLengths = [];
    
    for (let i = 0; i < shape.length - 1; i++) {
        const dx = shape[i + 1].x - shape[i].x;
        const dy = shape[i + 1].y - shape[i].y;
        const len = Math.sqrt(dx * dx + dy * dy);
        segmentLengths.push(len);
        totalLength += len;
    }
    
    // Handle degenerate case (all points at same location)
    // Return the first point's coordinates (they're all the same)
    if (totalLength < 0.0001) {
        return { x: shape[0].x, y: shape[0].y };
    }
    
    // Step 2: Determine number of samples
    // Use at least 100 samples, or 1 sample per 0.1 units of path length
    const numSamples = Math.max(100, Math.round(totalLength / 0.1));
    const intervalLength = totalLength / numSamples;
    
    // Step 3: Resample at equal intervals using linear interpolation
    let sumX = 0;
    let sumY = 0;
    let currentDist = 0;
    let segmentIdx = 0;
    
    for (let i = 0; i < numSamples; i++) {
        const targetDist = i * intervalLength;
        
        // Find the segment containing this distance
        while (segmentIdx < segmentLengths.length - 1 && 
               currentDist + segmentLengths[segmentIdx] < targetDist) {
            currentDist += segmentLengths[segmentIdx];
            segmentIdx++;
        }
        
        // Linear interpolation within the segment
        const segLen = segmentLengths[segmentIdx] || 0.0001;
        const t = segLen > 0 ? (targetDist - currentDist) / segLen : 0;
        const clampedT = Math.max(0, Math.min(1, t));
        
        const p1 = shape[segmentIdx];
        const p2 = shape[Math.min(segmentIdx + 1, shape.length - 1)];
        
        const resampledX = p1.x + clampedT * (p2.x - p1.x);
        const resampledY = p1.y + clampedT * (p2.y - p1.y);
        
        sumX += resampledX;
        sumY += resampledY;
    }
    
    // Step 4: Compute arithmetic mean of resampled coordinates
    return {
        x: sumX / numSamples,
        y: sumY / numSamples
    };
}

/**
 * Calculate area of a shape using the shoelace formula (for diagnostic/testing only)
 * 
 * NOTE: This function is NOT used for actual area calculations in the app.
 * All production area calculations use calculatePixelBasedArea() to match
 * the original drawing app methodology. This function is retained only for
 * diagnostic comparisons in the test functions.
 * 
 * @param {Array} shape - Array of {x, y} points
 * @returns {number} Area in square grid units
 */
function calculateAreaShoelace(shape) {
    if (!shape || shape.length < 3) return 0;
    let area = 0;
    for (let i = 0; i < shape.length; i++) {
        const j = (i + 1) % shape.length;
        area += shape[i].x * shape[j].y;
        area -= shape[j].x * shape[i].y;
    }
    return Math.abs(area) / 2;
}

// ============================================
// PIXEL-BASED AREA CALCULATION (MATCHING ORIGINAL DRAWING APP)
// ============================================

/**
 * Calculate path length of a shape in unit coordinates
 */
function calculatePathLength(unitPoints) {
    let length = 0;
    for (let i = 0; i < unitPoints.length - 1; i++) {
        const p1 = unitPoints[i];
        const p2 = unitPoints[i + 1];
        length += Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
    }
    return length;
}

/**
 * Calculate distance from point to line segment
 */
function distanceToSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lengthSquared = dx * dx + dy * dy;
    
    if (lengthSquared === 0) {
        return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
    }
    
    let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t));
    
    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;
    
    return Math.sqrt((px - closestX) * (px - closestX) + (py - closestY) * (py - closestY));
}

/**
 * Check if shape is closed (matching original app logic)
 * May modify unitPoints to add closure points if needed
 */
function isShapeClosedOriginal(unitPoints) {
    if (unitPoints.length < 10) return false;
    
    const first = unitPoints[0];
    const last = unitPoints[unitPoints.length - 1];
    
    const closureDistance = Math.sqrt(
        (last.x - first.x) ** 2 + (last.y - first.y) ** 2
    );
    
    const pathLength = calculatePathLength(unitPoints);
    const avgSegment = pathLength / (unitPoints.length - 1);
    
    const gapPercentage = (closureDistance / pathLength) * 100;
    
    // Calculate total angle change (rotation)
    let totalAngleChange = 0;
    
    for (let i = 1; i < unitPoints.length - 1; i++) {
        const p0 = unitPoints[i - 1];
        const p1 = unitPoints[i];
        const p2 = unitPoints[i + 1];
        
        const v1x = p1.x - p0.x;
        const v1y = p1.y - p0.y;
        const v2x = p2.x - p1.x;
        const v2y = p2.y - p1.y;
        
        const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
        const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
        
        if (mag1 > 0 && mag2 > 0) {
            const dot = v1x * v2x + v1y * v2y;
            const cosAngle = dot / (mag1 * mag2);
            const angle = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
            totalAngleChange += angle;
        }
    }
    
    const fullRotation = 2 * Math.PI;
    const rotationPercentage = (totalAngleChange / fullRotation) * 100;
    
    // Strategy 1: Very tight closure
    if (gapPercentage < 2.0) {
        if (closureDistance > avgSegment * 0.5) {
            const steps = Math.max(3, Math.ceil(closureDistance / avgSegment));
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                unitPoints.push({
                    x: last.x + (first.x - last.x) * t,
                    y: last.y + (first.y - last.y) * t
                });
            }
        }
        return true;
    }
    
    // Strategy 2: Good rotation with reasonable gap
    if (gapPercentage < 10.0 && rotationPercentage >= 70.0) {
        if (closureDistance > avgSegment * 0.5) {
            const steps = Math.max(3, Math.ceil(closureDistance / avgSegment));
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                unitPoints.push({
                    x: last.x + (first.x - last.x) * t,
                    y: last.y + (first.y - last.y) * t
                });
            }
        }
        return true;
    }
    
    // Strategy 3: Excellent rotation with slightly larger gap
    if (gapPercentage < 15.0 && rotationPercentage >= 85.0) {
        if (closureDistance > avgSegment * 0.5) {
            const steps = Math.max(3, Math.ceil(closureDistance / avgSegment));
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                unitPoints.push({
                    x: last.x + (first.x - last.x) * t,
                    y: last.y + (first.y - last.y) * t
                });
            }
        }
        return true;
    }
    
    return false;
}

/**
 * Point-in-polygon test using ray casting
 */
function isPointInPolygon(x, y, polygon) {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        
        const intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

/**
 * Pixel-based area calculation matching original drawing app methodology
 * 
 * This is the PRIMARY area calculation method used throughout the app.
 * It matches the original drawing app by:
 * 1. Computing brush radius as: brushSize / SCALE_FACTOR / 2
 * 2. Scanning a grid within the shape's bounding box (plus brush radius margin)
 * 3. Counting cells that are either:
 *    - Inside the polygon (for closed shapes), OR
 *    - Within brush radius of any path segment
 * 4. For closed shapes: subtracting outline area = perimeter * (brushRadius * 2) * 0.50
 * 
 * Closed shape detection uses gap percentage and rotation analysis, and may
 * add interpolated closure points between last and first point if needed.
 * 
 * @param {Array} unitPoints - Array of {x, y} points in unit coordinates (-10 to +10)
 * @param {number} brushSizePixels - Brush size in pixels (default 5, matching app default)
 * @param {number} resolution - Grid resolution for scanning in units (null for auto-select)
 * @returns {number} Area in square grid units
 */
function calculatePixelBasedArea(unitPoints, brushSizePixels = 5, resolution = null) {
    if (unitPoints.length === 0) return 0;
    
    // Make a copy to avoid modifying the original
    const points = unitPoints.map(p => ({ x: p.x, y: p.y }));
    
    const isClosed = isShapeClosedOriginal(points);
    
    // Match original app: brushRadius = brushSize / SCALE_FACTOR / 2
    // SCALE_FACTOR = 1000 / 20 = 50
    const fullBrushRadius = brushSizePixels / SCALE_FACTOR / 2;
    const brushRadius = fullBrushRadius;
    
    if (resolution === null) {
        if (brushRadius < 0.05) {
            resolution = 0.05;
        } else if (brushRadius < 0.1) {
            resolution = 0.075;
        } else {
            resolution = 0.1;
        }
    }
    
    // Find bounding box
    let minX = points[0].x, maxX = points[0].x;
    let minY = points[0].y, maxY = points[0].y;
    
    for (const p of points) {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
    }
    
    minX -= brushRadius;
    maxX += brushRadius;
    minY -= brushRadius;
    maxY += brushRadius;
    
    let paintedCells = 0;
    
    for (let x = minX; x <= maxX; x += resolution) {
        for (let y = minY; y <= maxY; y += resolution) {
            let isPainted = false;
            
            if (isClosed) {
                if (isPointInPolygon(x, y, points)) {
                    isPainted = true;
                } else {
                    for (let i = 0; i < points.length - 1; i++) {
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        const dist = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                        if (dist <= brushRadius) {
                            isPainted = true;
                            break;
                        }
                    }
                }
            } else {
                for (let i = 0; i < points.length - 1; i++) {
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const dist = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist <= brushRadius) {
                        isPainted = true;
                        break;
                    }
                }
            }
            
            if (isPainted) {
                paintedCells++;
            }
        }
    }
    
    const cellArea = resolution * resolution;
    const totalArea = paintedCells * cellArea;
    
    let adjustedArea = totalArea;
    
    // Subtract outline area for closed shapes (matching original app)
    if (isClosed) {
        let perimeter = 0;
        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            perimeter += Math.sqrt(dx * dx + dy * dy);
        }
        
        const outlineArea = perimeter * (brushRadius * 2) * 0.50;
        adjustedArea = Math.max(0, totalArea - outlineArea);
    }
    
    return adjustedArea;
}

// ============================================
// DIAGNOSTIC FUNCTIONS FOR DATA COMPARISON
// ============================================

/**
 * Run comprehensive diagnostics comparing tracing app data to expected values
 * Call from console: runDataDiagnostics()
 */
function runDataDiagnostics() {
    console.log('='.repeat(70));
    console.log('DATA DIAGNOSTICS: Comparing Tracing App to Original Drawing App');
    console.log('='.repeat(70));
    
    const targetFreqs = [500, 1000, 2000];
    
    for (const hz of targetFreqs) {
        const hzKey = String(hz);
        const data = frequencyAverages[hzKey];
        
        if (!data) {
            console.log(`\n${hz} Hz: No data found`);
            continue;
        }
        
        console.log(`\n${'='.repeat(50)}`);
        console.log(`${hz} Hz ANALYSIS`);
        console.log('='.repeat(50));
        
        // Shape counts
        console.log(`\nShape Counts:`);
        console.log(`  Red shapes: ${data.redShapes ? data.redShapes.length : 0}`);
        console.log(`  Blue shapes: ${data.blueShapes ? data.blueShapes.length : 0}`);
        
        // List participants for each shape
        if (data.redShapes && data.redShapes.length > 0) {
            console.log(`\nRed shapes breakdown:`);
            // We'd need to track source participant - for now just show count
        }
        
        // Centroid analysis for individual shapes
        console.log(`\n--- Individual Shape Centroids ---`);
        
        let redCentroids = [];
        let blueCentroids = [];
        
        if (data.redShapes) {
            data.redShapes.forEach((shape, idx) => {
                const c = calculateCentroid(shape);
                if (c && isFinite(c.x) && isFinite(c.y)) {
                    redCentroids.push(c);
                    console.log(`  Red[${idx}]: centroid=(${c.x.toFixed(4)}, ${c.y.toFixed(4)})`);
                }
            });
        }
        
        if (data.blueShapes) {
            data.blueShapes.forEach((shape, idx) => {
                const c = calculateCentroid(shape);
                if (c && isFinite(c.x) && isFinite(c.y)) {
                    blueCentroids.push(c);
                    console.log(`  Blue[${idx}]: centroid=(${c.x.toFixed(4)}, ${c.y.toFixed(4)})`);
                }
            });
        }
        
        // Mean of individual centroids
        if (redCentroids.length > 0) {
            const meanRedX = redCentroids.reduce((s, c) => s + c.x, 0) / redCentroids.length;
            const meanRedY = redCentroids.reduce((s, c) => s + c.y, 0) / redCentroids.length;
            console.log(`\n  Mean Red Centroid: (${meanRedX.toFixed(4)}, ${meanRedY.toFixed(4)})`);
        }
        
        if (blueCentroids.length > 0) {
            const meanBlueX = blueCentroids.reduce((s, c) => s + c.x, 0) / blueCentroids.length;
            const meanBlueY = blueCentroids.reduce((s, c) => s + c.y, 0) / blueCentroids.length;
            console.log(`  Mean Blue Centroid: (${meanBlueX.toFixed(4)}, ${meanBlueY.toFixed(4)})`);
        }
        
        // Shift from mean of individual centroids
        if (redCentroids.length > 0 && blueCentroids.length > 0) {
            const meanRedX = redCentroids.reduce((s, c) => s + c.x, 0) / redCentroids.length;
            const meanRedY = redCentroids.reduce((s, c) => s + c.y, 0) / redCentroids.length;
            const meanBlueX = blueCentroids.reduce((s, c) => s + c.x, 0) / blueCentroids.length;
            const meanBlueY = blueCentroids.reduce((s, c) => s + c.y, 0) / blueCentroids.length;
            
            const shiftFromMeans = Math.sqrt(
                (meanBlueX - meanRedX) ** 2 + (meanBlueY - meanRedY) ** 2
            );
            console.log(`\n  Shift (from mean of individual centroids): ${shiftFromMeans.toFixed(4)}`);
        }
        
        // Average contour analysis
        console.log(`\n--- Average Contour Analysis ---`);
        
        if (data.redAvg) {
            const avgRedCentroid = data.redCentroid;
            const pixelArea = calculatePixelBasedArea(data.redAvg, brushSize);
            const radius = Math.sqrt(pixelArea / Math.PI);
            
            console.log(`  Red Avg Contour:`);
            console.log(`    Centroid: (${avgRedCentroid.x.toFixed(4)}, ${avgRedCentroid.y.toFixed(4)})`);
            console.log(`    Area (pixel-based): ${pixelArea.toFixed(4)}`);
            console.log(`    Radius: ${radius.toFixed(4)}`);
        }
        
        if (data.blueAvg) {
            const avgBlueCentroid = data.blueCentroid;
            const pixelArea = calculatePixelBasedArea(data.blueAvg, brushSize);
            const radius = Math.sqrt(pixelArea / Math.PI);
            
            console.log(`  Blue Avg Contour:`);
            console.log(`    Centroid: (${avgBlueCentroid.x.toFixed(4)}, ${avgBlueCentroid.y.toFixed(4)})`);
            console.log(`    Area (pixel-based): ${pixelArea.toFixed(4)}`);
            console.log(`    Radius: ${radius.toFixed(4)}`);
        }
        
        // Shift from average contour centroids
        if (data.redCentroid && data.blueCentroid) {
            const shiftFromAvg = Math.sqrt(
                (data.blueCentroid.x - data.redCentroid.x) ** 2 +
                (data.blueCentroid.y - data.redCentroid.y) ** 2
            );
            console.log(`\n  Shift (from avg contour centroids): ${shiftFromAvg.toFixed(4)}`);
        }
        
        // Compare to manuscript values
        const manuscriptData = {
            500: { shift: 0.5287, r: 0.4209 },
            1000: { shift: 0.5032, r: 0.3775 },
            2000: { shift: 0.1688, r: 0.3543 }
        };
        
        if (manuscriptData[hz]) {
            console.log(`\n--- Comparison to Manuscript ---`);
            console.log(`  Manuscript Shift: ${manuscriptData[hz].shift}`);
            console.log(`  Manuscript r: ${manuscriptData[hz].r}`);
            
            if (data.redCentroid && data.blueCentroid) {
                const tracingShift = Math.sqrt(
                    (data.blueCentroid.x - data.redCentroid.x) ** 2 +
                    (data.blueCentroid.y - data.redCentroid.y) ** 2
                );
                const ratio = tracingShift / manuscriptData[hz].shift;
                console.log(`  Tracing App Shift: ${tracingShift.toFixed(4)}`);
                console.log(`  Ratio (Tracing/Manuscript): ${ratio.toFixed(4)}`);
            }
            
            if (data.redAvg) {
                const avgArea = calculatePixelBasedArea(data.redAvg, brushSize);
                const avgRadius = Math.sqrt(avgArea / Math.PI);
                const radiusRatio = avgRadius / manuscriptData[hz].r;
                console.log(`  Tracing App Red r: ${avgRadius.toFixed(4)}`);
                console.log(`  Radius Ratio (Tracing/Manuscript): ${radiusRatio.toFixed(4)}`);
            }
        }
    }
    
    console.log('\n' + '='.repeat(70));
    console.log('END DIAGNOSTICS');
    console.log('='.repeat(70));
}

/**
 * List all shapes by participant to identify duplicates
 * Call from console: listShapesByParticipant()
 */
function listShapesByParticipant() {
    console.log('='.repeat(70));
    console.log('SHAPES BY PARTICIPANT AND FREQUENCY');
    console.log('='.repeat(70));
    
    const shapesByFreqParticipant = {};
    
    for (const participant of Object.keys(allData)) {
        for (const trial of Object.keys(allData[participant])) {
            for (const freqKey of Object.keys(allData[participant][trial])) {
                const data = allData[participant][trial][freqKey];
                const hz = parseFloat(freqKey);
                
                if (!shapesByFreqParticipant[hz]) {
                    shapesByFreqParticipant[hz] = {};
                }
                
                const key = `${participant}|${trial}`;
                if (!shapesByFreqParticipant[hz][key]) {
                    shapesByFreqParticipant[hz][key] = { red: 0, blue: 0 };
                }
                
                shapesByFreqParticipant[hz][key].red += data.red ? data.red.length : 0;
                shapesByFreqParticipant[hz][key].blue += data.blue ? data.blue.length : 0;
            }
        }
    }
    
    const targetFreqs = [500, 1000, 2000];
    
    for (const hz of targetFreqs) {
        console.log(`\n${hz} Hz:`);
        const participants = shapesByFreqParticipant[hz];
        if (!participants) {
            console.log('  No data');
            continue;
        }
        
        let totalRed = 0, totalBlue = 0;
        for (const [key, counts] of Object.entries(participants)) {
            console.log(`  ${key}: Red=${counts.red}, Blue=${counts.blue}`);
            totalRed += counts.red;
            totalBlue += counts.blue;
        }
        console.log(`  TOTAL: Red=${totalRed}, Blue=${totalBlue}`);
    }
}

/**
 * Compare individual centroid calculation methods
 * Call from console: compareCentroidMethods()
 */
function compareCentroidMethods() {
    console.log('='.repeat(70));
    console.log('CENTROID METHOD COMPARISON');
    console.log('='.repeat(70));
    
    const targetFreqs = [500, 1000, 2000];
    
    for (const hz of targetFreqs) {
        const hzKey = String(hz);
        const data = frequencyAverages[hzKey];
        
        if (!data || !data.redShapes || data.redShapes.length === 0) {
            console.log(`\n${hz} Hz: No red shapes`);
            continue;
        }
        
        console.log(`\n${hz} Hz - First Red Shape Analysis:`);
        const shape = data.redShapes[0];
        
        // Method 1: Simple average (no resampling)
        let simpleX = 0, simpleY = 0;
        for (const p of shape) {
            simpleX += p.x;
            simpleY += p.y;
        }
        simpleX /= shape.length;
        simpleY /= shape.length;
        console.log(`  Simple average: (${simpleX.toFixed(4)}, ${simpleY.toFixed(4)})`);
        
        // Method 2: Resampled centroid (our method)
        const resampled = calculateCentroid(shape);
        console.log(`  Resampled centroid: (${resampled.x.toFixed(4)}, ${resampled.y.toFixed(4)})`);
        
        // Difference
        const diff = Math.sqrt((resampled.x - simpleX) ** 2 + (resampled.y - simpleY) ** 2);
        console.log(`  Difference: ${diff.toFixed(4)} units`);
    }
}

/**
 * Normalize contour to start at highest Y point and go counterclockwise
 * 
 * Steps:
 * 1. Find the point with the highest Y value (topmost in grid coordinates)
 *    - If there are ties, choose the one with the highest X value
 * 2. Rotate the contour so that point becomes index 0
 * 3. Ensure counterclockwise winding (positive signed area)
 * 
 * @param {Array} shape - Array of {x, y} points
 * @returns {Array} Normalized contour
 */
function normalizeContour(shape) {
    if (!shape || shape.length < 3) return shape;
    
    // Step 1: Find the index of the highest Y point
    // If there are ties, choose the one with highest X
    let highestIdx = 0;
    let highestY = shape[0].y;
    let highestX = shape[0].x;
    
    for (let i = 1; i < shape.length; i++) {
        if (shape[i].y > highestY || 
            (shape[i].y === highestY && shape[i].x > highestX)) {
            highestY = shape[i].y;
            highestX = shape[i].x;
            highestIdx = i;
        }
    }
    
    // Step 2: Rotate array so highest Y point becomes index 0
    const rotated = [];
    for (let i = 0; i < shape.length; i++) {
        rotated.push(shape[(i + highestIdx) % shape.length]);
    }
    
    // Step 3: Calculate signed area to determine winding direction
    // Positive = counterclockwise, Negative = clockwise
    let signedArea = 0;
    for (let i = 0; i < rotated.length; i++) {
        const j = (i + 1) % rotated.length;
        signedArea += rotated[i].x * rotated[j].y;
        signedArea -= rotated[j].x * rotated[i].y;
    }
    
    // If clockwise (negative signed area), reverse to make counterclockwise
    if (signedArea < 0) {
        // Keep the first point (highest Y) at index 0, reverse the rest
        const reversed = [rotated[0]];
        for (let i = rotated.length - 1; i > 0; i--) {
            reversed.push(rotated[i]);
        }
        return reversed;
    }
    
    return rotated;
}

/**
 * Average shapes using equal-weight polar/radial coordinate averaging
 * 
 * Process:
 * 1. Calculate centroid of each shape (uniform path-resampled mean)
 * 2. Convert each shape to polar coordinates (angle -> distance from centroid)
 * 3. Sample radial distance at uniform angles (0 to 2*PI in radialResolution steps)
 * 4. Compute the simple arithmetic mean of radial distances at each angle
 *    (every shape contributes equally regardless of size)
 * 5. Convert back to Cartesian coordinates at the unweighted average centroid
 * 6. Normalize output to start at highest Y (with highest X tiebreaker), counterclockwise
 * 
 * The centroid of the average shape is a simple geometric average (unweighted)
 * of individual shape centroids.
 * 
 * This method avoids point correspondence issues because we're averaging
 * "how far the shape extends in each direction" rather than trying to
 * match points along the perimeter.
 */
function simpleAverageShapes(shapes) {
    if (!shapes || shapes.length === 0) return null;
    
    // Filter out invalid shapes (need at least 3 points to form a polygon)
    const validShapes = shapes.filter(s => s && s.length >= 3);
    if (validShapes.length === 0) return null;
    
    if (validShapes.length === 1) {
        return normalizeContour(validShapes[0]);
    }
    
    // Step 1: Calculate centroid of each shape
    const centroids = validShapes.map(shape => calculateCentroid(shape));
    
    // Filter out any shapes with invalid centroids (safeguard)
    const validIndices = [];
    for (let i = 0; i < centroids.length; i++) {
        if (centroids[i] && isFinite(centroids[i].x) && isFinite(centroids[i].y)) {
            validIndices.push(i);
        }
    }
    
    if (validIndices.length === 0) return null;
    if (validIndices.length === 1) {
        return normalizeContour(validShapes[validIndices[0]]);
    }
    
    // Calculate average centroid position (simple geometric mean, unweighted)
    let avgCentroidX = 0, avgCentroidY = 0;
    for (const idx of validIndices) {
        avgCentroidX += centroids[idx].x;
        avgCentroidY += centroids[idx].y;
    }
    avgCentroidX /= validIndices.length;
    avgCentroidY /= validIndices.length;
    
    // Equal-weight averaging: every shape contributes equally regardless of size.
    const equalWeight = 1 / validIndices.length;
    
    console.log(`[Radial Average] Equal weights: ${validIndices.length} shapes, weight = ${equalWeight.toFixed(4)} each`);
    
    // Step 2 & 3: Convert each shape to radial samples (distance at each angle)
    const numAngles = radialResolution;
    const radialSamples = validIndices.map(shapeIdx => {
        const shape = validShapes[shapeIdx];
        const centroid = centroids[shapeIdx];
        
        // For each angle, find the distance to the shape boundary
        const distances = new Array(numAngles).fill(0);
        
        for (let angleDeg = 0; angleDeg < numAngles; angleDeg++) {
            const angleRad = (angleDeg / numAngles) * 2 * Math.PI;
            const rayDirX = Math.cos(angleRad);
            const rayDirY = Math.sin(angleRad);
            
            // Find intersection of ray from centroid with shape boundary
            // Use the furthest intersection point
            let maxDist = 0;
            
            for (let i = 0; i < shape.length; i++) {
                const p1 = shape[i];
                const p2 = shape[(i + 1) % shape.length];
                
                // Ray-segment intersection
                const dist = raySegmentIntersection(
                    centroid.x, centroid.y,
                    rayDirX, rayDirY,
                    p1.x, p1.y,
                    p2.x, p2.y
                );
                
                if (dist !== null && dist > maxDist) {
                    maxDist = dist;
                }
            }
            
            distances[angleDeg] = maxDist;
        }
        
        return distances;
    });
    
    // Step 4: Simple (equal-weight) average of radial distances at each angle.
    const avgDistances = new Array(numAngles).fill(0);
    for (let angleDeg = 0; angleDeg < numAngles; angleDeg++) {
        let sum = 0;
        for (let s = 0; s < radialSamples.length; s++) {
            sum += radialSamples[s][angleDeg];
        }
        avgDistances[angleDeg] = sum * equalWeight;
    }
    
    // Step 5: Convert back to Cartesian coordinates
    // Angles span 0 to 2*PI in numAngles steps, producing counterclockwise order
    const rawAvgShape = [];
    for (let angleDeg = 0; angleDeg < numAngles; angleDeg++) {
        const angleRad = (angleDeg / numAngles) * 2 * Math.PI;
        const dist = avgDistances[angleDeg];
        rawAvgShape.push({
            x: avgCentroidX + dist * Math.cos(angleRad),
            y: avgCentroidY + dist * Math.sin(angleRad)
        });
    }
    
    // Step 6: Normalize output to start at highest Y point (with highest X as tiebreaker)
    // and ENFORCE counterclockwise direction regardless of input drawing direction.
    // normalizeContour:
    //   a) Finds highest Y point (highest X tiebreaker)
    //   b) Rotates array so that point becomes index 0
    //   c) Checks signed area; reverses if clockwise
    const avgShape = normalizeContour(rawAvgShape);
    
    // Step 7: Verify normalization (defensive check)
    if (avgShape && avgShape.length >= 3) {
        let verifySignedArea = 0;
        for (let i = 0; i < avgShape.length; i++) {
            const j = (i + 1) % avgShape.length;
            verifySignedArea += avgShape[i].x * avgShape[j].y;
            verifySignedArea -= avgShape[j].x * avgShape[i].y;
        }
        if (verifySignedArea < 0) {
            console.warn('[Radial Average] WARNING: Output shape is clockwise after normalization - forcing CCW');
            const fixed = [avgShape[0]];
            for (let i = avgShape.length - 1; i > 0; i--) {
                fixed.push(avgShape[i]);
            }
            console.log(`[Radial Average] ${validIndices.length} shapes averaged (equal-weight), avg centroid: (${avgCentroidX.toFixed(2)}, ${avgCentroidY.toFixed(2)})`);
            return fixed;
        }
    }
    
    console.log(`[Radial Average] ${validIndices.length} shapes averaged (equal-weight), avg centroid: (${avgCentroidX.toFixed(2)}, ${avgCentroidY.toFixed(2)})`);
    
    return avgShape;
}

/**
 * Calculate intersection of a ray with a line segment
 * Returns distance along ray if intersection exists, null otherwise
 * 
 * @param {number} rayX, rayY - Ray origin
 * @param {number} rayDirX, rayDirY - Ray direction (should be normalized)
 * @param {number} p1x, p1y - Segment start
 * @param {number} p2x, p2y - Segment end
 * @returns {number|null} Distance along ray to intersection, or null
 */
function raySegmentIntersection(rayX, rayY, rayDirX, rayDirY, p1x, p1y, p2x, p2y) {
    const segDirX = p2x - p1x;
    const segDirY = p2y - p1y;
    
    const denom = rayDirX * segDirY - rayDirY * segDirX;
    
    // Parallel check
    if (Math.abs(denom) < 1e-10) return null;
    
    const t = ((p1x - rayX) * segDirY - (p1y - rayY) * segDirX) / denom;
    const u = ((p1x - rayX) * rayDirY - (p1y - rayY) * rayDirX) / denom;
    
    // Check if intersection is on the ray (t >= 0) and on the segment (0 <= u <= 1)
    if (t >= 0 && u >= 0 && u <= 1) {
        return t;
    }
    
    return null;
}

/**
 * Generate average shapes across ALL participants for each frequency
 * 
 * Process:
 * 1. Collect all shapes for each frequency
 * 2. Average them using contour normalization (start at highest Y, counterclockwise)
 * 3. Calculate area and centroid on the AVERAGE shape only
 */
function generateFrequencyAverages() {
    const statusEl = document.getElementById('freq-avg-status');
    statusEl.textContent = 'Generating frequency averages...';
    
    frequencyAverages = {};
    let totalRed = 0, totalBlue = 0;
    
    // Collect all shapes by frequency
    for (const freq of FREQUENCIES) {
        const fk = fKey(freq);
        const hzKey = freq.hz;
        
        frequencyAverages[hzKey] = {
            redShapes: [],
            blueShapes: [],
            redAvg: null,
            blueAvg: null,
            redCentroid: null,
            blueCentroid: null,
            redArea: 0,
            blueArea: 0
        };
        
        // Iterate through all participants and trials
        for (const p of Object.keys(allData)) {
            for (const t of Object.keys(allData[p])) {
                // Find matching frequency key
                for (const dataFk of Object.keys(allData[p][t])) {
                    // Match by frequency value (ignore dB)
                    const dataHz = parseFloat(dataFk);
                    if (Math.abs(dataHz - freq.hz) < 0.1) {
                        const d = allData[p][t][dataFk];
                        if (d.red) {
                            d.red.forEach(shape => {
                                if (shape && shape.length > 2) {
                                    frequencyAverages[hzKey].redShapes.push(shape);
                                    totalRed++;
                                }
                            });
                        }
                        if (d.blue) {
                            d.blue.forEach(shape => {
                                if (shape && shape.length > 2) {
                                    frequencyAverages[hzKey].blueShapes.push(shape);
                                    totalBlue++;
                                }
                            });
                        }
                    }
                }
            }
        }
        
        // Calculate simple averages
        if (frequencyAverages[hzKey].redShapes.length > 0) {
            const avgShape = simpleAverageShapes(frequencyAverages[hzKey].redShapes);
            if (avgShape) {
                frequencyAverages[hzKey].redAvg = avgShape;
                frequencyAverages[hzKey].redCentroid = calculateCentroid(avgShape);
                frequencyAverages[hzKey].redArea = calculatePixelBasedArea(avgShape, brushSize);
            }
        }
        if (frequencyAverages[hzKey].blueShapes.length > 0) {
            const avgShape = simpleAverageShapes(frequencyAverages[hzKey].blueShapes);
            if (avgShape) {
                frequencyAverages[hzKey].blueAvg = avgShape;
                frequencyAverages[hzKey].blueCentroid = calculateCentroid(avgShape);
                frequencyAverages[hzKey].blueArea = calculatePixelBasedArea(avgShape, brushSize);
            }
        }
    }
    
    // Count frequencies with averages
    let freqsWithData = 0;
    for (const hz of Object.keys(frequencyAverages)) {
        if (frequencyAverages[hz].redAvg || frequencyAverages[hz].blueAvg) {
            freqsWithData++;
        }
    }
    
    statusEl.textContent = `Generated averages for ${freqsWithData} frequencies (${totalRed} red shapes, ${totalBlue} blue shapes)`;
    status(`Frequency averages generated: ${freqsWithData} frequencies`);
    
    // Update the frequency composites gallery
    updateFreqCompositesGallery();
    updateCircleApproxAnalysis();
}

/**
 * Update the frequency composites gallery with generated averages
 * Shows all individual traced shapes at low opacity with average shape on top
 * Area and centroid are calculated on the AVERAGE shape only
 */
function updateFreqCompositesGallery() {
    const gallery = document.getElementById('freq-composites-gallery');
    gallery.innerHTML = '';
    
    let hasData = false;
    
    // Sort frequencies numerically
    const sortedFreqs = Object.keys(frequencyAverages).sort((a, b) => parseFloat(a) - parseFloat(b));
    
    for (const hzKey of sortedFreqs) {
        const data = frequencyAverages[hzKey];
        
        // Only show if there's any data
        if (data.redShapes.length === 0 && data.blueShapes.length === 0) continue;
        
        hasData = true;
        
        // Area and centroid are already calculated by generateFrequencyAverages() or doBulk()
        // Only recalculate if missing (defensive check)
        if (data.redAvg && !data.redCentroid) {
            data.redCentroid = calculateCentroid(data.redAvg);
        }
        if (data.redAvg && !data.redArea) {
            data.redArea = calculatePixelBasedArea(data.redAvg, brushSize);
        }
        if (data.blueAvg && !data.blueCentroid) {
            data.blueCentroid = calculateCentroid(data.blueAvg);
        }
        if (data.blueAvg && !data.blueArea) {
            data.blueArea = calculatePixelBasedArea(data.blueAvg, brushSize);
        }
        
        // Create card
        const card = document.createElement('div');
        card.className = 'bg-white rounded-xl p-3 border border-emerald-200 shadow-sm';
        
        // Create canvas (larger for better detail)
        const cv = document.createElement('canvas');
        cv.width = 400;
        cv.height = 400;
        cv.className = 'w-full rounded-lg border bg-white mb-2';
        const cx = cv.getContext('2d');
        
        // White background
        cx.fillStyle = 'white';
        cx.fillRect(0, 0, 400, 400);
        
        const scale = 400 / CANVAS_SIZE;
        
        // Draw grid first (background)
        drawCompositeGrid(cx, 400);
        
        // Draw all individual traced shapes at low opacity (NO centroid markers)
        const traceOpacity = 0.25;
        data.redShapes.forEach(shape => {
            drawCompositeShape(cx, shape, COLORS.red, scale, traceOpacity, 1.5);
        });
        data.blueShapes.forEach(shape => {
            drawCompositeShape(cx, shape, COLORS.blue, scale, traceOpacity, 1.5);
        });
        
        // Draw average shapes at full opacity with thicker lines
        if (data.redAvg) {
            drawCompositeShape(cx, data.redAvg, '#991b1b', scale, 1, 3);
        }
        if (data.blueAvg) {
            drawCompositeShape(cx, data.blueAvg, '#1e3a8a', scale, 1, 3);
        }
        
        // Draw centroid markers (+ signs) for average shapes
        if (redCentroid) {
            drawCentroidMarker(cx, redCentroid, '#991b1b', scale);
        }
        if (blueCentroid) {
            drawCentroidMarker(cx, blueCentroid, '#1e3a8a', scale);
        }
        
        card.appendChild(cv);
        
        // Stats - show area and centroid of AVERAGE shapes
        const statsDiv = document.createElement('div');
        statsDiv.className = 'text-xs space-y-1';
        
        const redAreaText = data.redAvg ? `area: ${redAvgArea.toFixed(2)}` : '';
        const blueAreaText = data.blueAvg ? `area: ${blueAvgArea.toFixed(2)}` : '';
        
        const redCentroidText = redCentroid ? ` | centroid: (${redCentroid.x.toFixed(2)}, ${redCentroid.y.toFixed(2)})` : '';
        const blueCentroidText = blueCentroid ? ` | centroid: (${blueCentroid.x.toFixed(2)}, ${blueCentroid.y.toFixed(2)})` : '';
        
        statsDiv.innerHTML = `
            <p class="font-bold text-emerald-700">${hzKey} Hz</p>
            <p class="text-red-600">Red: ${data.redShapes.length} shapes${redAreaText ? ', ' + redAreaText : ''}${redCentroidText}</p>
            <p class="text-blue-600">Blue: ${data.blueShapes.length} shapes${blueAreaText ? ', ' + blueAreaText : ''}${blueCentroidText}</p>
        `;
        card.appendChild(statsDiv);
        
        gallery.appendChild(card);
    }
    
    if (!hasData) {
        gallery.innerHTML = '<div class="border-2 border-dashed border-emerald-200 rounded-xl p-6 text-center text-gray-400 text-sm col-span-full">No traced shapes found. Load or trace some data first.</div>';
    }
    
    // ================================================================
    // Centroid Shift Analysis: mean-of-centroids vs centroid-of-average
    // ================================================================
    const analysisPanel = document.getElementById('centroid-analysis');
    const analysisTable = document.getElementById('centroid-analysis-table');
    
    if (!hasData) {
        analysisPanel.classList.add('hidden');
        return;
    }
    
    analysisPanel.classList.remove('hidden');
    
    // Build analysis data for each frequency
    const rows = [];
    
    for (const hzKey of sortedFreqs) {
        const data = frequencyAverages[hzKey];
        if (data.redShapes.length === 0 && data.blueShapes.length === 0) continue;
        
        // --- Method A: Mean of individual shape centroids ---
        // Compute centroid of each individual shape, then average those centroids
        let meanRedCentroid = null;
        let meanBlueCentroid = null;
        let redIndividualCentroids = [];
        let blueIndividualCentroids = [];
        
        if (data.redShapes.length > 0) {
            for (const shape of data.redShapes) {
                const c = calculateCentroid(shape);
                if (c && isFinite(c.x) && isFinite(c.y)) {
                    redIndividualCentroids.push(c);
                }
            }
            if (redIndividualCentroids.length > 0) {
                let sx = 0, sy = 0;
                for (const c of redIndividualCentroids) { sx += c.x; sy += c.y; }
                meanRedCentroid = { x: sx / redIndividualCentroids.length, y: sy / redIndividualCentroids.length };
            }
        }
        
        if (data.blueShapes.length > 0) {
            for (const shape of data.blueShapes) {
                const c = calculateCentroid(shape);
                if (c && isFinite(c.x) && isFinite(c.y)) {
                    blueIndividualCentroids.push(c);
                }
            }
            if (blueIndividualCentroids.length > 0) {
                let sx = 0, sy = 0;
                for (const c of blueIndividualCentroids) { sx += c.x; sy += c.y; }
                meanBlueCentroid = { x: sx / blueIndividualCentroids.length, y: sy / blueIndividualCentroids.length };
            }
        }
        
        // Mean-of-centroids shift
        let meanShift = null;
        if (meanRedCentroid && meanBlueCentroid) {
            meanShift = Math.sqrt(
                Math.pow(meanBlueCentroid.x - meanRedCentroid.x, 2) +
                Math.pow(meanBlueCentroid.y - meanRedCentroid.y, 2)
            );
        }
        
        // --- Method B: Centroid of the averaged contour ---
        // Already computed as data.redCentroid and data.blueCentroid
        let contourShift = null;
        if (data.redCentroid && data.blueCentroid) {
            contourShift = Math.sqrt(
                Math.pow(data.blueCentroid.x - data.redCentroid.x, 2) +
                Math.pow(data.blueCentroid.y - data.redCentroid.y, 2)
            );
        }
        
        // Discrepancy
        let discrepancy = null;
        let discrepancyPct = null;
        if (meanShift !== null && contourShift !== null && meanShift > 1e-8) {
            discrepancy = contourShift - meanShift;
            discrepancyPct = ((contourShift - meanShift) / meanShift) * 100;
        }
        
        // Standard deviation of individual centroid shifts (per-shape red-to-blue)
        // Only meaningful if both colors have shapes; pair by index up to min count
        let individualShifts = [];
        if (redIndividualCentroids.length > 0 && blueIndividualCentroids.length > 0) {
            // Compute shift for each individual shape pair (matched by index)
            // If unequal counts, also compute each blue centroid vs mean red centroid
            for (const bc of blueIndividualCentroids) {
                if (meanRedCentroid) {
                    individualShifts.push(Math.sqrt(
                        Math.pow(bc.x - meanRedCentroid.x, 2) +
                        Math.pow(bc.y - meanRedCentroid.y, 2)
                    ));
                }
            }
        }
        let shiftSD = null;
        if (individualShifts.length > 1) {
            const mean = individualShifts.reduce((a, b) => a + b, 0) / individualShifts.length;
            const variance = individualShifts.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (individualShifts.length - 1);
            shiftSD = Math.sqrt(variance);
        }
        
        rows.push({
            hz: parseFloat(hzKey),
            hzKey,
            nRed: redIndividualCentroids.length,
            nBlue: blueIndividualCentroids.length,
            meanRedCentroid,
            meanBlueCentroid,
            meanShift,
            contourRedCentroid: data.redCentroid,
            contourBlueCentroid: data.blueCentroid,
            contourShift,
            discrepancy,
            discrepancyPct,
            shiftSD
        });
    }
    
    // Render the analysis table
    let html = `<table class="w-full text-xs border-collapse">
        <thead>
            <tr class="bg-emerald-100 text-left">
                <th class="p-2 font-semibold border-b border-emerald-300">Freq</th>
                <th class="p-2 font-semibold border-b border-emerald-300">N (R/B)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Mean of Centroids (Red)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Mean of Centroids (Blue)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Centroid of Avg Contour (Red)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Centroid of Avg Contour (Blue)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Shift (Mean of Centroids)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Shift (Avg Contour)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Discrepancy</th>
                <th class="p-2 font-semibold border-b border-emerald-300">SD of Individual Shifts</th>
            </tr>
        </thead><tbody>`;
    
    for (const r of rows) {
        const fmtC = c => c ? `(${c.x.toFixed(3)}, ${c.y.toFixed(3)})` : '-';
        const fmtV = v => v !== null ? v.toFixed(4) : '-';
        const fmtPct = v => v !== null ? `${v >= 0 ? '+' : ''}${v.toFixed(1)}%` : '-';
        
        // Color discrepancy cell: green if small (<20%), yellow if moderate, red if large
        let discClass = 'text-gray-600';
        if (r.discrepancyPct !== null) {
            const abs = Math.abs(r.discrepancyPct);
            if (abs > 50) discClass = 'text-red-700 font-bold';
            else if (abs > 20) discClass = 'text-amber-700 font-semibold';
            else discClass = 'text-green-700';
        }
        
        html += `<tr class="border-b border-gray-200 hover:bg-emerald-50">
            <td class="p-2 font-semibold">${r.hzKey} Hz</td>
            <td class="p-2 font-mono">${r.nRed} / ${r.nBlue}</td>
            <td class="p-2 font-mono text-red-600">${fmtC(r.meanRedCentroid)}</td>
            <td class="p-2 font-mono text-blue-600">${fmtC(r.meanBlueCentroid)}</td>
            <td class="p-2 font-mono text-red-600">${fmtC(r.contourRedCentroid)}</td>
            <td class="p-2 font-mono text-blue-600">${fmtC(r.contourBlueCentroid)}</td>
            <td class="p-2 font-mono font-semibold">${fmtV(r.meanShift)}</td>
            <td class="p-2 font-mono font-semibold">${fmtV(r.contourShift)}</td>
            <td class="p-2 font-mono ${discClass}">${fmtV(r.discrepancy)} (${fmtPct(r.discrepancyPct)})</td>
            <td class="p-2 font-mono">${fmtV(r.shiftSD)}</td>
        </tr>`;
    }
    
    html += '</tbody></table>';
    
    // Add interpretation note
    html += `<div class="mt-3 text-xs text-gray-500 space-y-1">
        <p><span class="font-semibold">Mean of Centroids:</span> Arithmetic mean of each individual shape's centroid position, computed separately for red and blue. The shift is the Euclidean distance between these two mean positions.</p>
        <p><span class="font-semibold">Centroid of Avg Contour:</span> Geometric centroid of the equal-weight average contour shape. The shift is the Euclidean distance between the red and blue average contour centroids.</p>
        <p><span class="font-semibold">Discrepancy:</span> Difference between the two shift values. Large positive values indicate the averaging procedure amplifies centroid separation due to correlated shape asymmetries in the averaged contour.</p>
        <p><span class="font-semibold">SD of Individual Shifts:</span> Standard deviation of each blue shape's distance from the mean red centroid. High values indicate large inter-participant variability in perceived lateralization.</p>
    </div>`;
    
    analysisTable.innerHTML = html;
    
    // Console log for quick reference
    console.log('[Centroid Analysis] Frequency | Mean-of-Centroids Shift | Contour-Centroid Shift | Discrepancy');
    for (const r of rows) {
        const ms = r.meanShift !== null ? r.meanShift.toFixed(4) : 'N/A';
        const cs = r.contourShift !== null ? r.contourShift.toFixed(4) : 'N/A';
        const dp = r.discrepancyPct !== null ? `${r.discrepancyPct.toFixed(1)}%` : 'N/A';
        console.log(`[Centroid Analysis] ${r.hzKey} Hz | ${ms} | ${cs} | ${dp}`);
    }
}

/**
 * Circle Approximation & Shift Analysis
 * 
 * Displays analysis of frequency-averaged contours as equivalent circles:
 * - Area: Calculated using pixel-based method matching original drawing app
 * - Radius: r = sqrt(area / pi) - the radius of a perfect circle with same area
 * - Center: Centroid of the average contour (calculated via uniform path resampling)
 * - Shift: Euclidean distance between red (0¬∞ IPD) and blue (90¬∞ IPD) centroids
 * 
 * Also shows comparison to manuscript values for 500, 1000, 2000 Hz with ratios
 * to help identify discrepancies between tracing app and original data.
 */
function updateCircleApproxAnalysis() {
    const panel = document.getElementById('circle-approx-analysis');
    const tableDiv = document.getElementById('circle-approx-table');
    
    const sortedFreqs = Object.keys(frequencyAverages)
        .map(Number)
        .sort((a, b) => a - b)
        .map(String);
    
    if (sortedFreqs.length === 0) {
        panel.classList.add('hidden');
        return;
    }
    
    panel.classList.remove('hidden');
    
    // Manuscript comparison data
    const manuscriptData = {
        '500': { shift: 0.5287, r: 0.4209 },
        '1000': { shift: 0.5032, r: 0.3775 },
        '2000': { shift: 0.1688, r: 0.3543 }
    };
    
    const rows = [];
    
    for (const hzKey of sortedFreqs) {
        const data = frequencyAverages[hzKey];
        
        // Pixel-based calculations (matching original drawing app)
        let redRadius = null, blueRadius = null;
        if (data.redArea > 0) {
            redRadius = Math.sqrt(data.redArea / Math.PI);
        }
        if (data.blueArea > 0) {
            blueRadius = Math.sqrt(data.blueArea / Math.PI);
        }
        
        const redCenter = data.redCentroid;
        const blueCenter = data.blueCentroid;
        
        // Shift between circle centers
        let shift = null;
        let shiftX = null, shiftY = null;
        if (redCenter && blueCenter) {
            shiftX = blueCenter.x - redCenter.x;
            shiftY = blueCenter.y - redCenter.y;
            shift = Math.sqrt(shiftX * shiftX + shiftY * shiftY);
        }
        
        // Manuscript comparison
        const ms = manuscriptData[hzKey];
        let shiftRatio = null, radiusRatio = null;
        if (ms && shift !== null) {
            shiftRatio = shift / ms.shift;
        }
        if (ms && redRadius !== null) {
            radiusRatio = redRadius / ms.r;
        }
        
        rows.push({
            hz: parseFloat(hzKey),
            hzKey,
            redArea: data.redArea || null,
            blueArea: data.blueArea || null,
            redRadius,
            blueRadius,
            redCenter,
            blueCenter,
            shiftX,
            shiftY,
            shift,
            nRed: data.redShapes ? data.redShapes.length : 0,
            nBlue: data.blueShapes ? data.blueShapes.length : 0,
            manuscriptShift: ms ? ms.shift : null,
            manuscriptR: ms ? ms.r : null,
            shiftRatio,
            radiusRatio
        });
    }
    
    // Render main data table
    let html = `
    <p class="text-sm font-semibold text-emerald-700 mb-2">Pixel-Based Area (matching original drawing app methodology):</p>
    <table class="w-full text-xs border-collapse mb-4">
        <thead>
            <tr class="bg-emerald-100 text-left">
                <th class="p-2 font-semibold border-b border-emerald-300">Freq</th>
                <th class="p-2 font-semibold border-b border-emerald-300">N (R/B)</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Red Area</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Red r</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Red Center</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Blue Area</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Blue r</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Blue Center</th>
                <th class="p-2 font-semibold border-b border-emerald-300">Shift</th>
            </tr>
        </thead><tbody>`;
    
    for (const r of rows) {
        const fmtV = v => v !== null ? v.toFixed(4) : '-';
        const fmtC = c => c ? `(${c.x.toFixed(3)}, ${c.y.toFixed(3)})` : '-';
        html += `<tr class="border-b border-gray-200 hover:bg-emerald-50">
            <td class="p-2 font-semibold">${r.hzKey} Hz</td>
            <td class="p-2 font-mono">${r.nRed} / ${r.nBlue}</td>
            <td class="p-2 font-mono text-red-600">${fmtV(r.redArea)}</td>
            <td class="p-2 font-mono text-red-600">${fmtV(r.redRadius)}</td>
            <td class="p-2 font-mono text-red-600">${fmtC(r.redCenter)}</td>
            <td class="p-2 font-mono text-blue-600">${fmtV(r.blueArea)}</td>
            <td class="p-2 font-mono text-blue-600">${fmtV(r.blueRadius)}</td>
            <td class="p-2 font-mono text-blue-600">${fmtC(r.blueCenter)}</td>
            <td class="p-2 font-mono font-semibold">${fmtV(r.shift)}</td>
        </tr>`;
    }
    html += '</tbody></table>';
    
    // Comparison to manuscript values
    html += `
    <p class="text-sm font-semibold text-amber-700 mb-2">Comparison to Manuscript Values (500, 1000, 2000 Hz only):</p>
    <table class="w-full text-xs border-collapse mb-4">
        <thead>
            <tr class="bg-amber-100 text-left">
                <th class="p-2 font-semibold border-b border-amber-300">Freq</th>
                <th class="p-2 font-semibold border-b border-amber-300">Manuscript Shift</th>
                <th class="p-2 font-semibold border-b border-amber-300">Tracing Shift</th>
                <th class="p-2 font-semibold border-b border-amber-300">Shift Ratio</th>
                <th class="p-2 font-semibold border-b border-amber-300">Manuscript r</th>
                <th class="p-2 font-semibold border-b border-amber-300">Tracing r</th>
                <th class="p-2 font-semibold border-b border-amber-300">Radius Ratio</th>
            </tr>
        </thead><tbody>`;
    
    for (const r of rows) {
        if (!r.manuscriptShift) continue; // Only show 500, 1000, 2000 Hz
        const fmtV = v => v !== null ? v.toFixed(4) : '-';
        const ratioClass = r.shiftRatio ? (Math.abs(r.shiftRatio - 1) < 0.1 ? 'text-green-600' : 'text-red-600') : '';
        html += `<tr class="border-b border-gray-200 hover:bg-amber-50">
            <td class="p-2 font-semibold">${r.hzKey} Hz</td>
            <td class="p-2 font-mono">${fmtV(r.manuscriptShift)}</td>
            <td class="p-2 font-mono">${fmtV(r.shift)}</td>
            <td class="p-2 font-mono font-bold ${ratioClass}">${fmtV(r.shiftRatio)}</td>
            <td class="p-2 font-mono">${fmtV(r.manuscriptR)}</td>
            <td class="p-2 font-mono">${fmtV(r.redRadius)}</td>
            <td class="p-2 font-mono font-bold ${ratioClass}">${fmtV(r.radiusRatio)}</td>
        </tr>`;
    }
    html += '</tbody></table>';
    
    html += `<div class="mt-3 text-xs text-gray-500 space-y-1">
        <p><span class="font-semibold">Area:</span> Pixel-based area matching the original drawing app. Calculated by scanning a grid and counting painted cells, including brush width effects and outline subtraction for closed shapes.</p>
        <p><span class="font-semibold">Radius (r):</span> Equivalent circle radius: r = sqrt(area / pi).</p>
        <p><span class="font-semibold">Center:</span> Centroid of the average contour calculated via uniform path resampling.</p>
        <p><span class="font-semibold">Shift:</span> Euclidean distance between red and blue centroids.</p>
        <p><span class="font-semibold">Ratio:</span> Tracing app value divided by manuscript value. Values close to 1.0 (green) indicate good agreement; large deviations (red) indicate discrepancy.</p>
        <p class="mt-2 font-semibold">Diagnostic: Run <code>runDataDiagnostics()</code> in browser console for detailed analysis. Run <code>listShapesByParticipant()</code> to check for duplicate shapes.</p>
    </div>`;
    
    tableDiv.innerHTML = html;
    
    // Console log
    console.log('[Circle Approx] Freq | Red r | Blue r | Shift | Manuscript Shift | Ratio');
    for (const r of rows) {
        const rr = r.redRadius !== null ? r.redRadius.toFixed(4) : 'N/A';
        const br = r.blueRadius !== null ? r.blueRadius.toFixed(4) : 'N/A';
        const sh = r.shift !== null ? r.shift.toFixed(4) : 'N/A';
        const ms = r.manuscriptShift !== null ? r.manuscriptShift.toFixed(4) : 'N/A';
        const ratio = r.shiftRatio !== null ? r.shiftRatio.toFixed(2) : 'N/A';
        console.log(`[Circle Approx] ${r.hzKey} Hz | r=${rr} | r=${br} | shift=${sh} | ms_shift=${ms} | ratio=${ratio}`);
    }
}

function drawCompositeShape(cx, shape, color, scale, opacity, lineWidth) {
    if (!shape || shape.length < 2) return;
    
    cx.save();
    cx.globalAlpha = opacity;
    cx.strokeStyle = color;
    cx.lineWidth = lineWidth;
    cx.lineCap = 'round';
    cx.lineJoin = 'round';
    
    cx.beginPath();
    const start = unitToCanvas(shape[0].x, shape[0].y);
    cx.moveTo(start.x * scale, start.y * scale);
    
    for (let i = 1; i < shape.length; i++) {
        const pt = unitToCanvas(shape[i].x, shape[i].y);
        cx.lineTo(pt.x * scale, pt.y * scale);
    }
    
    cx.stroke();
    cx.restore();
}

/**
 * Draw a centroid marker (+ sign) on the composite canvas
 */
function drawCentroidMarker(cx, centroid, color, scale) {
    if (!centroid) return;
    
    const canvasPos = unitToCanvas(centroid.x, centroid.y);
    const x = canvasPos.x * scale;
    const y = canvasPos.y * scale;
    const size = 8; // Size of the + marker in pixels
    
    cx.save();
    cx.strokeStyle = color;
    cx.lineWidth = 2;
    cx.lineCap = 'round';
    
    // Draw horizontal line of +
    cx.beginPath();
    cx.moveTo(x - size, y);
    cx.lineTo(x + size, y);
    cx.stroke();
    
    // Draw vertical line of +
    cx.beginPath();
    cx.moveTo(x, y - size);
    cx.lineTo(x, y + size);
    cx.stroke();
    
    cx.restore();
}

/**
 * Draw grid for composite image
 */
function drawCompositeGrid(cx, size) {
    const center = size / 2;
    const unitSize = size / 20; // 20 units across
    
    // Minor grid lines
    cx.strokeStyle = '#e5e7eb';
    cx.lineWidth = 0.5;
    for (let i = 0; i <= 20; i++) {
        const pos = i * unitSize;
        cx.beginPath();
        cx.moveTo(pos, 0);
        cx.lineTo(pos, size);
        cx.stroke();
        cx.beginPath();
        cx.moveTo(0, pos);
        cx.lineTo(size, pos);
        cx.stroke();
    }
    
    // Major axes
    cx.strokeStyle = '#9ca3af';
    cx.lineWidth = 1;
    cx.beginPath();
    cx.moveTo(0, center);
    cx.lineTo(size, center);
    cx.stroke();
    cx.beginPath();
    cx.moveTo(center, 0);
    cx.lineTo(center, size);
    cx.stroke();
    
    // Reference circle (3 units radius)
    cx.strokeStyle = '#6b7280';
    cx.lineWidth = 1;
    cx.beginPath();
    cx.arc(center, center, 3 * unitSize, 0, 2 * Math.PI);
    cx.stroke();
}

/**
 * Export frequency averages as PNG images packaged into a ZIP file.
 * Creates one image per frequency with:
 * - Individual traced contours resampled to 1000 uniform points at reduced
 *   opacity (background), providing consistent stroke rendering
 * - Average shapes at full opacity with centroid crosshair markers (foreground)
 * - Grid, reference circle, and area/centroid/shift statistics overlaid
 */
function exportFrequencyPNGs() {
    const statusEl = document.getElementById('freq-avg-status');
    
    // Check if averages have been generated
    const hasData = Object.keys(frequencyAverages).some(hz => 
        frequencyAverages[hz].redAvg || frequencyAverages[hz].blueAvg
    );
    
    if (!hasData) {
        statusEl.textContent = 'Please generate frequency averages first';
        return;
    }
    
    statusEl.textContent = 'Creating PNG images and packaging ZIP...';
    
    const zip = new JSZip();
    const imgFolder = zip.folder('frequency_averages');
    let fileCount = 0;
    
    // Collect all canvases first (toBlob is async, so we use promises)
    const exportPromises = [];
    
    for (const freq of FREQUENCIES) {
        const hzKey = freq.hz;
        const data = frequencyAverages[hzKey];
        
        if (!data || (!data.redAvg && !data.blueAvg)) continue;
        
        // Create canvas for this frequency
        const tc = document.createElement('canvas');
        tc.width = tc.height = CANVAS_SIZE;
        const cx = tc.getContext('2d');
        
        // White background
        cx.fillStyle = 'white';
        cx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        
        // Layer 1: Reference circle (3-unit radius head outline)
        cx.save();
        cx.strokeStyle = '#6b7280';
        cx.lineWidth = 1 * (CANVAS_SIZE / 400);
        cx.beginPath();
        cx.arc(CENTER, CENTER, BACKGROUND_CIRCLE_RADIUS * SCALE_FACTOR, 0, Math.PI * 2);
        cx.stroke();
        cx.restore();
        
        // Layer 2: Individual traced shapes (resampled) at low opacity.
        // Visual parameters match the in-app gallery composites, scaled
        // proportionally for the full-resolution export canvas.
        // Gallery renders at 400px with scale = 400/CANVAS_SIZE.
        // Export renders at CANVAS_SIZE (1:1), so line widths scale by
        // CANVAS_SIZE/400 = 2.5 to produce the same visual weight.
        const scaleFactor = CANVAS_SIZE / 400;
        const traceOpacity = 0.45;
        const traceLineWidth = 1 * scaleFactor;
        const avgLineWidth = 3 * scaleFactor;
        const resampleN = 1000;
        
        if (data.redShapes && data.redShapes.length > 0) {
            for (const shape of data.redShapes) {
                if (!shape || shape.length < 3) continue;
                const rs = resample(shape, resampleN);
                cx.save();
                cx.globalAlpha = traceOpacity;
                cx.strokeStyle = COLORS.red;
                cx.lineWidth = traceLineWidth;
                cx.lineCap = 'round';
                cx.lineJoin = 'round';
                cx.beginPath();
                const s0 = unitToCanvas(rs[0].x, rs[0].y);
                cx.moveTo(s0.x, s0.y);
                for (let i = 1; i < rs.length; i++) {
                    const pt = unitToCanvas(rs[i].x, rs[i].y);
                    cx.lineTo(pt.x, pt.y);
                }
                cx.closePath();
                cx.stroke();
                cx.restore();
            }
        }
        
        if (data.blueShapes && data.blueShapes.length > 0) {
            for (const shape of data.blueShapes) {
                if (!shape || shape.length < 3) continue;
                const rs = resample(shape, resampleN);
                cx.save();
                cx.globalAlpha = traceOpacity;
                cx.strokeStyle = COLORS.blue;
                cx.lineWidth = traceLineWidth;
                cx.lineCap = 'round';
                cx.lineJoin = 'round';
                cx.beginPath();
                const s0 = unitToCanvas(rs[0].x, rs[0].y);
                cx.moveTo(s0.x, s0.y);
                for (let i = 1; i < rs.length; i++) {
                    const pt = unitToCanvas(rs[i].x, rs[i].y);
                    cx.lineTo(pt.x, pt.y);
                }
                cx.closePath();
                cx.stroke();
                cx.restore();
            }
        }
        
        // Layer 3: Average shapes at full opacity with crosshair centroid markers
        if (data.redAvg && data.redAvg.length >= 2) {
            cx.strokeStyle = '#991b1b';
            cx.lineWidth = avgLineWidth;
            cx.lineCap = 'round';
            cx.lineJoin = 'round';
            cx.beginPath();
            const st = unitToCanvas(data.redAvg[0].x, data.redAvg[0].y);
            cx.moveTo(st.x, st.y);
            for (let i = 1; i < data.redAvg.length; i++) {
                const pt = unitToCanvas(data.redAvg[i].x, data.redAvg[i].y);
                cx.lineTo(pt.x, pt.y);
            }
            cx.closePath();
            cx.stroke();
            
            if (data.redCentroid) {
                const cp = unitToCanvas(data.redCentroid.x, data.redCentroid.y);
                const markerSize = 8 * scaleFactor;
                cx.strokeStyle = '#991b1b';
                cx.lineWidth = 2 * scaleFactor;
                cx.lineCap = 'round';
                cx.beginPath();
                cx.moveTo(cp.x - markerSize, cp.y);
                cx.lineTo(cp.x + markerSize, cp.y);
                cx.stroke();
                cx.beginPath();
                cx.moveTo(cp.x, cp.y - markerSize);
                cx.lineTo(cp.x, cp.y + markerSize);
                cx.stroke();
            }
        }
        
        if (data.blueAvg && data.blueAvg.length >= 2) {
            cx.strokeStyle = '#1e3a8a';
            cx.lineWidth = avgLineWidth;
            cx.lineCap = 'round';
            cx.lineJoin = 'round';
            cx.beginPath();
            const st = unitToCanvas(data.blueAvg[0].x, data.blueAvg[0].y);
            cx.moveTo(st.x, st.y);
            for (let i = 1; i < data.blueAvg.length; i++) {
                const pt = unitToCanvas(data.blueAvg[i].x, data.blueAvg[i].y);
                cx.lineTo(pt.x, pt.y);
            }
            cx.closePath();
            cx.stroke();
            
            if (data.blueCentroid) {
                const cp = unitToCanvas(data.blueCentroid.x, data.blueCentroid.y);
                const markerSize = 8 * scaleFactor;
                cx.strokeStyle = '#1e3a8a';
                cx.lineWidth = 2 * scaleFactor;
                cx.lineCap = 'round';
                cx.beginPath();
                cx.moveTo(cp.x - markerSize, cp.y);
                cx.lineTo(cp.x + markerSize, cp.y);
                cx.stroke();
                cx.beginPath();
                cx.moveTo(cp.x, cp.y - markerSize);
                cx.lineTo(cp.x, cp.y + markerSize);
                cx.stroke();
            }
        }
        
        // Layer 4: Grid on top
        cx.strokeStyle = '#e5e7eb';
        cx.lineWidth = 1;
        for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) {
            if (i === 0) continue;
            const c = unitToCanvas(i, i);
            cx.beginPath(); cx.moveTo(0, c.y); cx.lineTo(CANVAS_SIZE, c.y); cx.stroke();
            cx.beginPath(); cx.moveTo(c.x, 0); cx.lineTo(c.x, CANVAS_SIZE); cx.stroke();
        }
        cx.strokeStyle = '#6b7280';
        cx.lineWidth = 2;
        cx.beginPath(); cx.moveTo(0, CENTER); cx.lineTo(CANVAS_SIZE, CENTER); cx.stroke();
        cx.beginPath(); cx.moveTo(CENTER, 0); cx.lineTo(CENTER, CANVAS_SIZE); cx.stroke();
        
        // Title
        cx.fillStyle = '#1f2937';
        cx.font = 'bold 28px sans-serif';
        cx.textAlign = 'center';
        cx.fillText(`${hzKey} Hz`, CENTER, 30);
        
        // Detailed stats
        cx.font = '14px sans-serif';
        cx.textAlign = 'left';
        const redCount = data.redShapes ? data.redShapes.length : 0;
        const blueCount = data.blueShapes ? data.blueShapes.length : 0;
        
        cx.fillStyle = '#991b1b';
        const redCentroidStr = data.redCentroid ? `(${data.redCentroid.x.toFixed(2)}, ${data.redCentroid.y.toFixed(2)})` : '-';
        const redAreaStr = data.redArea ? data.redArea.toFixed(2) : '-';
        cx.fillText(`Red: N=${redCount}, Centroid=${redCentroidStr}, Area=${redAreaStr}`, 20, 55);
        
        cx.fillStyle = '#1e3a8a';
        const blueCentroidStr = data.blueCentroid ? `(${data.blueCentroid.x.toFixed(2)}, ${data.blueCentroid.y.toFixed(2)})` : '-';
        const blueAreaStr = data.blueArea ? data.blueArea.toFixed(2) : '-';
        cx.fillText(`Blue: N=${blueCount}, Centroid=${blueCentroidStr}, Area=${blueAreaStr}`, 20, 75);
        
        // Shift calculation
        if (data.redCentroid && data.blueCentroid) {
            const shift = Math.sqrt(
                Math.pow(data.blueCentroid.x - data.redCentroid.x, 2) + 
                Math.pow(data.blueCentroid.y - data.redCentroid.y, 2)
            );
            cx.fillStyle = '#6b7280';
            cx.fillText(`Centroid Shift: ${shift.toFixed(3)} units`, 20, 95);
        }
        
        // Convert canvas to blob and add to ZIP
        const filename = `frequency_avg_${hzKey}Hz.png`;
        const promise = new Promise(resolve => {
            tc.toBlob(blob => {
                blob.arrayBuffer().then(buf => {
                    imgFolder.file(filename, buf);
                    fileCount++;
                    resolve();
                });
            });
        });
        exportPromises.push(promise);
    }
    
    // Wait for all canvases to be converted, then generate and download ZIP
    Promise.all(exportPromises).then(() => {
        zip.generateAsync({ type: 'blob' }).then(zipBlob => {
            const timestamp = new Date().toISOString().slice(0, 10);
            saveAs(zipBlob, `frequency_averages_${timestamp}.zip`);
            statusEl.textContent = `Exported ${fileCount} PNG images as ZIP`;
            status(`Exported ${fileCount} frequency average PNGs as ZIP`);
        });
    });
}

function updateGallery() {
    const g = document.getElementById('gallery');
    g.innerHTML = '';
    let has = false;
    for (const p of Object.keys(allData).sort()) {
        for (const t of Object.keys(allData[p]).sort()) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                if (d.redAvg || d.blueAvg) {
                    has = true;
                    const card = document.createElement('div');
                    card.className = 'bg-gray-50 rounded-xl p-3 border';
                    const cv = document.createElement('canvas');
                    cv.width = 200; cv.height = 200;
                    cv.className = 'w-full rounded-lg border bg-white mb-2';
                    const cx = cv.getContext('2d');
                    cx.fillStyle = 'white'; cx.fillRect(0, 0, 200, 200);
                    const sc = 200 / CANVAS_SIZE;
                    // Traced shapes at SHAPE_OPACITY (background)
                    d.red.forEach(s => drawPreview(cx, s, COLORS.red, sc, SHAPE_OPACITY));
                    d.blue.forEach(s => drawPreview(cx, s, COLORS.blue, sc, SHAPE_OPACITY));
                    // Average shapes with darker colors at full opacity (foreground)
                    if (d.redAvg) drawPreview(cx, d.redAvg, '#991b1b', sc, 1, 3);
                    if (d.blueAvg) drawPreview(cx, d.blueAvg, '#1e3a8a', sc, 1, 3);
                    // Grid on top
                    drawMiniGrid(cx, 200);
                    card.appendChild(cv);
                    card.innerHTML += `<p class="text-xs font-semibold">${p} - ${t}</p><p class="text-xs text-gray-500">${fk}</p>`;
                    g.appendChild(card);
                }
            }
        }
    }
    if (!has) g.innerHTML = '<div class="border-2 border-dashed border-gray-200 rounded-xl p-8 text-center text-gray-400">No averages yet</div>';
}

function drawPreview(cx, s, clr, sc, op, lw = 2) {
    if (!s || s.length < 2) return;
    cx.save(); cx.globalAlpha = op; cx.strokeStyle = clr; cx.lineWidth = lw;
    cx.lineCap = 'round'; cx.lineJoin = 'round'; cx.beginPath();
    const st = unitToCanvas(s[0].x, s[0].y);
    cx.moveTo(st.x * sc, st.y * sc);
    for (let i = 1; i < s.length; i++) {
        const p = unitToCanvas(s[i].x, s[i].y);
        cx.lineTo(p.x * sc, p.y * sc);
    }
    cx.stroke(); cx.restore();
}

function drawMiniGrid(cx, sz) {
    const c = sz / 2;
    cx.strokeStyle = '#e5e7eb'; cx.lineWidth = 0.5;
    for (let i = 0; i <= sz; i += sz / 20) {
        cx.beginPath(); cx.moveTo(i, 0); cx.lineTo(i, sz); cx.stroke();
        cx.beginPath(); cx.moveTo(0, i); cx.lineTo(sz, i); cx.stroke();
    }
    cx.strokeStyle = '#6b7280'; cx.lineWidth = 1;
    cx.beginPath(); cx.moveTo(0, c); cx.lineTo(sz, c); cx.stroke();
    cx.beginPath(); cx.moveTo(c, 0); cx.lineTo(c, sz); cx.stroke();
}

// ============================================
// DATA TABLE
// ============================================
function updateTable() {
    const tb = document.getElementById('data-body');
    tb.innerHTML = '';
    let has = false;
    for (const p of Object.keys(allData).sort()) {
        for (const t of Object.keys(allData[p]).sort()) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                d.red.forEach((s, i) => {
                    has = true;
                    const sm = s.slice(0, 2).map(pt => `(${pt.x.toFixed(1)},${pt.y.toFixed(1)})`).join(' ');
                    tb.innerHTML += `<tr><td>${p}</td><td>${t}</td><td>${fk}</td><td class="text-red-500">‚óè</td><td>${i + 1}</td><td>${s.length}</td><td>${sm}...</td></tr>`;
                });
                d.blue.forEach((s, i) => {
                    has = true;
                    const sm = s.slice(0, 2).map(pt => `(${pt.x.toFixed(1)},${pt.y.toFixed(1)})`).join(' ');
                    tb.innerHTML += `<tr><td>${p}</td><td>${t}</td><td>${fk}</td><td class="text-blue-500">‚óè</td><td>${i + 1}</td><td>${s.length}</td><td>${sm}...</td></tr>`;
                });
            }
        }
    }
    if (!has) tb.innerHTML = '<tr><td colspan="7" class="text-center text-gray-400 py-8">No data</td></tr>';
}

// ============================================
// EXPORTS
// ============================================
function expCSV() {
    let csv = 'Participant,Trial,Frequency,Color,Shape,Point,X,Y,IsAvg\n';
    for (const p of Object.keys(allData)) {
        for (const t of Object.keys(allData[p])) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                d.red.forEach((s, si) => s.forEach((pt, pi) => { csv += `${p},${t},${fk},Red,${si + 1},${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},false\n`; }));
                d.blue.forEach((s, si) => s.forEach((pt, pi) => { csv += `${p},${t},${fk},Blue,${si + 1},${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},false\n`; }));
                if (d.redAvg) d.redAvg.forEach((pt, pi) => { csv += `${p},${t},${fk},Red,Avg,${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},true\n`; });
                if (d.blueAvg) d.blueAvg.forEach((pt, pi) => { csv += `${p},${t},${fk},Blue,Avg,${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},true\n`; });
            }
        }
    }
    saveAs(new Blob([csv], { type: 'text/csv' }), `contour_${new Date().toISOString().slice(0, 10)}.csv`);
    status('CSV exported');
}

function expJSON() {
    const ex = { exportDate: new Date().toISOString(), version: '5.3', settings: { resampleRate, imageOpacity: Math.round(IMAGE_OPACITY * 100), shapeOpacity: Math.round(SHAPE_OPACITY * 100), brushSize, radialResolution }, allData };
    saveAs(new Blob([JSON.stringify(ex, null, 2)], { type: 'application/json' }), `contour_${new Date().toISOString().slice(0, 10)}.json`);
    status('JSON exported');
}

// ============================================
// CLOUD COLLABORATION - GOOGLE SHEETS
// ============================================
let autoCloudSave = false;
let cloudSaveTimeout = null;

function getCloudUrl() {
    return document.getElementById('cloud-url').value.trim();
}

function getTracerName() {
    return document.getElementById('tracer-name').value.trim();
}

function setCloudStatus(msg, isError = false) {
    const el = document.getElementById('cloud-status');
    el.textContent = msg;
    el.className = isError ? 'text-xs text-red-600 mt-3' : 'text-xs text-green-600 mt-3';
}

// Cloud progress popup functions
let cloudProgressStartTime = null;

function showCloudProgress(title, message) {
    const modal = document.getElementById('cloud-progress-modal');
    document.getElementById('cloud-progress-icon').textContent = '‚òÅÔ∏è';
    document.getElementById('cloud-progress-title').textContent = title;
    document.getElementById('cloud-progress-message').textContent = message;
    document.getElementById('cloud-progress-bar').style.width = '0%';
    document.getElementById('cloud-progress-details').textContent = '';
    document.getElementById('cloud-progress-result').classList.add('hidden');
    document.getElementById('cloud-progress-close').classList.add('hidden');
    modal.classList.add('active');
    cloudProgressStartTime = Date.now();
}

function updateCloudProgress(percent, details = '') {
    document.getElementById('cloud-progress-bar').style.width = percent + '%';
    
    let timeInfo = '';
    if (cloudProgressStartTime && percent > 0 && percent < 100) {
        const elapsed = (Date.now() - cloudProgressStartTime) / 1000; // seconds
        const estimatedTotal = elapsed / (percent / 100);
        const remaining = estimatedTotal - elapsed;
        
        if (remaining > 0) {
            if (remaining < 60) {
                timeInfo = ` (~${Math.ceil(remaining)}s remaining)`;
            } else {
                const mins = Math.floor(remaining / 60);
                const secs = Math.ceil(remaining % 60);
                timeInfo = ` (~${mins}m ${secs}s remaining)`;
            }
        }
    }
    
    if (details) {
        document.getElementById('cloud-progress-details').textContent = details + timeInfo;
    } else if (timeInfo) {
        document.getElementById('cloud-progress-details').textContent = `${percent}% complete${timeInfo}`;
    }
}

function showCloudSuccess(title, message, details = '') {
    document.getElementById('cloud-progress-icon').textContent = '‚úÖ';
    document.getElementById('cloud-progress-title').textContent = title;
    document.getElementById('cloud-progress-message').textContent = message;
    document.getElementById('cloud-progress-bar').style.width = '100%';
    
    // Show total time taken
    let totalTime = '';
    if (cloudProgressStartTime) {
        const elapsed = (Date.now() - cloudProgressStartTime) / 1000;
        if (elapsed < 60) {
            totalTime = `\nCompleted in ${elapsed.toFixed(1)} seconds`;
        } else {
            const mins = Math.floor(elapsed / 60);
            const secs = (elapsed % 60).toFixed(1);
            totalTime = `\nCompleted in ${mins}m ${secs}s`;
        }
    }
    
    const resultDiv = document.getElementById('cloud-progress-result');
    resultDiv.classList.remove('hidden', 'bg-red-100');
    resultDiv.classList.add('bg-green-100');
    document.getElementById('cloud-result-text').textContent = '‚úì Success';
    document.getElementById('cloud-result-text').className = 'font-semibold text-green-700';
    document.getElementById('cloud-result-details').textContent = details + totalTime;
    document.getElementById('cloud-result-details').className = 'text-sm mt-2 text-green-600 whitespace-pre-line';
    document.getElementById('cloud-progress-details').textContent = '100% complete';
    
    document.getElementById('cloud-progress-close').classList.remove('hidden');
}

function showCloudError(title, message, details = '') {
    document.getElementById('cloud-progress-icon').textContent = '‚ùå';
    document.getElementById('cloud-progress-title').textContent = title;
    document.getElementById('cloud-progress-message').textContent = message;
    
    const resultDiv = document.getElementById('cloud-progress-result');
    resultDiv.classList.remove('hidden', 'bg-green-100');
    resultDiv.classList.add('bg-red-100');
    document.getElementById('cloud-result-text').textContent = '‚úó Error';
    document.getElementById('cloud-result-text').className = 'font-semibold text-red-700';
    document.getElementById('cloud-result-details').textContent = details;
    document.getElementById('cloud-result-details').className = 'text-sm mt-2 text-red-600';
    
    document.getElementById('cloud-progress-close').classList.remove('hidden');
}

function hideCloudProgress() {
    document.getElementById('cloud-progress-modal').classList.remove('active');
    cloudProgressStartTime = null;
}

async function saveToCloud() {
    const url = getCloudUrl();
    const tracerName = getTracerName();
    
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    if (!tracerName) {
        setCloudStatus('‚ùå Enter your tracer name', true);
        return;
    }
    
    // Show progress popup
    showCloudProgress('Saving to Cloud...', 'Preparing your traced data');
    
    // Save settings locally
    localStorage.setItem('cloudUrl', url);
    localStorage.setItem('tracerName', tracerName);
    
    // For Final saves: diff against snapshot so we only send new shapes.
    // The server will merge these into its stored Final data.
    const isFinal = (tracerName === 'Final');
    let dataToSend = allData;
    
    if (isFinal && _finalSnapshot) {
        const diff = extractNewShapes(allData, _finalSnapshot);
        if (!diff) {
            updateCloudProgress(100);
            showCloudSuccess(
                'Nothing New to Save',
                'All shapes already exist in the cloud Final data.',
                'No new traced shapes were detected since your last load.'
            );
            setCloudStatus('‚úÖ Final is up to date (no new data)');
            return;
        }
        dataToSend = diff;
        console.log('Final save: sending only new shapes (diffed against snapshot)');
    }
    
    // Count data for display
    let totalShapes = 0;
    let dataDebug = [];
    for (const p of Object.keys(dataToSend)) {
        for (const t of Object.keys(dataToSend[p])) {
            for (const f of Object.keys(dataToSend[p][t])) {
                const d = dataToSend[p][t][f];
                const redCount = d.red ? d.red.length : 0;
                const blueCount = d.blue ? d.blue.length : 0;
                totalShapes += redCount + blueCount;
                dataDebug.push(`${p}/${t}/${f}: R=${redCount}, B=${blueCount}`);
            }
        }
    }
    const participantCount = Object.keys(dataToSend).length;
    
    updateCloudProgress(10, `${participantCount} participants, ${totalShapes} shapes`);
    
    console.log('=== SAVE TO CLOUD DEBUG ===');
    console.log('Tracer:', tracerName, isFinal ? '(Final - diff mode)' : '');
    console.log('Participants:', Object.keys(dataToSend));
    console.log('Total shapes:', totalShapes);
    console.log('Data breakdown:', dataDebug);
    
    const saveData = {
        action: 'saveProgress',
        tracerName: tracerName,
        savedAt: new Date().toISOString(),
        allData: dataToSend,
        settings: { resampleRate, imageOpacity: Math.round(IMAGE_OPACITY * 100), shapeOpacity: Math.round(SHAPE_OPACITY * 100), brushSize, radialResolution }
    };
    
    // Log the size of the payload
    const payloadSize = JSON.stringify(saveData).length;
    const payloadKB = (payloadSize / 1024).toFixed(1);
    console.log('Payload size:', payloadSize, 'bytes');
    
    updateCloudProgress(20, `Uploading ${payloadKB} KB...`);
    
    try {
        updateCloudProgress(30, 'Connecting to Google Sheets...');
        
        // Use no-cors mode since Google Apps Script redirects
        await fetch(url, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(saveData)
        });
        
        updateCloudProgress(60, 'Data sent, verifying...');
        
        // Verify by checking if save worked
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        updateCloudProgress(80, 'Checking save status...');
        
        try {
            const checkUrl = `${url}?action=listTracers`;
            const checkResp = await fetch(checkUrl);
            if (checkResp.ok) {
                const data = await checkResp.json();
                const found = data.tracers?.find(t => t.name === tracerName);
                
                updateCloudProgress(100);
                
                if (found) {
                    console.log('Verification - found tracer:', found);
                    const savedTime = new Date().toLocaleTimeString();
                    showCloudSuccess(
                        'Saved Successfully!', 
                        `Your data has been saved to the cloud.`,
                        `Tracer: ${tracerName}\nParticipants: ${found.participantCount}\nTrials: ${found.trialCount}\nShapes: ${found.totalShapes}\nTime: ${savedTime}`
                    );
                    setCloudStatus(`‚úÖ Saved as "${tracerName}" (${found.totalShapes} shapes)`);
                } else {
                    console.log('Verification - tracer not found in list');
                    showCloudSuccess(
                        'Save Complete', 
                        'Data was sent to Google Sheets.',
                        `Tracer: ${tracerName}\nNote: Verification pending. Check your Google Sheet.`
                    );
                    setCloudStatus(`‚úÖ Saved as "${tracerName}"`);
                }
            } else {
                throw new Error('Verification request failed');
            }
        } catch (verifyError) {
            console.log('Verification error:', verifyError);
            // Save may have worked, just verification failed
            showCloudSuccess(
                'Save Sent', 
                'Data was sent to Google Sheets.',
                `Tracer: ${tracerName}\nNote: Could not verify. Check your Google Sheet directly.`
            );
            setCloudStatus(`‚úÖ Saved as "${tracerName}" (unverified)`);
        }
        
        status('Saved to cloud');
        
        // After a successful Final save, update the snapshot to current allData
        // so the next save only sends shapes added after this point.
        if (isFinal) {
            _finalSnapshot = JSON.parse(JSON.stringify(allData));
            console.log('Updated _finalSnapshot after successful Final save');
        }
    } catch (e) {
        console.error('Save error:', e);
        showCloudError(
            'Save Failed',
            'Could not save to Google Sheets.',
            e.message || 'Check your internet connection and Apps Script URL.'
        );
        setCloudStatus('‚ùå Save failed: ' + e.message, true);
        status('Cloud save failed');
    }
}

/**
 * Populate the Final frequency replacement dropdown with available frequencies
 */
function populateFinalFrequencyDropdown() {
    const select = document.getElementById('final-freq-select');
    select.innerHTML = '<option value="">-- Select frequency to replace --</option>';
    
    for (const freq of FREQUENCIES) {
        const option = document.createElement('option');
        option.value = `${freq.hz}Hz_${freq.db}dB`;
        option.textContent = `${freq.hz} Hz (${freq.db} dB)`;
        select.appendChild(option);
    }
}

/**
 * Replace ALL data for a specific frequency in the "Final" tracer on the cloud.
 * 
 * Use case: When a frequency (e.g., 500 Hz) has incorrect or duplicate traces
 * and needs to be completely re-done.
 * 
 * Process:
 * 1. Collects all local data for the selected frequency across all participants/trials
 * 2. Sends a 'replaceFinalFrequency' action to the Google Apps Script
 * 3. Server deletes ALL existing rows for Final/[frequency] and inserts new data
 * 4. Updates local _finalSnapshot to reflect the replacement
 * 
 * Warning: This operation cannot be undone. Requires user confirmation.
 */
async function replaceFinalFrequency() {
    const url = getCloudUrl();
    const freqKey = document.getElementById('final-freq-select').value;
    
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    if (!freqKey) {
        setCloudStatus('‚ùå Select a frequency to replace', true);
        return;
    }
    
    // Parse frequency from key
    const freqMatch = freqKey.match(/(\d+(?:\.\d+)?)Hz_(\d+)dB/);
    if (!freqMatch) {
        setCloudStatus('‚ùå Invalid frequency format', true);
        return;
    }
    const hz = parseFloat(freqMatch[1]);
    
    // Collect all local data for this frequency
    const freqData = {};
    let totalShapes = 0;
    
    for (const participant of Object.keys(allData)) {
        for (const trial of Object.keys(allData[participant])) {
            for (const fk of Object.keys(allData[participant][trial])) {
                if (fk === freqKey) {
                    const d = allData[participant][trial][fk];
                    if (!freqData[participant]) freqData[participant] = {};
                    if (!freqData[participant][trial]) freqData[participant][trial] = {};
                    freqData[participant][trial][fk] = {
                        red: d.red || [],
                        blue: d.blue || [],
                        redAvg: d.redAvg || null,
                        blueAvg: d.blueAvg || null
                    };
                    totalShapes += (d.red ? d.red.length : 0) + (d.blue ? d.blue.length : 0);
                }
            }
        }
    }
    
    if (totalShapes === 0) {
        setCloudStatus(`‚ùå No local data for ${hz} Hz to replace with`, true);
        return;
    }
    
    // Confirm with user
    const confirmMsg = `‚ö†Ô∏è WARNING: This will DELETE all existing ${hz} Hz data in Final and replace it with your current local data (${totalShapes} shapes).\n\nThis action cannot be undone.\n\nAre you sure?`;
    if (!confirm(confirmMsg)) {
        setCloudStatus('Replacement cancelled');
        return;
    }
    
    showCloudProgress('Replacing Frequency Data...', `Replacing ${hz} Hz data in Final`);
    
    const replaceData = {
        action: 'replaceFinalFrequency',
        tracerName: 'Final',
        frequencyKey: freqKey,
        frequencyHz: hz,
        savedAt: new Date().toISOString(),
        allData: freqData,
        settings: { resampleRate, imageOpacity: Math.round(IMAGE_OPACITY * 100), shapeOpacity: Math.round(SHAPE_OPACITY * 100), brushSize, radialResolution }
    };
    
    console.log('=== REPLACE FINAL FREQUENCY DEBUG ===');
    console.log('Frequency:', freqKey);
    console.log('Total shapes:', totalShapes);
    console.log('Participants:', Object.keys(freqData));
    
    try {
        updateCloudProgress(30, 'Sending replacement data...');
        
        await fetch(url, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(replaceData)
        });
        
        updateCloudProgress(70, 'Data sent, waiting for confirmation...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        updateCloudProgress(100);
        showCloudSuccess(
            'Frequency Replaced!',
            `${hz} Hz data in Final has been replaced.`,
            `Shapes uploaded: ${totalShapes}\nParticipants: ${Object.keys(freqData).length}`
        );
        setCloudStatus(`‚úÖ Replaced ${hz} Hz in Final (${totalShapes} shapes)`);
        
        // Update the Final snapshot to include this new data
        if (_finalSnapshot) {
            for (const p of Object.keys(freqData)) {
                if (!_finalSnapshot[p]) _finalSnapshot[p] = {};
                for (const t of Object.keys(freqData[p])) {
                    if (!_finalSnapshot[p][t]) _finalSnapshot[p][t] = {};
                    for (const f of Object.keys(freqData[p][t])) {
                        _finalSnapshot[p][t][f] = JSON.parse(JSON.stringify(freqData[p][t][f]));
                    }
                }
            }
            console.log('Updated _finalSnapshot with replaced frequency data');
        }
        
    } catch (e) {
        console.error('Replace error:', e);
        showCloudError(
            'Replace Failed',
            `Could not replace ${hz} Hz data in Final.`,
            e.message || 'Check your internet connection and Apps Script URL.'
        );
        setCloudStatus('‚ùå Replace failed: ' + e.message, true);
    }
}

async function loadFromCloud(tracerNameOverride = null, mergeMode = false, fromCoordinates = false) {
    const url = getCloudUrl();
    const tracerName = tracerNameOverride || getTracerName();
    
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    if (!tracerName) {
        setCloudStatus('‚ùå Enter tracer name to load', true);
        return;
    }
    
    try {
        setCloudStatus('‚òÅÔ∏è Loading from cloud...');
        status('Loading from cloud...');
        
        // For Final: use loadCoordinates to reconstruct from point data
        // (TracerProgress has corrupted JSON, CoordinateData has intact point data)
        // For other tracers: use loadCoordinates when fromCoordinates is true
        const isFinal = (tracerName === 'Final');
        const action = isFinal ? 'loadCoordinates' :
                       (fromCoordinates ? 'loadCoordinates' : 'loadProgress');
        
        const fetchUrl = `${url}?action=${action}&tracerName=${encodeURIComponent(tracerName)}`;
        console.log('[loadFromCloud] Fetching:', fetchUrl);
        
        const response = await fetch(fetchUrl);
        console.log('[loadFromCloud] Response status:', response.status);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        // Get raw text first to debug JSON issues
        const rawText = await response.text();
        console.log('[loadFromCloud] Response length:', rawText.length, 'characters');
        
        // Try to parse JSON with better error reporting
        let data;
        try {
            data = JSON.parse(rawText);
        } catch (parseError) {
            console.error('[loadFromCloud] JSON parse error:', parseError);
            console.error('[loadFromCloud] Error position:', parseError.message);
            
            // Try to show context around the error
            const match = parseError.message.match(/position (\d+)/);
            if (match) {
                const pos = parseInt(match[1]);
                const start = Math.max(0, pos - 100);
                const end = Math.min(rawText.length, pos + 100);
                console.error('[loadFromCloud] Context around error:');
                console.error('...', rawText.substring(start, pos), '<<<ERROR HERE>>>', rawText.substring(pos, end), '...');
            }
            
            // Check for common issues
            if (rawText.includes('<!DOCTYPE') || rawText.includes('<html')) {
                throw new Error('Server returned HTML instead of JSON. Check Apps Script deployment.');
            }
            
            throw new Error(`JSON parse failed: ${parseError.message}`);
        }
        
        console.log('[loadFromCloud] Parsed data keys:', Object.keys(data));
        
        // Check for parse errors from server
        if (data.parseErrors && data.parseErrors.length > 0) {
            console.warn('[loadFromCloud] Server reported parse errors:', data.parseErrors);
        }
        
        if (data.error) {
            setCloudStatus('‚ùå ' + data.error, true);
            status('Load failed: ' + data.error);
            return;
        }
        
        if (data.allData) {
            const participantCount = Object.keys(data.allData).length;
            console.log('[loadFromCloud] Loaded', participantCount, 'participants');
            
            // Log any parse errors but continue loading
            if (data.parseErrors && data.parseErrors.length > 0) {
                console.warn('[loadFromCloud] Some rows had parse errors (data may be incomplete):');
                data.parseErrors.forEach(err => console.warn('  -', err));
            }
            
            if (mergeMode) {
                // Merge with existing data instead of replacing
                mergeDataInto(allData, data.allData);
            } else {
                // Replace current data
                allData = data.allData;
            }
            
            // Snapshot Final data so subsequent saves only send new shapes
            if (isFinal) {
                _finalSnapshot = JSON.parse(JSON.stringify(allData));
                console.log('Captured _finalSnapshot after loading Final (' +
                    Object.keys(_finalSnapshot).length + ' participants)');
            }
            
            if (data.settings && !mergeMode) {
                applySettings(data.settings);
            }
            
            // Rebuild tabs
            rebuildTabsFromData();
            
            const actionLabel = mergeMode ? 'Added' : 'Loaded';
            const source = (!isFinal && fromCoordinates) ? ' (all history)' : '';
            if (data.savedAt) {
                const savedTime = new Date(data.savedAt).toLocaleString();
                setCloudStatus(`‚úÖ ${actionLabel} "${tracerName}"${source} (saved ${savedTime})`);
            } else if (data.pointCount) {
                setCloudStatus(`‚úÖ ${actionLabel} "${tracerName}"${source}: ${data.pointCount} points`);
            } else {
                setCloudStatus(`‚úÖ ${actionLabel} "${tracerName}"${source}`);
            }
            status(mergeMode ? 'Data added from cloud' : 'Loaded from cloud');
        } else {
            setCloudStatus('‚ö†Ô∏è No data found for ' + tracerName);
        }
    } catch (e) {
        console.error('[loadFromCloud] Error:', e);
        setCloudStatus('‚ùå ' + e.message, true);
        status('Cloud load failed');
    }
}

/**
 * Merge source data into target data without replacing existing shapes.
 * Uses epsilon-tolerant shapesMatch for duplicate detection.
 */
function mergeDataInto(target, source) {
    for (const participant of Object.keys(source)) {
        if (!target[participant]) {
            target[participant] = {};
        }
        for (const trial of Object.keys(source[participant])) {
            if (!target[participant][trial]) {
                target[participant][trial] = {};
            }
            for (const freq of Object.keys(source[participant][trial])) {
                if (!target[participant][trial][freq]) {
                    target[participant][trial][freq] = { red: [], blue: [], redAvg: null, blueAvg: null };
                }
                
                const srcData = source[participant][trial][freq];
                const tgtData = target[participant][trial][freq];
                
                // Merge red shapes (epsilon-tolerant duplicate check)
                if (srcData.red) {
                    srcData.red.forEach(srcShape => {
                        if (srcShape && srcShape.length > 0) {
                            const isDuplicate = tgtData.red.some(tgtShape => shapesMatch(tgtShape, srcShape));
                            if (!isDuplicate) {
                                tgtData.red.push(srcShape);
                            }
                        }
                    });
                }
                
                // Merge blue shapes (epsilon-tolerant duplicate check)
                if (srcData.blue) {
                    srcData.blue.forEach(srcShape => {
                        if (srcShape && srcShape.length > 0) {
                            const isDuplicate = tgtData.blue.some(tgtShape => shapesMatch(tgtShape, srcShape));
                            if (!isDuplicate) {
                                tgtData.blue.push(srcShape);
                            }
                        }
                    });
                }
                
                // Keep existing averages or use source averages if target has none
                if (!tgtData.redAvg && srcData.redAvg) {
                    tgtData.redAvg = srcData.redAvg;
                }
                if (!tgtData.blueAvg && srcData.blueAvg) {
                    tgtData.blueAvg = srcData.blueAvg;
                }
            }
        }
    }
}

/**
 * Load all tracers' data at once from CoordinateData sheet
 * This loads ALL historical exports, not just the latest from each tracer
 */
async function loadAllTracers() {
    const url = getCloudUrl();
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    
    try {
        setCloudStatus('‚òÅÔ∏è Loading all coordinate data (excluding Final)...');
        status('Loading all data from CoordinateData (excluding Final)...');
        
        const response = await fetch(`${url}?action=loadAllCoordinates&excludeTracer=Final`);
        const data = await response.json();
        
        if (data.error) {
            setCloudStatus('‚ùå ' + data.error, true);
            status('Load failed: ' + data.error);
            return;
        }
        
        if (data.allData) {
            allData = data.allData;
            rebuildTabsFromData();
            
            const excludeNote = data.excludedTracers ? ` (excluded: ${data.excludedTracers.join(', ')})` : '';
            setCloudStatus(`‚úÖ Loaded ${data.pointCount} points from ${data.tracerCount} tracers${excludeNote}`);
            status(`Loaded all data: ${data.pointCount} points from ${data.tracerCount} tracers${excludeNote}`);
        } else {
            setCloudStatus('‚ö†Ô∏è No coordinate data found');
        }
        
    } catch (e) {
        setCloudStatus('‚ùå Load all failed: ' + e.message, true);
        status('Load all failed');
    }
}

async function listTracers() {
    const url = getCloudUrl();
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    
    try {
        setCloudStatus('‚òÅÔ∏è Fetching tracer list...');
        console.log('[listTracers] Fetching from:', `${url}?action=listTracers`);
        
        const response = await fetch(`${url}?action=listTracers`);
        console.log('[listTracers] Response status:', response.status, response.statusText);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('[listTracers] Response data:', data);
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        const select = document.getElementById('tracer-select');
        select.innerHTML = '<option value="">-- Select tracer to load --</option>';
        
        if (data.tracers && data.tracers.length > 0) {
            data.tracers.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.name;
                // Handle both savedAt and lastSaved for compatibility
                const dateStr = t.savedAt || t.lastSaved;
                let formattedDate = 'unknown date';
                if (dateStr) {
                    try {
                        formattedDate = new Date(dateStr).toLocaleDateString();
                    } catch (e) {
                        formattedDate = dateStr;
                    }
                }
                const protectedLabel = t.isProtected ? ' [PROTECTED]' : '';
                opt.textContent = `${t.name}${protectedLabel} (${t.totalShapes} shapes, saved ${formattedDate})`;
                select.appendChild(opt);
            });
            setCloudStatus(`‚úÖ Found ${data.tracers.length} tracers`);
        } else {
            setCloudStatus('‚ö†Ô∏è No tracers found (sheet may be empty)');
            console.log('[listTracers] No tracers in response. Check if TracerProgress sheet exists and has data.');
        }
    } catch (e) {
        console.error('[listTracers] Error:', e);
        setCloudStatus('‚ùå Failed to list tracers: ' + e.message, true);
    }
}

/**
 * Test connection to cloud API
 * Call from console: testCloudConnection()
 */
async function testCloudConnection() {
    const url = getCloudUrl();
    if (!url) {
        console.error('[testCloudConnection] No URL configured. Set the Apps Script URL first.');
        return { error: 'No URL configured' };
    }
    
    console.log('[testCloudConnection] Testing connection to:', url);
    
    try {
        // Test 1: Basic connection (no action)
        console.log('[testCloudConnection] Test 1: Basic endpoint...');
        const resp1 = await fetch(url);
        const data1 = await resp1.json();
        console.log('[testCloudConnection] Basic response:', data1);
        
        // Test 2: testConnection action
        console.log('[testCloudConnection] Test 2: testConnection action...');
        const resp2 = await fetch(`${url}?action=testConnection`);
        const data2 = await resp2.json();
        console.log('[testCloudConnection] testConnection response:', data2);
        
        // Test 3: listTracers action
        console.log('[testCloudConnection] Test 3: listTracers action...');
        const resp3 = await fetch(`${url}?action=listTracers`);
        const data3 = await resp3.json();
        console.log('[testCloudConnection] listTracers response:', data3);
        
        console.log('[testCloudConnection] All tests complete!');
        return { basic: data1, testConnection: data2, listTracers: data3 };
    } catch (e) {
        console.error('[testCloudConnection] Error:', e);
        return { error: e.message };
    }
}

function loadSelectedTracer() {
    const select = document.getElementById('tracer-select');
    const tracerName = select.value;
    if (tracerName) {
        loadFromCloud(tracerName, false, true); // Load mode (replace), from CoordinateData (all history)
    }
}

function addSelectedTracer() {
    const select = document.getElementById('tracer-select');
    const tracerName = select.value;
    if (tracerName) {
        loadFromCloud(tracerName, true, true); // Merge mode (add to existing), from CoordinateData (all history)
    }
}

function toggleAutoCloudSave() {
    autoCloudSave = !autoCloudSave;
    const btn = document.getElementById('auto-cloud-toggle');
    btn.textContent = autoCloudSave ? '‚ö° Auto-Save: ON' : '‚ö° Auto-Save: OFF';
    btn.className = autoCloudSave 
        ? 'px-4 py-2 rounded-xl font-bold text-sm bg-green-500 text-white shadow'
        : 'px-4 py-2 rounded-xl font-bold text-sm bg-amber-500 text-white shadow';
    
    localStorage.setItem('autoCloudSave', autoCloudSave);
    status(autoCloudSave ? 'Auto-save to cloud enabled' : 'Auto-save disabled');
}

function triggerAutoSave() {
    if (!autoCloudSave) return;
    if (!getCloudUrl() || !getTracerName()) return;
    
    if (cloudSaveTimeout) clearTimeout(cloudSaveTimeout);
    cloudSaveTimeout = setTimeout(() => {
        saveToCloud();
    }, 2000); // Save 2 seconds after last shape
}

function rebuildTabsFromData() {
    const parts = new Map();
    for (const p of Object.keys(allData)) {
        parts.set(p, new Map());
        for (const t of Object.keys(allData[p])) {
            parts.get(p).set(t, new Set());
            for (const fk of Object.keys(allData[p][t])) {
                const hz = parseFloat(fk);
                if (!isNaN(hz)) parts.get(p).get(t).add(hz);
            }
        }
    }
    
    if (parts.size > 0) {
        buildTabs(parts);
        updateGallery();
        updateTable();
    }
}

function loadCloudSettings() {
    const url = localStorage.getItem('cloudUrl');
    const name = localStorage.getItem('tracerName');
    const autoSave = localStorage.getItem('autoCloudSave') === 'true';
    
    if (url) document.getElementById('cloud-url').value = url;
    if (name) document.getElementById('tracer-name').value = name;
    
    if (autoSave) {
        autoCloudSave = true;
        const btn = document.getElementById('auto-cloud-toggle');
        btn.textContent = '‚ö° Auto-Save: ON';
        btn.className = 'px-4 py-2 rounded-xl font-bold text-sm bg-green-500 text-white shadow';
    }
}

// ============================================
// TEST FUNCTIONS - Run from console: runContourTests()
// ============================================

/**
 * Test contour normalization and averaging
 * Creates two identical squares:
 * - Shape 1: Top-left area, drawn CLOCKWISE
 * - Shape 2: Bottom-right area, drawn COUNTER-CLOCKWISE
 * 
 * If normalization works correctly:
 * - Both should be normalized to start at highest Y (with highest X tiebreaker)
 * - Both should be counterclockwise
 * - The average should be centered between them, NOT collapsed/cancelled
 */
function runContourTests() {
    console.log('='.repeat(60));
    console.log('CONTOUR NORMALIZATION AND AVERAGING TESTS');
    console.log('='.repeat(60));
    
    // Test 1: Verify normalizeContour with clockwise vs counterclockwise input
    console.log('\n--- TEST 1: normalizeContour direction handling ---');
    
    // Square at (-5, 5) to (-3, 3) - top-left area
    // Drawn CLOCKWISE (starting top-left, going right)
    const squareCW = [
        { x: -5, y: 5 },  // top-left (highest Y, but not highest X among highest Y)
        { x: -3, y: 5 },  // top-right (highest Y AND highest X) <- should become start
        { x: -3, y: 3 },  // bottom-right
        { x: -5, y: 3 }   // bottom-left
    ];
    
    // Same square drawn COUNTER-CLOCKWISE (starting top-left, going down)
    const squareCCW = [
        { x: -5, y: 5 },  // top-left
        { x: -5, y: 3 },  // bottom-left
        { x: -3, y: 3 },  // bottom-right
        { x: -3, y: 5 }   // top-right (highest Y AND highest X) <- should become start
    ];
    
    const normalizedCW = normalizeContour(squareCW);
    const normalizedCCW = normalizeContour(squareCCW);
    
    console.log('Input CW (clockwise):', JSON.stringify(squareCW));
    console.log('Normalized CW:', JSON.stringify(normalizedCW));
    console.log('Input CCW (counter-clockwise):', JSON.stringify(squareCCW));
    console.log('Normalized CCW:', JSON.stringify(normalizedCCW));
    
    // Check: Both should start at (-3, 5) - the highest Y with highest X
    const cw_start_correct = normalizedCW[0].x === -3 && normalizedCW[0].y === 5;
    const ccw_start_correct = normalizedCCW[0].x === -3 && normalizedCCW[0].y === 5;
    
    console.log(`\nCW starts at highest Y, highest X (-3, 5): ${cw_start_correct ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    console.log(`CCW starts at highest Y, highest X (-3, 5): ${ccw_start_correct ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    
    // Check winding direction (should be counterclockwise = positive signed area)
    function getSignedArea(shape) {
        let area = 0;
        for (let i = 0; i < shape.length; i++) {
            const j = (i + 1) % shape.length;
            area += shape[i].x * shape[j].y;
            area -= shape[j].x * shape[i].y;
        }
        return area / 2;
    }
    
    const cw_area = getSignedArea(normalizedCW);
    const ccw_area = getSignedArea(normalizedCCW);
    
    console.log(`\nNormalized CW signed area: ${cw_area.toFixed(4)} (positive = CCW): ${cw_area > 0 ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    console.log(`Normalized CCW signed area: ${ccw_area.toFixed(4)} (positive = CCW): ${ccw_area > 0 ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    
    // Test 2: Averaging two identical shapes at different positions
    console.log('\n--- TEST 2: Averaging shapes at different positions ---');
    
    // Shape 1: Square at top-left (-6, 6) to (-4, 4), drawn clockwise
    const shape1 = [
        { x: -6, y: 6 },
        { x: -4, y: 6 },
        { x: -4, y: 4 },
        { x: -6, y: 4 }
    ];
    
    // Shape 2: Same size square at bottom-right (4, -4) to (6, -6), drawn counter-clockwise
    const shape2 = [
        { x: 4, y: -4 },
        { x: 4, y: -6 },
        { x: 6, y: -6 },
        { x: 6, y: -4 }
    ];
    
    console.log('Shape 1 (top-left, CW):', JSON.stringify(shape1));
    console.log('Shape 2 (bottom-right, CCW):', JSON.stringify(shape2));
    
    const centroid1 = calculateCentroid(shape1);
    const centroid2 = calculateCentroid(shape2);
    console.log(`\nShape 1 centroid: (${centroid1.x.toFixed(2)}, ${centroid1.y.toFixed(2)})`);
    console.log(`Shape 2 centroid: (${centroid2.x.toFixed(2)}, ${centroid2.y.toFixed(2)})`);
    
    const avgShape = simpleAverageShapes([shape1, shape2]);
    
    if (avgShape) {
        const avgCentroid = calculateCentroid(avgShape);
        const avgArea = calculateAreaShoelace(avgShape);
        
        console.log(`\nAverage shape centroid: (${avgCentroid.x.toFixed(2)}, ${avgCentroid.y.toFixed(2)})`);
        console.log(`Average shape area: ${avgArea.toFixed(4)}`);
        
        // Expected: centroid should be near (-1, 0) - midpoint of the two centroids
        // (-5, 5) and (5, -5) average to (0, 0)
        const expectedCentroidX = (centroid1.x + centroid2.x) / 2;
        const expectedCentroidY = (centroid1.y + centroid2.y) / 2;
        
        console.log(`Expected centroid: (${expectedCentroidX.toFixed(2)}, ${expectedCentroidY.toFixed(2)})`);
        
        const centroidError = Math.sqrt(
            Math.pow(avgCentroid.x - expectedCentroidX, 2) + 
            Math.pow(avgCentroid.y - expectedCentroidY, 2)
        );
        
        console.log(`Centroid error: ${centroidError.toFixed(4)} ${centroidError < 0.5 ? '‚úÖ PASS' : '‚ùå FAIL'}`);
        
        // Area should be approximately the same as input shapes (2x2 = 4 square units)
        const shape1Area = calculateAreaShoelace(shape1);
        const shape2Area = calculateAreaShoelace(shape2);
        
        console.log(`\nShape 1 area: ${shape1Area.toFixed(4)}`);
        console.log(`Shape 2 area: ${shape2Area.toFixed(4)}`);
        console.log(`Average shape area: ${avgArea.toFixed(4)}`);
        console.log(`Area preserved: ${Math.abs(avgArea - shape1Area) < 1 ? '‚úÖ PASS' : '‚ö†Ô∏è CHECK (radial sampling may differ slightly)'}`);
        
        // Check that average shape starts at highest Y with highest X tiebreaker
        let highestY = -Infinity;
        let highestX = -Infinity;
        for (const pt of avgShape) {
            if (pt.y > highestY || (pt.y === highestY && pt.x > highestX)) {
                highestY = pt.y;
                highestX = pt.x;
            }
        }
        
        const startsCorrectly = Math.abs(avgShape[0].y - highestY) < 0.01 && 
                                Math.abs(avgShape[0].x - highestX) < 0.01;
        console.log(`\nAverage shape starts at highest Y, highest X: ${startsCorrectly ? '‚úÖ PASS' : '‚ùå FAIL'}`);
        console.log(`  First point: (${avgShape[0].x.toFixed(2)}, ${avgShape[0].y.toFixed(2)})`);
        console.log(`  Highest Y, X: (${highestX.toFixed(2)}, ${highestY.toFixed(2)})`);
        
        // Check winding direction
        const avgSignedArea = getSignedArea(avgShape);
        console.log(`\nAverage shape signed area: ${avgSignedArea.toFixed(4)} (positive = CCW): ${avgSignedArea > 0 ? '‚úÖ PASS' : '‚ùå FAIL'}`);
        
    } else {
        console.log('‚ùå FAIL: simpleAverageShapes returned null');
    }
    
    // Test 3: Worst-case input - shapes drawn from non-highest-Y starting points, clockwise
    console.log('\n--- TEST 3: Non-highest-Y start, clockwise input ---');
    console.log('Both shapes are identical 2x2 squares at origin but drawn differently:');
    
    // Shape A: Start at BOTTOM-LEFT, go CLOCKWISE
    const shapeA = [
        { x: -1, y: -1 },  // bottom-left (start here - NOT highest Y)
        { x: -1, y: 1 },   // top-left (going up - clockwise)
        { x: 1, y: 1 },    // top-right
        { x: 1, y: -1 }    // bottom-right
    ];
    
    // Shape B: Start at RIGHT, go CLOCKWISE
    const shapeB = [
        { x: 1, y: -1 },   // bottom-right (start here - NOT highest Y)
        { x: -1, y: -1 },  // bottom-left (going left - clockwise)
        { x: -1, y: 1 },   // top-left
        { x: 1, y: 1 }     // top-right
    ];
    
    console.log('Shape A (start bottom-left, CW):', JSON.stringify(shapeA));
    console.log('Shape B (start bottom-right, CW):', JSON.stringify(shapeB));
    
    // Both should normalize to the same thing
    const normA = normalizeContour(shapeA);
    const normB = normalizeContour(shapeB);
    
    console.log('Normalized A:', JSON.stringify(normA));
    console.log('Normalized B:', JSON.stringify(normB));
    
    // Both should start at (1, 1) - highest Y with highest X tiebreaker
    const normA_startOk = normA[0].x === 1 && normA[0].y === 1;
    const normB_startOk = normB[0].x === 1 && normB[0].y === 1;
    console.log(`\nShape A starts at (1,1): ${normA_startOk ? '‚úÖ PASS' : '‚ùå FAIL'} (got: ${normA[0].x}, ${normA[0].y})`);
    console.log(`Shape B starts at (1,1): ${normB_startOk ? '‚úÖ PASS' : '‚ùå FAIL'} (got: ${normB[0].x}, ${normB[0].y})`);
    
    // Both should be CCW
    const normA_area = getSignedArea(normA);
    const normB_area = getSignedArea(normB);
    console.log(`Shape A CCW (positive area): ${normA_area > 0 ? '‚úÖ PASS' : '‚ùå FAIL'} (${normA_area.toFixed(4)})`);
    console.log(`Shape B CCW (positive area): ${normB_area > 0 ? '‚úÖ PASS' : '‚ùå FAIL'} (${normB_area.toFixed(4)})`);
    
    // Both should produce identical normalized output
    let pointsMatch = normA.length === normB.length;
    if (pointsMatch) {
        for (let i = 0; i < normA.length; i++) {
            if (normA[i].x !== normB[i].x || normA[i].y !== normB[i].y) {
                pointsMatch = false;
                break;
            }
        }
    }
    console.log(`Normalized A === Normalized B: ${pointsMatch ? '‚úÖ PASS' : '‚ùå FAIL'}`);
    
    // Now average them - result should be the same square
    const avgAB = simpleAverageShapes([shapeA, shapeB]);
    if (avgAB) {
        const avgAB_centroid = calculateCentroid(avgAB);
        const avgAB_areaShoelace = calculateAreaShoelace(avgAB);
        const avgAB_signedArea = getSignedArea(avgAB);
        
        // Centroid should be near origin (0, 0)
        const centroidNearOrigin = Math.abs(avgAB_centroid.x) < 0.2 && Math.abs(avgAB_centroid.y) < 0.2;
        console.log(`\nAverage centroid near (0,0): ${centroidNearOrigin ? '‚úÖ PASS' : '‚ùå FAIL'} (got: ${avgAB_centroid.x.toFixed(3)}, ${avgAB_centroid.y.toFixed(3)})`);
        
        // Area should be near 4 (2x2 square)
        console.log(`Average area (shoelace): ${avgAB_areaShoelace.toFixed(4)} (expected ~4.0): ${Math.abs(avgAB_areaShoelace - 4) < 0.5 ? '‚úÖ PASS' : '‚ùå FAIL'}`);
        
        // Must start at highest Y
        let hY = -Infinity, hX = -Infinity;
        for (const pt of avgAB) {
            if (pt.y > hY || (pt.y === hY && pt.x > hX)) { hY = pt.y; hX = pt.x; }
        }
        const avgStartOk = Math.abs(avgAB[0].y - hY) < 0.01 && Math.abs(avgAB[0].x - hX) < 0.01;
        console.log(`Average starts at highest Y, highest X: ${avgStartOk ? '‚úÖ PASS' : '‚ùå FAIL'}`);
        
        // Must be CCW
        console.log(`Average is CCW: ${avgAB_signedArea > 0 ? '‚úÖ PASS' : '‚ùå FAIL'} (signed area: ${avgAB_signedArea.toFixed(4)})`);
    } else {
        console.log('‚ùå FAIL: Average returned null');
    }
    
    // Test 4: Opposite positions, opposite directions - must NOT cancel out
    console.log('\n--- TEST 4: CW at (1,1) + CCW at (-1,-1) must not cancel ---');
    console.log('Two identical 2x2 squares at opposite positions with opposite winding:');
    
    // Shape C: 2x2 square centered at (1, 1), drawn CLOCKWISE
    // Vertices: (0,2), (2,2), (2,0), (0,0) - starting top-left, going right (CW)
    const shapeC = [
        { x: 0, y: 2 },   // top-left
        { x: 2, y: 2 },   // top-right
        { x: 2, y: 0 },   // bottom-right
        { x: 0, y: 0 }    // bottom-left
    ];
    
    // Shape D: 2x2 square centered at (-1, -1), drawn COUNTER-CLOCKWISE
    // Vertices: (-2,0), (-2,-2), (0,-2), (0,0) - starting top-left, going down (CCW)
    const shapeD = [
        { x: -2, y: 0 },  // top-left
        { x: -2, y: -2 }, // bottom-left
        { x: 0, y: -2 },  // bottom-right
        { x: 0, y: 0 }    // top-right
    ];
    
    console.log('Shape C (center 1,1 - CW):', JSON.stringify(shapeC));
    console.log('Shape D (center -1,-1 - CCW):', JSON.stringify(shapeD));
    
    const centroidC = calculateCentroid(shapeC);
    const centroidD = calculateCentroid(shapeD);
    console.log(`Shape C centroid: (${centroidC.x.toFixed(2)}, ${centroidC.y.toFixed(2)})`);
    console.log(`Shape D centroid: (${centroidD.x.toFixed(2)}, ${centroidD.y.toFixed(2)})`);
    console.log(`Shape C area (shoelace): ${calculateAreaShoelace(shapeC).toFixed(4)}`);
    console.log(`Shape D area (shoelace): ${calculateAreaShoelace(shapeD).toFixed(4)}`);
    
    const avgCD = simpleAverageShapes([shapeC, shapeD]);
    if (avgCD) {
        const avgCD_centroid = calculateCentroid(avgCD);
        const avgCD_areaShoelace = calculateAreaShoelace(avgCD);
        const avgCD_signedArea = getSignedArea(avgCD);
        
        // Critical check: area must NOT be near zero (not cancelled out)
        const notCancelled = avgCD_areaShoelace > 2.0;
        console.log(`\nArea NOT cancelled (> 2.0): ${notCancelled ? '‚úÖ PASS' : '‚ùå FAIL'} (got: ${avgCD_areaShoelace.toFixed(4)})`);
        
        // Area should be near 4.0 (both inputs are 2x2 = 4 sq units)
        const areaPreserved = Math.abs(avgCD_areaShoelace - 4) < 0.5;
        console.log(`Area ~4.0 (preserved): ${areaPreserved ? '‚úÖ PASS' : '‚ö†Ô∏è CHECK'} (got: ${avgCD_areaShoelace.toFixed(4)})`);
        
        // Centroid should be near (0, 0) - midpoint of (1,1) and (-1,-1)
        const centroidNearOrigin = Math.abs(avgCD_centroid.x) < 0.3 && Math.abs(avgCD_centroid.y) < 0.3;
        console.log(`Centroid near (0,0): ${centroidNearOrigin ? '‚úÖ PASS' : '‚ùå FAIL'} (got: ${avgCD_centroid.x.toFixed(3)}, ${avgCD_centroid.y.toFixed(3)})`);
        
        // Must start at highest Y
        let hY4 = -Infinity, hX4 = -Infinity;
        for (const pt of avgCD) {
            if (pt.y > hY4 || (pt.y === hY4 && pt.x > hX4)) { hY4 = pt.y; hX4 = pt.x; }
        }
        const avgCD_startOk = Math.abs(avgCD[0].y - hY4) < 0.01 && Math.abs(avgCD[0].x - hX4) < 0.01;
        console.log(`Starts at highest Y, highest X: ${avgCD_startOk ? '‚úÖ PASS' : '‚ùå FAIL'}`);
        
        // Must be CCW
        console.log(`Is CCW: ${avgCD_signedArea > 0 ? '‚úÖ PASS' : '‚ùå FAIL'} (signed area: ${avgCD_signedArea.toFixed(4)})`);
    } else {
        console.log('‚ùå FAIL: Average returned null (shapes may have cancelled!)');
    }
    
    console.log('\n' + '='.repeat(60));
    console.log('END OF TESTS');
    console.log('='.repeat(60));
    
    return { normalizedCW, normalizedCCW, avgShape };
}

/**
 * Test ZIP path parsing logic
 * Run from console: runZipParsingTests()
 */
function runZipParsingTests() {
    console.log('='.repeat(60));
    console.log('ZIP PATH PARSING TESTS');
    console.log('='.repeat(60));
    
    // Test cases for folder pattern matching
    const testCases = [
        {
            path: 'Jiaxin L_11_Drawings 2/Jiaxin L_62.5Hz_100dB.png',
            expectedParticipant: 'Jiaxin L',
            expectedFolderNum: 11,
            expectedFreq: 62.5
        },
        {
            path: 'John_3/John_1000Hz_80dB.png',
            expectedParticipant: 'John',
            expectedFolderNum: 3,
            expectedFreq: 1000
        },
        {
            path: 'Mary Smith_5_Trial/Mary Smith_250Hz_90dB.png',
            expectedParticipant: 'Mary Smith',
            expectedFolderNum: 5,
            expectedFreq: 250
        },
        {
            path: 'OuterZip/InnerZip/Participant_7/Participant_500Hz_100dB.png',
            expectedParticipant: 'Participant',
            expectedFolderNum: 7,
            expectedFreq: 500
        },
        {
            path: 'Simple/2/Test_125Hz_85dB.png',
            expectedParticipant: 'Simple',
            expectedFolderNum: 2,
            expectedFreq: 125
        }
    ];
    
    let passCount = 0;
    let failCount = 0;
    
    for (const tc of testCases) {
        console.log(`\n--- Testing: ${tc.path} ---`);
        
        const pathParts = tc.path.split('/').filter(p => p.length > 0);
        const filename = pathParts[pathParts.length - 1];
        
        let folderNum = null;
        let partPath = null;
        
        // Replicate the folder matching logic from processZip
        for (let i = 0; i < pathParts.length - 1; i++) {
            const part = pathParts[i];
            
            // Pattern: "Name_Number" or "Name_Number_AnythingElse"
            const match = part.match(/^(.+?)_(\d+)(?:_.*)?$/);
            if (match) {
                partPath = match[1].trim();
                folderNum = parseInt(match[2]);
                console.log(`  Matched folder pattern: "${part}" ‚Üí participant="${partPath}", folderNum=${folderNum}`);
                break;
            }
            
            // Check for purely numeric folders
            if (/^\d+$/.test(part)) {
                folderNum = parseInt(part);
                if (i > 0) {
                    partPath = pathParts[i - 1];
                }
                console.log(`  Found numeric folder: ${part} ‚Üí folderNum=${folderNum}, participant=${partPath}`);
                break;
            }
        }
        
        // Fallback to filename parsing
        const participant = partPath || parseParticipant(filename);
        const freq = parseFreq(filename);
        
        console.log(`  Final: participant="${participant}", folderNum=${folderNum}, freq=${freq}Hz`);
        
        // Check results
        const participantOk = participant === tc.expectedParticipant;
        const folderNumOk = folderNum === tc.expectedFolderNum;
        const freqOk = freq === tc.expectedFreq;
        
        console.log(`  Participant: ${participantOk ? '‚úÖ' : '‚ùå'} (expected: "${tc.expectedParticipant}", got: "${participant}")`);
        console.log(`  Folder Num: ${folderNumOk ? '‚úÖ' : '‚ùå'} (expected: ${tc.expectedFolderNum}, got: ${folderNum})`);
        console.log(`  Frequency: ${freqOk ? '‚úÖ' : '‚ùå'} (expected: ${tc.expectedFreq}, got: ${freq})`);
        
        if (participantOk && folderNumOk && freqOk) {
            passCount++;
        } else {
            failCount++;
        }
    }
    
    console.log('\n' + '='.repeat(60));
    console.log(`RESULTS: ${passCount} passed, ${failCount} failed`);
    console.log('='.repeat(60));
    
    return { passCount, failCount };
}

// Make test functions available globally
window.runZipParsingTests = runZipParsingTests;

// Make test function available globally
window.runContourTests = runContourTests;

// Make diagnostic and cloud test functions available globally
window.runDataDiagnostics = runDataDiagnostics;
window.listShapesByParticipant = listShapesByParticipant;
window.compareCentroidMethods = compareCentroidMethods;
window.testCloudConnection = testCloudConnection;

/**
 * Print all available console diagnostic commands
 * Call from console: help() or showDiagnostics()
 */
function showDiagnostics() {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           SOUND OBJECT CONTOUR TRACER - CONSOLE DIAGNOSTICS                  ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                              ‚ïë
‚ïë  DATA ANALYSIS:                                                              ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                               ‚ïë
‚ïë  runDataDiagnostics()      - Compare tracing app data to manuscript values   ‚ïë
‚ïë                              Shows shape counts, centroids, areas, shifts    ‚ïë
‚ïë                              for 500, 1000, 2000 Hz with ratio comparisons   ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  listShapesByParticipant() - List all shapes grouped by participant/trial    ‚ïë
‚ïë                              Use to identify duplicate or missing shapes     ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  compareCentroidMethods()  - Compare simple average vs resampled centroid    ‚ïë
‚ïë                              Shows difference between methods                ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  CLOUD CONNECTION:                                                           ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                           ‚ïë
‚ïë  testCloudConnection()     - Test connection to Google Apps Script           ‚ïë
‚ïë                              Runs 3 tests: basic, testConnection, listTracers‚ïë
‚ïë                              Use to debug cloud sync issues                  ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  GEOMETRY TESTS:                                                             ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                             ‚ïë
‚ïë  runContourTests()         - Test contour normalization and averaging        ‚ïë
‚ïë                              Verifies CW/CCW detection, alignment, area      ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  runZipParsingTests()      - Test ZIP file parsing logic                     ‚ïë
‚ïë                              Verifies participant/frequency extraction       ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  DATA ACCESS:                                                                ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                                ‚ïë
‚ïë  allData                   - Current trace data (all participants/trials)    ‚ïë
‚ïë  frequencyAverages         - Current frequency average data                  ‚ïë
‚ïë  images                    - Loaded participant images                       ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  QUICK CHECKS:                                                               ‚ïë
‚ïë  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                                                               ‚ïë
‚ïë  Object.keys(allData)      - List all loaded participants                    ‚ïë
‚ïë  Object.keys(frequencyAverages) - List all frequencies with averages         ‚ïë
‚ïë  frequencyAverages['500']  - View data for specific frequency                ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);
}
window.showDiagnostics = showDiagnostics;
window.help = showDiagnostics;

// ============================================
// INIT
// ============================================
function init() {
    canvas = document.getElementById('drawing-canvas');
    ctx = canvas.getContext('2d');
    canvas.width = canvas.height = CANVAS_SIZE;
    
    // Pointer Events: route through unified handlers that detect
    // single-pointer drawing vs two-finger pinch-zoom gestures.
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointermove', handlePointerMove);
    canvas.addEventListener('pointerup', handlePointerUp);
    canvas.addEventListener('pointerleave', handlePointerUp);
    canvas.addEventListener('pointercancel', handlePointerUp);
    
    // Mouse wheel zoom on desktop
    document.getElementById('canvas-container').addEventListener('wheel', e => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? -0.15 : 0.15;
        const newScale = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoomScale + delta));
        if (newScale === zoomScale) return;

        // Zoom toward cursor position
        const rect = canvas.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const ds = newScale / zoomScale;
        zoomTranslateX = cx - ds * (cx - zoomTranslateX);
        zoomTranslateY = cy - ds * (cy - zoomTranslateY);
        zoomScale = newScale;
        applyZoomTransform();
    }, { passive: false });
    
    // Reset zoom button
    document.getElementById('reset-zoom').onclick = resetZoom;
    
    document.getElementById('color-red').onclick = () => { selColor = 'red'; document.getElementById('color-red').classList.add('selected'); document.getElementById('color-blue').classList.remove('selected'); };
    document.getElementById('color-blue').onclick = () => { selColor = 'blue'; document.getElementById('color-blue').classList.add('selected'); document.getElementById('color-red').classList.remove('selected'); };
    
    document.getElementById('brush-slider').oninput = e => { brushSize = +e.target.value; document.getElementById('brush-val').textContent = brushSize; };
    document.getElementById('resample-slider').oninput = e => { resampleRate = +e.target.value; document.getElementById('resample-val').textContent = resampleRate; };
    document.getElementById('img-opacity-slider').oninput = e => { IMAGE_OPACITY = +e.target.value / 100; document.getElementById('img-opacity-val').textContent = e.target.value + '%'; redraw(); };
    document.getElementById('shape-opacity-slider').oninput = e => { SHAPE_OPACITY = +e.target.value / 100; document.getElementById('shape-opacity-val').textContent = e.target.value + '%'; redraw(); };
    document.getElementById('radial-res-slider').oninput = e => { radialResolution = +e.target.value; document.getElementById('radial-res-val').textContent = radialResolution; };
    
    document.getElementById('toggle-draw').onclick = () => { drawingOn = !drawingOn; const b = document.getElementById('toggle-draw'); b.textContent = drawingOn ? '‚úèÔ∏è ON' : '‚úèÔ∏è OFF'; b.className = b.className.replace(drawingOn ? 'bg-red' : 'bg-green', drawingOn ? 'bg-green' : 'bg-red'); canvas.style.cursor = drawingOn ? 'crosshair' : 'default'; };
    document.getElementById('undo-btn').onclick = undo;
    document.getElementById('redo-btn').onclick = redo;
    document.getElementById('clear-btn').onclick = () => { if (confirm('Clear all?')) { const d = curData(); if (d) { undoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) }); d.red = []; d.blue = []; d.redAvg = null; d.blueAvg = null; } redraw(); updateTable(); updateGallery(); document.getElementById('undo-btn').disabled = false; } };
    document.getElementById('grid-btn').onclick = () => { showGrid = !showGrid; redraw(); };
    
    document.getElementById('zip-upload').onchange = e => { if (e.target.files[0]) handleZip(e.target.files[0]); };
    document.getElementById('single-upload').onchange = e => { if (e.target.files[0]) handleSingle(e.target.files[0]); };
    document.getElementById('json-import').onchange = e => { if (e.target.files[0]) handleJson(e.target.files[0]); };
    
    document.getElementById('bulk-avg').onclick = openModal;
    document.getElementById('clear-avg').onclick = clearAvgCur;
    document.getElementById('gen-freq-avg').onclick = generateFrequencyAverages;
    document.getElementById('export-freq-png').onclick = exportFrequencyPNGs;
    
    document.getElementById('close-modal').onclick = () => document.getElementById('modal').classList.remove('active');
    document.getElementById('cancel-modal').onclick = () => document.getElementById('modal').classList.remove('active');
    document.getElementById('do-bulk').onclick = doBulk;
    document.getElementById('sel-all-f').onclick = () => document.querySelectorAll('#mod-f input').forEach(c => c.checked = true);
    
    document.getElementById('toggle-data').onclick = () => document.getElementById('data-box').classList.toggle('hidden');
    
    document.getElementById('exp-csv').onclick = expCSV;
    document.getElementById('exp-json').onclick = expJSON;
    
    // Cloud collaboration
    document.getElementById('cloud-save').onclick = saveToCloud;
    document.getElementById('cloud-load').onclick = () => loadFromCloud(null, false, true); // Load from CoordinateData
    document.getElementById('cloud-list').onclick = listTracers;
    document.getElementById('cloud-load-all').onclick = loadAllTracers;
    document.getElementById('cloud-load-other').onclick = loadSelectedTracer;
    document.getElementById('cloud-add-other').onclick = addSelectedTracer;
    document.getElementById('auto-cloud-toggle').onclick = toggleAutoCloudSave;
    document.getElementById('cloud-progress-close').onclick = hideCloudProgress;
    
    // Final frequency replacement
    document.getElementById('final-replace-btn').onclick = replaceFinalFrequency;
    populateFinalFrequencyDropdown();
    
    // Load saved settings
    loadCloudSettings();
    
    drawGrid();
}

window.addEventListener('load', init);
</script>
</body>
</html>
