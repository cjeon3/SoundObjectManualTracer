<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sound Object Contour Tracer | UCI Hearing & Speech Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * { -webkit-tap-highlight-color: transparent; }
        body { min-height: 100vh; font-family: ui-sans-serif, system-ui, sans-serif; background: #f3f4f6; }
        #canvas-container { max-width: 100%; width: 100%; margin: 0 auto; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); border-radius: 0.75rem; overflow: hidden; background: #fff; touch-action: none; aspect-ratio: 1; }
        #drawing-canvas { display: block; width: 100%; height: 100%; touch-action: none; cursor: crosshair; }
        input[type="range"] { -webkit-appearance: none; background: transparent; cursor: pointer; width: 100%; height: 40px; }
        input[type="range"]::-webkit-slider-runnable-track { background: linear-gradient(to right, #3b82f6, #8b5cf6); height: 8px; border-radius: 4px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 24px; width: 24px; background: #000; border: 3px solid #fff; border-radius: 50%; cursor: grab; margin-top: -8px; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
        input[type="range"]::-moz-range-track { background: linear-gradient(to right, #3b82f6, #8b5cf6); height: 8px; border-radius: 4px; }
        input[type="range"]::-moz-range-thumb { height: 24px; width: 24px; background: #000; border: 3px solid #fff; border-radius: 50%; cursor: grab; box-shadow: 0 2px 6px rgba(0,0,0,0.4); }
        .slider-labels { display: flex; justify-content: space-between; font-size: 11px; color: #6b7280; margin-top: 4px; }
        .tab-btn { transition: all 0.2s; }
        .tab-btn.active { background: linear-gradient(to right, #3b82f6, #8b5cf6) !important; color: white !important; transform: scale(1.05); }
        .trial-btn.active { background: linear-gradient(to right, #10b981, #059669) !important; color: white !important; }
        .freq-btn.active { background: linear-gradient(to right, #f59e0b, #d97706) !important; color: white !important; }
        .color-button.selected { border: 4px solid white !important; box-shadow: 0 0 0 4px #3b82f6 !important; transform: scale(1.15) !important; }
        .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s; }
        .modal.active { opacity: 1; visibility: visible; }
        .modal-content { background: white; border-radius: 16px; padding: 1.5rem; max-width: 900px; width: 95%; max-height: 90vh; overflow-y: auto; }
        .checkbox-grid { display: grid; gap: 0.5rem; max-height: 200px; overflow-y: auto; }
        .checkbox-item { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; background: #f8fafc; border-radius: 6px; cursor: pointer; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .data-table th { background: #f1f5f9; padding: 0.5rem; text-align: left; font-weight: 600; }
        .data-table td { padding: 0.5rem; border-bottom: 1px solid #e2e8f0; font-family: monospace; }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="max-w-6xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-blue-800 mb-2">Sound Object Contour Tracer</h1>
            <p class="text-xl font-semibold text-gray-600">UCI Hearing & Speech Lab</p>
        </header>
        
        <!-- Upload -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-lg font-bold text-gray-800 mb-4">üìÅ Upload Images or Import Data</h2>
            <div class="flex flex-wrap gap-3">
                <label class="px-6 py-2.5 rounded-xl font-bold text-sm bg-gradient-to-r from-blue-500 to-blue-600 text-white shadow-lg cursor-pointer">üìÅ Upload ZIP<input type="file" id="zip-upload" accept=".zip" class="hidden"></label>
                <label class="px-6 py-2.5 rounded-xl font-bold text-sm bg-gradient-to-r from-purple-500 to-purple-600 text-white shadow-lg cursor-pointer">üñºÔ∏è Single PNG<input type="file" id="single-upload" accept="image/png" class="hidden"></label>
                <label class="px-6 py-2.5 rounded-xl font-bold text-sm bg-gradient-to-r from-teal-500 to-teal-600 text-white shadow-lg cursor-pointer">üì• Import JSON<input type="file" id="json-import" accept=".json" class="hidden"></label>
            </div>
            <p class="mt-3 text-sm text-gray-500">Supports nested ZIPs. Structure: ParticipantName/TrialFolder/filename.png</p>
            <div id="upload-log" class="mt-3 text-xs text-gray-600 font-mono max-h-64 overflow-y-auto border border-gray-200 rounded-lg p-2 bg-gray-50 hidden"></div>
        </div>
        
        <!-- Participant Tabs -->
        <div id="participant-section" class="bg-white p-4 rounded-xl shadow-lg mb-4 hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-3">Select Participant</h2>
            <div id="participant-tabs" class="flex flex-wrap gap-2"></div>
        </div>
        
        <!-- Trial Tabs -->
        <div id="trial-section" class="bg-white p-4 rounded-xl shadow-lg mb-4 hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-3">Select Trial</h2>
            <div id="trial-tabs" class="flex flex-wrap gap-2"></div>
        </div>
        
        <!-- Frequency Tabs -->
        <div id="frequency-section" class="bg-white p-4 rounded-xl shadow-lg mb-4 hidden">
            <h2 class="text-lg font-bold text-gray-800 mb-3">Select Frequency</h2>
            <div id="frequency-tabs" class="flex flex-wrap gap-2"></div>
        </div>
        
        <!-- Canvas -->
        <div id="canvas-container" class="bg-white rounded-xl shadow-2xl mb-6"><canvas id="drawing-canvas"></canvas></div>
        
        <!-- Controls -->
        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 space-y-4">
            <div class="flex flex-wrap items-start gap-6">
                <div>
                    <p class="font-bold text-gray-800 mb-2">Color</p>
                    <div class="flex gap-3">
                        <button id="color-red" class="color-button w-12 h-12 rounded-full shadow-md border-4 border-gray-200 selected" style="background:#ef4444;"></button>
                        <button id="color-blue" class="color-button w-12 h-12 rounded-full shadow-md border-4 border-gray-200" style="background:#3b82f6;"></button>
                    </div>
                </div>
                <div class="flex-1 min-w-[250px]">
                    <label class="font-bold text-gray-800">Brush Size: <span id="brush-val" class="text-xl text-blue-600">5</span></label>
                    <input id="brush-slider" type="range" min="1" max="10" value="5">
                    <div class="slider-labels"><span>1px</span><span>5px</span><span>10px</span></div>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 pt-4 border-t">
                <div class="bg-blue-50 p-4 rounded-xl">
                    <label class="font-bold text-gray-800">Resample Rate: <span id="resample-val" class="text-xl text-blue-600">1000</span></label>
                    <input id="resample-slider" type="range" min="500" max="10000" step="250" value="1000">
                    <div class="slider-labels"><span>500</span><span>5000</span><span>10000</span></div>
                </div>
                <div class="bg-purple-50 p-4 rounded-xl">
                    <label class="font-bold text-gray-800">Image Opacity: <span id="img-opacity-val" class="text-xl text-purple-600">10%</span></label>
                    <input id="img-opacity-slider" type="range" min="0" max="100" value="10">
                    <div class="slider-labels"><span>0%</span><span>50%</span><span>100%</span></div>
                </div>
                <div class="bg-green-50 p-4 rounded-xl">
                    <label class="font-bold text-gray-800">Shape Opacity: <span id="shape-opacity-val" class="text-xl text-green-600">30%</span></label>
                    <input id="shape-opacity-slider" type="range" min="0" max="100" value="30">
                    <div class="slider-labels"><span>0%</span><span>50%</span><span>100%</span></div>
                </div>
            </div>
            <div class="flex flex-wrap gap-2 pt-4 border-t">
                <button id="toggle-draw" class="px-5 py-2 rounded-xl font-bold text-sm bg-green-500 text-white shadow">‚úèÔ∏è Drawing: ON</button>
                <button id="undo-btn" disabled class="px-5 py-2 rounded-xl font-bold text-sm bg-yellow-400 text-gray-900 shadow disabled:opacity-50">‚Ü©Ô∏è Undo</button>
                <button id="redo-btn" disabled class="px-5 py-2 rounded-xl font-bold text-sm bg-yellow-400 text-gray-900 shadow disabled:opacity-50">‚Ü™Ô∏è Redo</button>
                <button id="clear-btn" class="px-5 py-2 rounded-xl font-bold text-sm bg-red-500 text-white shadow">üóëÔ∏è Clear</button>
                <button id="grid-btn" class="px-5 py-2 rounded-xl font-bold text-sm bg-gray-500 text-white shadow">üìê Grid</button>
            </div>
            <div id="status" class="text-sm text-gray-500 pt-2 border-t">Ready. Upload images to begin.</div>
            <div class="pt-2 border-t text-sm">
                <span class="font-semibold">Current:</span>
                <span id="info-p" class="font-mono text-gray-700">-</span> |
                <span id="info-t" class="font-mono text-gray-700">-</span> |
                <span id="info-f" class="font-mono text-gray-700">-</span> |
                Red: <span id="info-r" class="font-mono font-bold text-red-500">0</span> |
                Blue: <span id="info-b" class="font-mono font-bold text-blue-500">0</span>
            </div>
        </div>
        
        <!-- Generate Average Shapes Section - Below Controls, Above Export -->
        <div class="bg-gradient-to-r from-emerald-50 to-teal-50 p-6 rounded-xl shadow-lg mb-6 border-2 border-emerald-200">
            <h2 class="font-bold text-emerald-800 mb-4">Generate Average Shapes</h2>
            
            <!-- Current Selection Average -->
            <div class="mb-4 p-4 bg-white rounded-xl">
                <h3 class="font-semibold text-gray-700 mb-3">Current Selection</h3>
                <div class="grid grid-cols-3 gap-3">
                    <button id="gen-avg" class="px-4 py-2 rounded-xl font-bold text-sm bg-emerald-500 text-white shadow">Generate Current</button>
                    <button id="bulk-avg" class="px-4 py-2 rounded-xl font-bold text-sm bg-indigo-500 text-white shadow">Bulk Generate...</button>
                    <button id="clear-avg" class="px-4 py-2 rounded-xl font-bold text-sm bg-orange-400 text-white shadow">Clear Average</button>
                </div>
            </div>
            
            <!-- Cross-Participant Frequency Averaging -->
            <div class="p-4 bg-white rounded-xl">
                <h3 class="font-semibold text-gray-700 mb-3">Cross-Participant Frequency Averages</h3>
                <p class="text-xs text-gray-500 mb-3">Generate average shapes across ALL participants for each frequency. Creates PNG images with transparent individual traces and solid average contours.</p>
                <div class="grid grid-cols-2 gap-3">
                    <button id="gen-freq-avg" class="px-4 py-2 rounded-xl font-bold text-sm bg-teal-600 text-white shadow">Generate Frequency Averages</button>
                    <button id="export-freq-png" class="px-4 py-2 rounded-xl font-bold text-sm bg-cyan-600 text-white shadow">Export as PNG Images</button>
                </div>
                <div id="freq-avg-status" class="text-xs text-gray-500 mt-3"></div>
            </div>
        </div>
        
        <!-- Data Table -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <div class="flex justify-between mb-4">
                <h2 class="font-bold text-blue-700">Coordinate Data</h2>
                <button id="toggle-data" class="px-4 py-1 rounded-lg text-sm bg-gray-100">Show/Hide</button>
            </div>
            <div id="data-box" class="hidden max-h-80 overflow-auto">
                <table class="data-table"><thead><tr><th>Participant</th><th>Trial</th><th>Freq</th><th>Color</th><th>#</th><th>Pts</th><th>Sample</th></tr></thead><tbody id="data-body"><tr><td colspan="7" class="text-center text-gray-400 py-8">No data</td></tr></tbody></table>
            </div>
            <p class="text-xs text-gray-500 mt-2">Grid: 1000√ó1000px canvas, 20√ó20 units (-10 to +10), 50px per unit. Images align 1:1 with grid.</p>
        </div>
        
        <!-- Export -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h3 class="font-bold text-gray-800 mb-4">Export Data</h3>
            <div class="grid grid-cols-2 gap-3">
                <button id="exp-csv" class="px-4 py-2 rounded-xl font-bold text-sm bg-teal-500 text-white shadow">CSV</button>
                <button id="exp-json" class="px-4 py-2 rounded-xl font-bold text-sm bg-purple-500 text-white shadow">JSON</button>
            </div>
        </div>
        
        <!-- Cloud Collaboration -->
        <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-6 rounded-xl shadow-lg mb-6 border-2 border-indigo-200">
            <h3 class="font-bold text-indigo-800 mb-3">‚òÅÔ∏è Cloud Collaboration (Google Sheets)</h3>
            <p class="text-xs text-gray-600 mb-4">Multiple tracers can save/load progress. Each person's work is stored separately and can be merged.</p>
            
            <div class="mb-4">
                <label class="block text-sm font-semibold text-gray-700 mb-1">Apps Script URL</label>
                <input id="cloud-url" placeholder="https://script.google.com/macros/s/..." class="w-full px-3 py-2 border-2 border-indigo-300 rounded-xl text-sm">
            </div>
            
            <div class="mb-4">
                <label class="block text-sm font-semibold text-gray-700 mb-1">Your Tracer Name</label>
                <input id="tracer-name" placeholder="e.g., James, Sarah, Lab_Assistant_1" class="w-full px-3 py-2 border-2 border-indigo-300 rounded-xl text-sm">
            </div>
            
            <div class="grid grid-cols-2 gap-3 mb-4">
                <button id="cloud-save" class="px-4 py-2 rounded-xl font-bold text-sm bg-green-500 text-white shadow">üíæ Save to Cloud</button>
                <button id="cloud-load" class="px-4 py-2 rounded-xl font-bold text-sm bg-blue-500 text-white shadow">üìÇ Load My Progress</button>
            </div>
            
            <div class="border-t border-indigo-200 pt-4 mt-4">
                <h4 class="font-semibold text-gray-700 mb-2">Team Collaboration</h4>
                <div class="grid grid-cols-2 gap-3 mb-3">
                    <button id="cloud-list" class="px-4 py-2 rounded-xl font-bold text-sm bg-indigo-500 text-white shadow">üë• List All Tracers</button>
                    <button id="cloud-merge" class="px-4 py-2 rounded-xl font-bold text-sm bg-purple-500 text-white shadow">üîÄ Merge All Data</button>
                </div>
                <div class="flex gap-2">
                    <select id="tracer-select" class="flex-1 px-3 py-2 border-2 border-indigo-300 rounded-xl text-sm">
                        <option value="">-- Select tracer to load --</option>
                    </select>
                    <button id="cloud-load-other" class="px-4 py-2 rounded-xl font-bold text-sm bg-cyan-500 text-white shadow">Load</button>
                </div>
            </div>
            
            <div class="border-t border-indigo-200 pt-4 mt-4">
                <div class="flex items-center gap-3">
                    <button id="auto-cloud-toggle" class="px-4 py-2 rounded-xl font-bold text-sm bg-amber-500 text-white shadow">‚ö° Auto-Save: OFF</button>
                    <span class="text-xs text-gray-500">Auto-saves to cloud after each shape</span>
                </div>
            </div>
            
            <p id="cloud-status" class="text-xs text-gray-500 mt-3"></p>
        </div>
        
        <!-- Google -->
        <div class="bg-emerald-50 p-6 rounded-xl shadow-lg mb-6 border-2 border-emerald-200">
            <h3 class="font-bold text-emerald-800 mb-3">Google Sheets</h3>
            <div class="flex gap-2 mb-2">
                <input id="sheets-url" placeholder="Apps Script URL..." class="flex-1 px-3 py-2 border-2 border-emerald-300 rounded-xl text-sm">
                <button id="exp-sheets" class="px-4 py-2 rounded-xl font-bold text-sm bg-emerald-500 text-white">Export</button>
            </div>
            <button id="imp-sheets" class="px-4 py-2 rounded-xl font-bold text-sm bg-cyan-500 text-white">Import</button>
        </div>
        
        <div class="bg-blue-50 p-6 rounded-xl shadow-lg mb-6 border-2 border-blue-200">
            <h3 class="font-bold text-blue-800 mb-3">Google Drive</h3>
            <div class="flex gap-2">
                <input id="drive-url" placeholder="Apps Script URL..." class="flex-1 px-3 py-2 border-2 border-blue-300 rounded-xl text-sm">
                <button id="exp-drive" class="px-4 py-2 rounded-xl font-bold text-sm bg-blue-500 text-white">Export</button>
            </div>
        </div>
        
        <!-- Gallery -->
        <div class="bg-white p-6 rounded-xl shadow-lg">
            <h3 class="font-bold text-gray-800 mb-4">Average Shapes Gallery</h3>
            <div id="gallery" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"><div class="border-2 border-dashed border-gray-200 rounded-xl p-8 text-center text-gray-400">No averages yet</div></div>
        </div>
    </div>
    
    <!-- Modal -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between mb-4"><h2 class="font-bold text-xl">Bulk Generate</h2><button id="close-modal" class="p-2 hover:bg-gray-100 rounded">‚úï</button></div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div><h4 class="font-semibold mb-2">Participants <button id="sel-all-p" class="text-xs text-blue-600 ml-2">All</button></h4><div id="mod-p" class="checkbox-grid"></div></div>
                <div><h4 class="font-semibold mb-2">Trials <button id="sel-all-t" class="text-xs text-blue-600 ml-2">All</button></h4><div id="mod-t" class="checkbox-grid"></div></div>
                <div><h4 class="font-semibold mb-2">Frequencies <button id="sel-all-f" class="text-xs text-blue-600 ml-2">All</button></h4><div id="mod-f" class="checkbox-grid"></div></div>
            </div>
            <div class="flex justify-end gap-2"><button id="cancel-modal" class="px-4 py-2 rounded-xl bg-gray-200 font-bold">Cancel</button><button id="do-bulk" class="px-4 py-2 rounded-xl bg-emerald-500 text-white font-bold">Generate</button></div>
        </div>
    </div>

<script>
// ============================================
// CONSTANTS - MATCHING ORIGINAL APP EXACTLY
// ============================================
const CANVAS_SIZE = 1000;
const UNIT_RANGE = 10;
const SCALE_FACTOR = CANVAS_SIZE / (UNIT_RANGE * 2); // = 50
const CENTER = CANVAS_SIZE / 2; // = 500
const BACKGROUND_CIRCLE_RADIUS = 3; // units

const FREQUENCIES = [
    { hz: 62.5, db: 100 },
    { hz: 125, db: 90 },
    { hz: 250, db: 85 },
    { hz: 500, db: 80 },
    { hz: 1000, db: 80 },
    { hz: 2000, db: 80 }
];

const COLORS = { red: '#ef4444', blue: '#3b82f6' };

// ============================================
// STATE
// ============================================
let canvas, ctx;
let showGrid = true, drawingOn = true, isDrawing = false;
let selColor = 'red', brushSize = 5, resampleRate = 1000;
let IMAGE_OPACITY = 0.1;
let SHAPE_OPACITY = 0.3; // Opacity for background traced shapes (0-1)
let curPath = [];
let allData = {}, images = {}, trialMapping = {};
let curParticipant = null, curTrial = null, curFreq = null;
let undoStack = [], redoStack = [];

// ============================================
// COORDINATE TRANSFORMS - EXACT MATCH
// ============================================
function canvasToUnit(x, y) {
    return {
        x: (x - CENTER) / SCALE_FACTOR,
        y: (CENTER - y) / SCALE_FACTOR
    };
}

function unitToCanvas(x, y) {
    return {
        x: x * SCALE_FACTOR + CENTER,
        y: CENTER - y * SCALE_FACTOR
    };
}

// ============================================
// HELPERS
// ============================================
const fKey = f => `${f.hz}Hz_${f.db}dB`;
const dataKey = () => curParticipant && curTrial && curFreq ? `${curParticipant}|${curTrial}|${fKey(curFreq)}` : null;
const status = m => document.getElementById('status').textContent = m;
const log = m => { const el = document.getElementById('upload-log'); el.classList.remove('hidden'); el.innerHTML += m + '<br>'; el.scrollTop = el.scrollHeight; };

function ensureData(p, t, f) {
    if (!allData[p]) allData[p] = {};
    if (!allData[p][t]) allData[p][t] = {};
    if (!allData[p][t][f]) allData[p][t][f] = { red: [], blue: [], redAvg: null, blueAvg: null };
    return allData[p][t][f];
}

function curData() {
    return curParticipant && curTrial && curFreq ? ensureData(curParticipant, curTrial, fKey(curFreq)) : null;
}

// ============================================
// RESAMPLING
// ============================================
function resample(pts, n) {
    if (pts.length < 2) return pts;
    let len = 0;
    const segs = [];
    for (let i = 0; i < pts.length - 1; i++) {
        const d = Math.hypot(pts[i+1].x - pts[i].x, pts[i+1].y - pts[i].y);
        segs.push(d);
        len += d;
    }
    if (len === 0) return [pts[0]];
    const res = [{ ...pts[0] }];
    const iv = len / (n - 1);
    let cd = 0, si = 0;
    for (let i = 1; i < n - 1; i++) {
        const td = i * iv;
        while (si < segs.length && cd + segs[si] < td) cd += segs[si++];
        if (si >= segs.length) break;
        const pr = (td - cd) / segs[si];
        res.push({ x: pts[si].x + (pts[si+1].x - pts[si].x) * pr, y: pts[si].y + (pts[si+1].y - pts[si].y) * pr });
    }
    res.push({ ...pts[pts.length - 1] });
    return res;
}

// ============================================
// DRAWING - EXACT GRID MATCH
// ============================================
function drawGrid() {
    if (!showGrid) return;
    ctx.save();
    
    // Minor grid lines
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) {
        if (i === 0) continue;
        const c = unitToCanvas(i, i);
        ctx.beginPath(); ctx.moveTo(0, c.y); ctx.lineTo(CANVAS_SIZE, c.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(c.x, 0); ctx.lineTo(c.x, CANVAS_SIZE); ctx.stroke();
    }
    
    // Major axes
    ctx.strokeStyle = '#6b7280';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, CENTER); ctx.lineTo(CANVAS_SIZE, CENTER); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(CENTER, 0); ctx.lineTo(CENTER, CANVAS_SIZE); ctx.stroke();
    
    // Labels
    ctx.fillStyle = '#4b5563';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    for (let i = -UNIT_RANGE; i <= UNIT_RANGE; i += 2) {
        if (i === 0) continue;
        ctx.fillText(i.toString(), unitToCanvas(i, 0).x, CENTER + 20);
    }
    ctx.textAlign = 'left';
    for (let j = -UNIT_RANGE; j <= UNIT_RANGE; j += 2) {
        if (j === 0) continue;
        ctx.fillText(j.toString(), CENTER + 10, unitToCanvas(0, j).y);
    }
    
    ctx.restore();
}

function drawRefCircle() {
    ctx.save();
    ctx.beginPath();
    ctx.arc(CENTER, CENTER, BACKGROUND_CIRCLE_RADIUS * SCALE_FACTOR, 0, 2 * Math.PI);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
}

function drawShape(s, clr, op = 1, lw = null) {
    if (!s || s.length < 2) return;
    ctx.save();
    ctx.globalAlpha = op;
    ctx.strokeStyle = clr;
    ctx.lineWidth = lw || brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    const st = unitToCanvas(s[0].x, s[0].y);
    ctx.moveTo(st.x, st.y);
    for (let i = 1; i < s.length; i++) {
        const p = unitToCanvas(s[i].x, s[i].y);
        ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();
}

function drawAvgShape(s, clr) {
    if (!s || s.length < 2) return;
    ctx.save();
    ctx.strokeStyle = clr === COLORS.red ? '#991b1b' : '#1e3a8a';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    const st = unitToCanvas(s[0].x, s[0].y);
    ctx.moveTo(st.x, st.y);
    for (let i = 1; i < s.length; i++) {
        const p = unitToCanvas(s[i].x, s[i].y);
        ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
    ctx.restore();
}

function redraw() {
    ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    
    // Layer 1: Background image at configurable opacity
    const ik = curParticipant && curTrial && curFreq ? `${curParticipant}|${curTrial}|${fKey(curFreq)}` : null;
    if (ik && images[ik]) {
        ctx.save();
        ctx.globalAlpha = IMAGE_OPACITY;
        
        const img = images[ik];
        if (img.naturalWidth === CANVAS_SIZE && img.naturalHeight === CANVAS_SIZE) {
            ctx.drawImage(img, 0, 0);
        } else {
            const scale = Math.min(CANVAS_SIZE / img.naturalWidth, CANVAS_SIZE / img.naturalHeight);
            const scaledW = img.naturalWidth * scale;
            const scaledH = img.naturalHeight * scale;
            const offsetX = (CANVAS_SIZE - scaledW) / 2;
            const offsetY = (CANVAS_SIZE - scaledH) / 2;
            ctx.drawImage(img, offsetX, offsetY, scaledW, scaledH);
        }
        
        ctx.restore();
    }
    
    // Layer 2: Reference circle
    drawRefCircle();
    
    // Layer 3: Traced shapes with configurable opacity (in background)
    const d = curData();
    if (d) {
        // Traced shapes at configurable opacity
        d.red.forEach(s => drawShape(s, COLORS.red, SHAPE_OPACITY));
        d.blue.forEach(s => drawShape(s, COLORS.blue, SHAPE_OPACITY));
    }
    
    // Layer 4: Average shapes at full opacity on top
    if (d) {
        if (d.redAvg) drawAvgShape(d.redAvg, COLORS.red);
        if (d.blueAvg) drawAvgShape(d.blueAvg, COLORS.blue);
    }
    
    // Layer 5: Grid on top of everything
    drawGrid();
    updateInfo();
}

function updateInfo() {
    document.getElementById('info-p').textContent = curParticipant || '-';
    document.getElementById('info-t').textContent = curTrial || '-';
    document.getElementById('info-f').textContent = curFreq ? `${curFreq.hz} Hz` : '-';
    const d = curData();
    document.getElementById('info-r').textContent = d ? d.red.length : 0;
    document.getElementById('info-b').textContent = d ? d.blue.length : 0;
}

// ============================================
// DRAWING EVENTS
// ============================================
function getPoint(e) {
    const r = canvas.getBoundingClientRect();
    let cx, cy;
    if (e.touches?.length) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
    else if (e.changedTouches?.length) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
    else { cx = e.clientX; cy = e.clientY; }
    return { x: (cx - r.left) * (CANVAS_SIZE / r.width), y: (cy - r.top) * (CANVAS_SIZE / r.height) };
}

function startDraw(e) {
    if (!drawingOn || !curParticipant) return;
    isDrawing = true;
    const p = getPoint(e);
    curPath = [p];
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.strokeStyle = COLORS[selColor];
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    e.preventDefault();
}

function doDraw(e) {
    if (!isDrawing) return;
    const p = getPoint(e);
    curPath.push(p);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    e.preventDefault();
}

function endDraw() {
    if (!isDrawing) return;
    isDrawing = false;
    if (curPath.length > 5) {
        const d = curData();
        undoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) });
        redoStack = [];
        const up = curPath.map(p => canvasToUnit(p.x, p.y));
        const rs = resample(up, resampleRate);
        d[selColor].push(rs);
        redraw();
        updateTable();
        status(`Added ${selColor} (${rs.length} pts)`);
        
        // Trigger auto-save after each shape
        triggerAutoSave();
    }
    curPath = [];
    document.getElementById('undo-btn').disabled = !undoStack.length;
    document.getElementById('redo-btn').disabled = !redoStack.length;
}

function undo() {
    if (!undoStack.length) return;
    const st = undoStack.pop();
    const d = curData();
    if (st.key === dataKey()) {
        redoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) });
        Object.assign(d, st.data);
        redraw();
        updateTable();
    }
    document.getElementById('undo-btn').disabled = !undoStack.length;
    document.getElementById('redo-btn').disabled = !redoStack.length;
}

function redo() {
    if (!redoStack.length) return;
    const st = redoStack.pop();
    const d = curData();
    if (st.key === dataKey()) {
        undoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) });
        Object.assign(d, st.data);
        redraw();
        updateTable();
    }
    document.getElementById('undo-btn').disabled = !undoStack.length;
    document.getElementById('redo-btn').disabled = !redoStack.length;
}

// ============================================
// FILE PARSING - Filename format: "ParticipantName_FrequencyHz_LoudnessdB.png"
// ============================================
function parseParticipant(fn) {
    // Extract participant name: everything before _[number]Hz
    // Example: "Jiaxin L_62.5Hz_100dB.png" -> "Jiaxin L"
    const base = fn.replace(/\.png$/i, '');
    const m = base.match(/^(.+?)_\d+(?:\.\d+)?[Hh]z/i);
    return m ? m[1].trim() : fn.split('_')[0] || 'Unknown';
}

function parseFreq(fn) {
    // Extract frequency: number followed by Hz
    // Example: "Jiaxin L_62.5Hz_100dB.png" -> 62.5
    const m = fn.match(/(\d+(?:\.\d+)?)\s*[Hh]z/i);
    return m ? parseFloat(m[1]) : null;
}

// ============================================
// ZIP PROCESSING - NESTED SUPPORT
// Folder structure: "ParticipantName_FolderNumber_AnythingElse/filename.png"
// Example: "Jiaxin L_11_Drawings 2/Jiaxin L_62.5Hz_100dB.png"
// - Participant: "Jiaxin L"
// - Folder number: 11 (used to determine trial order)
// - Filename frequency: 62.5Hz
// Trial numbers are sorted (e.g., 3, 5, 11) and mapped to Trial 1, 2, 3
// ============================================
async function processZip(zipFile) {
    const zip = await JSZip.loadAsync(zipFile);
    const fileInfos = [];
    
    async function extractFromZip(z, pathPrefix = '') {
        const entries = Object.entries(z.files);
        log(`Scanning ${entries.length} entries in ZIP...`);
        
        for (const [path, file] of entries) {
            if (file.dir) continue;
            const fullPath = pathPrefix + path;
            
            if (path.toLowerCase().endsWith('.png')) {
                const filename = path.split('/').pop();
                const pathParts = fullPath.split('/').filter(p => p.length > 0);
                
                log(`Processing: ${fullPath}`);
                
                // Find the participant folder with format "Name_Number_..." 
                let folderNum = null;
                let partPath = null;
                
                // Look through path parts for folder matching "ParticipantName_Number_..."
                // Example: "Jiaxin L_11_Drawings 2"
                for (let i = 0; i < pathParts.length - 1; i++) {
                    const part = pathParts[i];
                    
                    // Pattern: "Name_Number" or "Name_Number_AnythingElse"
                    // Captures: participant name, folder number
                    const match = part.match(/^(.+?)_(\d+)(?:_.*)?$/);
                    if (match) {
                        partPath = match[1].trim();
                        folderNum = parseInt(match[2]);
                        log(`  Matched folder pattern: "${part}" ‚Üí participant="${partPath}", folderNum=${folderNum}`);
                        break;
                    }
                    
                    // Also check for purely numeric folders (backup)
                    if (/^\d+$/.test(part)) {
                        folderNum = parseInt(part);
                        // Look for participant in previous folder
                        if (i > 0) {
                            partPath = pathParts[i - 1];
                        }
                        log(`  Found numeric folder: ${part} ‚Üí folderNum=${folderNum}, participant=${partPath}`);
                        break;
                    }
                }
                
                // If still no participant, get from filename
                const participant = partPath || parseParticipant(filename);
                
                fileInfos.push({
                    filename,
                    file,
                    folderNum,
                    participant,
                    fullPath
                });
                
                log(`  Result: participant="${participant}", folderNum=${folderNum}, freq=${parseFreq(filename)}Hz`);
                
            } else if (path.toLowerCase().endsWith('.zip')) {
                // Handle nested ZIP files
                try {
                    log(`Found nested ZIP: ${path}`);
                    const blob = await file.async('blob');
                    const nested = await JSZip.loadAsync(blob);
                    await extractFromZip(nested, fullPath.replace(/\.zip$/i, '/'));
                } catch (e) {
                    console.warn('Nested ZIP error:', path, e);
                    log(`Warning: Could not process nested ZIP: ${path}`);
                }
            }
        }
    }
    
    await extractFromZip(zip);
    return fileInfos;
}

async function handleZip(file) {
    document.getElementById('upload-log').innerHTML = '';
    document.getElementById('upload-log').classList.remove('hidden');
    log('=== Processing ZIP file ===');
    log(`Filename: ${file.name}`);
    status('Loading ZIP...');
    
    try {
        const infos = await processZip(file);
        log(`=== Found ${infos.length} PNG files total ===`);
        
        if (!infos.length) {
            status('No PNG files found in ZIP');
            return;
        }
        
        // Build participant -> folder numbers mapping
        const partFolders = {};
        for (const i of infos) {
            const p = i.participant;
            if (!partFolders[p]) partFolders[p] = new Set();
            if (i.folderNum !== null) {
                partFolders[p].add(i.folderNum);
            }
        }
        
        // Log what we found
        log('=== Participants and their folder numbers ===');
        for (const [p, folders] of Object.entries(partFolders)) {
            log(`  ${p}: folders = [${Array.from(folders).sort((a,b)=>a-b).join(', ')}]`);
        }
        
        // Map folder numbers to trial 1, 2, 3 (sorted lowest to highest)
        trialMapping = {};
        log('=== Trial Mapping ===');
        for (const [p, folders] of Object.entries(partFolders)) {
            const sorted = Array.from(folders).sort((a, b) => a - b);
            trialMapping[p.toLowerCase()] = {};
            sorted.forEach((fn, idx) => {
                trialMapping[p.toLowerCase()][fn] = idx + 1;
            });
            if (sorted.length > 0) {
                log(`  ${p}: folders [${sorted.join(', ')}] ‚Üí Trial [${sorted.map((_, i) => i + 1).join(', ')}]`);
            } else {
                log(`  ${p}: No folder numbers found - defaulting to Trial 1`);
            }
        }
        
        // Load images and build data structure
        const participants = new Map();
        let loadedCount = 0;
        let skippedCount = 0;
        
        log('=== Loading Images ===');
        for (const info of infos) {
            const hz = parseFreq(info.filename);
            const freq = FREQUENCIES.find(f => f.hz === hz);
            
            // Only process frequencies 62.5 to 2000 Hz
            if (!freq) {
                skippedCount++;
                continue;
            }
            
            const p = info.participant;
            
            // Get trial number from mapping
            let trialNum = 1;
            if (info.folderNum !== null && trialMapping[p.toLowerCase()] && trialMapping[p.toLowerCase()][info.folderNum]) {
                trialNum = trialMapping[p.toLowerCase()][info.folderNum];
            }
            const t = `Trial ${trialNum}`;
            
            // Load image
            const blob = await info.file.async('blob');
            const img = await loadImg(URL.createObjectURL(blob));
            
            const ik = `${p}|${t}|${fKey(freq)}`;
            images[ik] = img;
            
            // Build tab structure
            if (!participants.has(p)) participants.set(p, new Map());
            if (!participants.get(p).has(t)) participants.get(p).set(t, new Set());
            participants.get(p).get(t).add(freq.hz);
            
            ensureData(p, t, fKey(freq));
            loadedCount++;
        }
        
        if (!participants.size) {
            status('No valid images found (need 62.5-2000 Hz frequencies)');
            log(`Skipped ${skippedCount} files (outside 62.5-2000 Hz range)`);
            return;
        }
        
        // Log final structure
        log('=== Final Tab Structure ===');
        for (const [p, trials] of participants) {
            const trialList = Array.from(trials.keys()).sort();
            log(`  ${p}: ${trialList.length} trials - [${trialList.join(', ')}]`);
            for (const [t, freqs] of trials) {
                log(`    ${t}: ${freqs.size} frequencies - [${Array.from(freqs).sort((a,b)=>a-b).join(', ')}]`);
            }
        }
        
        log(`=== Summary: ${loadedCount} loaded, ${skippedCount} skipped ===`);
        
        buildTabs(participants);
        status(`Loaded ${loadedCount} images from ${participants.size} participants`);
        
    } catch (e) {
        console.error(e);
        status('Error: ' + e.message);
        log('ERROR: ' + e.message);
        log(e.stack);
    }
}

function loadImg(src) {
    return new Promise((res, rej) => {
        const img = new Image();
        img.onload = () => res(img);
        img.onerror = rej;
        img.src = src;
    });
}

async function handleSingle(file) {
    try {
        const img = await loadImg(URL.createObjectURL(file));
        const p = parseParticipant(file.name) || 'Participant';
        const t = 'Trial 1';
        const hz = parseFreq(file.name);
        const freq = hz ? FREQUENCIES.find(f => f.hz === hz) : FREQUENCIES[0];
        
        const ik = `${p}|${t}|${fKey(freq || FREQUENCIES[0])}`;
        images[ik] = img;
        ensureData(p, t, fKey(freq || FREQUENCIES[0]));
        
        const parts = new Map([[p, new Map([[t, new Set([freq?.hz || 62.5])]])]]);
        buildTabs(parts);
        status(`Loaded: ${file.name}`);
    } catch (e) {
        status('Error: ' + e.message);
    }
}

function handleJson(file) {
    const r = new FileReader();
    r.onload = e => {
        try {
            const d = JSON.parse(e.target.result);
            if (d.allData) allData = d.allData;
            if (d.settings) {
                if (d.settings.resampleRate) {
                    resampleRate = d.settings.resampleRate;
                    document.getElementById('resample-slider').value = resampleRate;
                    document.getElementById('resample-val').textContent = resampleRate;
                }
                if (d.settings.imageOpacity !== undefined) {
                    IMAGE_OPACITY = d.settings.imageOpacity / 100;
                    document.getElementById('img-opacity-slider').value = d.settings.imageOpacity;
                    document.getElementById('img-opacity-val').textContent = d.settings.imageOpacity + '%';
                }
                if (d.settings.shapeOpacity !== undefined) {
                    SHAPE_OPACITY = d.settings.shapeOpacity / 100;
                    document.getElementById('shape-opacity-slider').value = d.settings.shapeOpacity;
                    document.getElementById('shape-opacity-val').textContent = d.settings.shapeOpacity + '%';
                }
                if (d.settings.brushSize) {
                    brushSize = d.settings.brushSize;
                    document.getElementById('brush-slider').value = brushSize;
                    document.getElementById('brush-val').textContent = brushSize;
                }
            }
            
            const parts = new Map();
            for (const p of Object.keys(allData)) {
                parts.set(p, new Map());
                for (const t of Object.keys(allData[p])) {
                    parts.get(p).set(t, new Set());
                    for (const fk of Object.keys(allData[p][t])) {
                        const hz = parseFloat(fk);
                        if (!isNaN(hz)) parts.get(p).get(t).add(hz);
                    }
                }
            }
            
            if (parts.size) {
                buildTabs(parts);
                updateGallery();
                status('JSON imported');
            }
        } catch (e) {
            status('Error: ' + e.message);
        }
    };
    r.readAsText(file);
}

// ============================================
// TAB BUILDING
// ============================================
function buildTabs(participants) {
    const pSec = document.getElementById('participant-section');
    const tSec = document.getElementById('trial-section');
    const fSec = document.getElementById('frequency-section');
    const pTabs = document.getElementById('participant-tabs');
    const tTabs = document.getElementById('trial-tabs');
    const fTabs = document.getElementById('frequency-tabs');
    
    pTabs.innerHTML = '';
    tTabs.innerHTML = '';
    fTabs.innerHTML = '';
    
    pSec.classList.remove('hidden');
    tSec.classList.remove('hidden');
    fSec.classList.remove('hidden');
    
    const sortedP = Array.from(participants.keys()).sort();
    let first = true;
    
    for (const p of sortedP) {
        const btn = document.createElement('button');
        btn.className = `tab-btn px-4 py-2 rounded-xl font-bold text-sm bg-gray-100 shadow${first ? ' active' : ''}`;
        btn.textContent = p;
        btn.onclick = () => selectParticipant(p, participants, btn);
        pTabs.appendChild(btn);
        
        if (first) {
            curParticipant = p;
            buildTrialTabs(p, participants.get(p));
            first = false;
        }
    }
}

function buildTrialTabs(p, trials) {
    const tTabs = document.getElementById('trial-tabs');
    tTabs.innerHTML = '';
    
    const sorted = Array.from(trials.keys()).sort((a, b) => {
        const na = parseInt(a.replace(/\D/g, '')) || 0;
        const nb = parseInt(b.replace(/\D/g, '')) || 0;
        return na - nb;
    });
    
    let first = true;
    for (const t of sorted) {
        const btn = document.createElement('button');
        btn.className = `trial-btn tab-btn px-4 py-2 rounded-xl font-bold text-sm bg-gray-100 shadow${first ? ' active' : ''}`;
        btn.textContent = t;
        btn.onclick = () => selectTrial(t, trials.get(t), btn);
        tTabs.appendChild(btn);
        
        if (first) {
            curTrial = t;
            buildFreqTabs(trials.get(t));
            first = false;
        }
    }
}

function buildFreqTabs(freqs) {
    const fTabs = document.getElementById('frequency-tabs');
    fTabs.innerHTML = '';
    
    let first = true;
    for (const f of FREQUENCIES) {
        const btn = document.createElement('button');
        const hasData = freqs && freqs.has(f.hz);
        btn.className = `freq-btn tab-btn px-4 py-2 rounded-xl font-bold text-sm shadow ${hasData ? 'bg-gray-100' : 'bg-gray-50 text-gray-400'}${first && hasData ? ' active' : ''}`;
        btn.textContent = `${f.hz} Hz`;
        btn.disabled = !hasData;
        btn.onclick = () => selectFreq(f, btn);
        fTabs.appendChild(btn);
        
        if (first && hasData) {
            curFreq = f;
            first = false;
        }
    }
    
    redraw();
}

function selectParticipant(p, participants, btn) {
    curParticipant = p;
    document.querySelectorAll('#participant-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    buildTrialTabs(p, participants.get(p));
    undoStack = []; redoStack = [];
    document.getElementById('undo-btn').disabled = true;
    document.getElementById('redo-btn').disabled = true;
}

function selectTrial(t, freqs, btn) {
    curTrial = t;
    document.querySelectorAll('#trial-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    buildFreqTabs(freqs);
    undoStack = []; redoStack = [];
    document.getElementById('undo-btn').disabled = true;
    document.getElementById('redo-btn').disabled = true;
}

function selectFreq(f, btn) {
    curFreq = f;
    document.querySelectorAll('#frequency-tabs .tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    undoStack = []; redoStack = [];
    document.getElementById('undo-btn').disabled = true;
    document.getElementById('redo-btn').disabled = true;
    redraw();
    updateTable();
}

// ============================================
// AVERAGE SHAPES
// ============================================
function calcAvg(shapes) {
    if (!shapes?.length) return null;
    if (shapes.length === 1) return [...shapes[0]];
    const maxLen = Math.max(...shapes.map(s => s.length));
    const norm = shapes.map(s => resample(s, maxLen));
    const avg = [];
    for (let i = 0; i < maxLen; i++) {
        let sx = 0, sy = 0, c = 0;
        for (const s of norm) {
            if (i < s.length) { sx += s[i].x; sy += s[i].y; c++; }
        }
        if (c) avg.push({ x: sx / c, y: sy / c });
    }
    return avg;
}

function genAvgCur() {
    const d = curData();
    if (!d) return status('No data');
    let gen = false;
    if (d.red.length) { d.redAvg = calcAvg(d.red); gen = true; }
    if (d.blue.length) { d.blueAvg = calcAvg(d.blue); gen = true; }
    if (gen) { redraw(); updateGallery(); status('Generated'); }
    else status('No shapes');
}

function clearAvgCur() {
    const d = curData();
    if (d) { d.redAvg = null; d.blueAvg = null; redraw(); updateGallery(); status('Cleared'); }
}

function openModal() {
    document.getElementById('modal').classList.add('active');
    const mp = document.getElementById('mod-p');
    const mt = document.getElementById('mod-t');
    const mf = document.getElementById('mod-f');
    mp.innerHTML = ''; mt.innerHTML = ''; mf.innerHTML = '';
    
    const ps = new Set(), ts = new Set();
    for (const p of Object.keys(allData)) {
        ps.add(p);
        for (const t of Object.keys(allData[p])) ts.add(t);
    }
    
    Array.from(ps).sort().forEach(p => {
        mp.innerHTML += `<label class="checkbox-item"><input type="checkbox" value="${p}" checked><span>${p}</span></label>`;
    });
    Array.from(ts).sort((a, b) => (parseInt(a.replace(/\D/g, '')) || 0) - (parseInt(b.replace(/\D/g, '')) || 0)).forEach(t => {
        mt.innerHTML += `<label class="checkbox-item"><input type="checkbox" value="${t}" checked><span>${t}</span></label>`;
    });
    FREQUENCIES.forEach(f => {
        mf.innerHTML += `<label class="checkbox-item"><input type="checkbox" value="${f.hz}" checked><span>${f.hz} Hz</span></label>`;
    });
}

function doBulk() {
    const selP = [...document.querySelectorAll('#mod-p input:checked')].map(c => c.value);
    const selT = [...document.querySelectorAll('#mod-t input:checked')].map(c => c.value);
    const selF = [...document.querySelectorAll('#mod-f input:checked')].map(c => parseFloat(c.value));
    let cnt = 0;
    for (const p of selP) {
        if (!allData[p]) continue;
        for (const t of selT) {
            if (!allData[p][t]) continue;
            for (const hz of selF) {
                const f = FREQUENCIES.find(x => x.hz === hz);
                if (!f) continue;
                const d = allData[p][t][fKey(f)];
                if (!d) continue;
                if (d.red.length) { d.redAvg = calcAvg(d.red); cnt++; }
                if (d.blue.length) { d.blueAvg = calcAvg(d.blue); cnt++; }
            }
        }
    }
    document.getElementById('modal').classList.remove('active');
    redraw();
    updateGallery();
    status(`Generated ${cnt} averages`);
}

// ============================================
// CROSS-PARTICIPANT FREQUENCY AVERAGING
// ============================================

// Store frequency averages: { hz: { redAvg: [...], blueAvg: [...], redShapes: [...], blueShapes: [...] } }
let frequencyAverages = {};

/**
 * Generate average shapes across ALL participants for each frequency
 * Collects all red shapes and all blue shapes for each frequency,
 * then computes a single average for each color per frequency
 */
function generateFrequencyAverages() {
    const statusEl = document.getElementById('freq-avg-status');
    statusEl.textContent = 'Generating frequency averages...';
    
    frequencyAverages = {};
    let totalRed = 0, totalBlue = 0;
    
    // Collect all shapes by frequency
    for (const freq of FREQUENCIES) {
        const fk = fKey(freq);
        const hzKey = freq.hz;
        
        frequencyAverages[hzKey] = {
            redShapes: [],
            blueShapes: [],
            redAvg: null,
            blueAvg: null
        };
        
        // Iterate through all participants and trials
        for (const p of Object.keys(allData)) {
            for (const t of Object.keys(allData[p])) {
                // Find matching frequency key
                for (const dataFk of Object.keys(allData[p][t])) {
                    // Match by frequency value (ignore dB)
                    const dataHz = parseFloat(dataFk);
                    if (Math.abs(dataHz - freq.hz) < 0.1) {
                        const d = allData[p][t][dataFk];
                        if (d.red) {
                            d.red.forEach(shape => {
                                if (shape && shape.length > 2) {
                                    frequencyAverages[hzKey].redShapes.push(shape);
                                    totalRed++;
                                }
                            });
                        }
                        if (d.blue) {
                            d.blue.forEach(shape => {
                                if (shape && shape.length > 2) {
                                    frequencyAverages[hzKey].blueShapes.push(shape);
                                    totalBlue++;
                                }
                            });
                        }
                    }
                }
            }
        }
        
        // Calculate averages for this frequency
        if (frequencyAverages[hzKey].redShapes.length > 0) {
            frequencyAverages[hzKey].redAvg = calcAvg(frequencyAverages[hzKey].redShapes);
        }
        if (frequencyAverages[hzKey].blueShapes.length > 0) {
            frequencyAverages[hzKey].blueAvg = calcAvg(frequencyAverages[hzKey].blueShapes);
        }
    }
    
    // Count frequencies with averages
    let freqsWithData = 0;
    for (const hz of Object.keys(frequencyAverages)) {
        if (frequencyAverages[hz].redAvg || frequencyAverages[hz].blueAvg) {
            freqsWithData++;
        }
    }
    
    statusEl.textContent = `Generated averages for ${freqsWithData} frequencies (${totalRed} red shapes, ${totalBlue} blue shapes)`;
    status(`Frequency averages generated: ${freqsWithData} frequencies`);
}

/**
 * Export frequency averages as PNG images
 * Creates one image per frequency with:
 * - Individual traced shapes at configurable opacity (background)
 * - Average shapes at full opacity (foreground)
 * - Grid on top
 */
function exportFrequencyPNGs() {
    const statusEl = document.getElementById('freq-avg-status');
    
    // Check if averages have been generated
    const hasData = Object.keys(frequencyAverages).some(hz => 
        frequencyAverages[hz].redAvg || frequencyAverages[hz].blueAvg
    );
    
    if (!hasData) {
        statusEl.textContent = 'Please generate frequency averages first';
        return;
    }
    
    statusEl.textContent = 'Creating PNG images...';
    
    const promises = [];
    
    for (const freq of FREQUENCIES) {
        const hzKey = freq.hz;
        const data = frequencyAverages[hzKey];
        
        if (!data || (!data.redAvg && !data.blueAvg)) continue;
        
        // Create canvas for this frequency
        const tc = document.createElement('canvas');
        tc.width = tc.height = CANVAS_SIZE;
        const cx = tc.getContext('2d');
        
        // White background
        cx.fillStyle = 'white';
        cx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        
        // Layer 1: Reference circle
        cx.save();
        cx.strokeStyle = '#e5e7eb';
        cx.lineWidth = 2;
        cx.beginPath();
        cx.arc(CENTER, CENTER, BACKGROUND_CIRCLE_RADIUS * SCALE_FACTOR, 0, Math.PI * 2);
        cx.stroke();
        cx.restore();
        
        // Layer 2: Individual traced shapes at SHAPE_OPACITY
        if (data.redShapes) {
            data.redShapes.forEach(shape => {
                if (shape && shape.length >= 2) {
                    cx.save();
                    cx.globalAlpha = SHAPE_OPACITY;
                    cx.strokeStyle = COLORS.red;
                    cx.lineWidth = brushSize;
                    cx.lineCap = 'round';
                    cx.lineJoin = 'round';
                    cx.beginPath();
                    const st = unitToCanvas(shape[0].x, shape[0].y);
                    cx.moveTo(st.x, st.y);
                    for (let i = 1; i < shape.length; i++) {
                        const pt = unitToCanvas(shape[i].x, shape[i].y);
                        cx.lineTo(pt.x, pt.y);
                    }
                    cx.stroke();
                    cx.restore();
                }
            });
        }
        
        if (data.blueShapes) {
            data.blueShapes.forEach(shape => {
                if (shape && shape.length >= 2) {
                    cx.save();
                    cx.globalAlpha = SHAPE_OPACITY;
                    cx.strokeStyle = COLORS.blue;
                    cx.lineWidth = brushSize;
                    cx.lineCap = 'round';
                    cx.lineJoin = 'round';
                    cx.beginPath();
                    const st = unitToCanvas(shape[0].x, shape[0].y);
                    cx.moveTo(st.x, st.y);
                    for (let i = 1; i < shape.length; i++) {
                        const pt = unitToCanvas(shape[i].x, shape[i].y);
                        cx.lineTo(pt.x, pt.y);
                    }
                    cx.stroke();
                    cx.restore();
                }
            });
        }
        
        // Layer 3: Average shapes at full opacity
        if (data.redAvg && data.redAvg.length >= 2) {
            cx.strokeStyle = '#991b1b'; // Dark red
            cx.lineWidth = 4;
            cx.lineCap = 'round';
            cx.lineJoin = 'round';
            cx.beginPath();
            const st = unitToCanvas(data.redAvg[0].x, data.redAvg[0].y);
            cx.moveTo(st.x, st.y);
            for (let i = 1; i < data.redAvg.length; i++) {
                const pt = unitToCanvas(data.redAvg[i].x, data.redAvg[i].y);
                cx.lineTo(pt.x, pt.y);
            }
            cx.stroke();
        }
        
        if (data.blueAvg && data.blueAvg.length >= 2) {
            cx.strokeStyle = '#1e3a8a'; // Dark blue
            cx.lineWidth = 4;
            cx.lineCap = 'round';
            cx.lineJoin = 'round';
            cx.beginPath();
            const st = unitToCanvas(data.blueAvg[0].x, data.blueAvg[0].y);
            cx.moveTo(st.x, st.y);
            for (let i = 1; i < data.blueAvg.length; i++) {
                const pt = unitToCanvas(data.blueAvg[i].x, data.blueAvg[i].y);
                cx.lineTo(pt.x, pt.y);
            }
            cx.stroke();
        }
        
        // Layer 4: Grid on top
        cx.strokeStyle = '#e5e7eb';
        cx.lineWidth = 1;
        for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) {
            if (i === 0) continue;
            const c = unitToCanvas(i, i);
            cx.beginPath(); cx.moveTo(0, c.y); cx.lineTo(CANVAS_SIZE, c.y); cx.stroke();
            cx.beginPath(); cx.moveTo(c.x, 0); cx.lineTo(c.x, CANVAS_SIZE); cx.stroke();
        }
        cx.strokeStyle = '#6b7280';
        cx.lineWidth = 2;
        cx.beginPath(); cx.moveTo(0, CENTER); cx.lineTo(CANVAS_SIZE, CENTER); cx.stroke();
        cx.beginPath(); cx.moveTo(CENTER, 0); cx.lineTo(CENTER, CANVAS_SIZE); cx.stroke();
        
        // Title
        cx.fillStyle = '#1f2937';
        cx.font = 'bold 24px sans-serif';
        cx.textAlign = 'center';
        cx.fillText(`${hzKey} Hz - All Participants Average`, CENTER, 40);
        
        // Stats
        cx.font = '14px sans-serif';
        cx.fillStyle = '#6b7280';
        const redCount = data.redShapes ? data.redShapes.length : 0;
        const blueCount = data.blueShapes ? data.blueShapes.length : 0;
        cx.fillText(`Red: ${redCount} shapes | Blue: ${blueCount} shapes`, CENTER, CANVAS_SIZE - 20);
        
        // Save as PNG
        tc.toBlob(blob => {
            saveAs(blob, `frequency_avg_${hzKey}Hz.png`);
        });
    }
    
    statusEl.textContent = 'PNG images exported!';
    status('Frequency PNG images exported');
}

function updateGallery() {
    const g = document.getElementById('gallery');
    g.innerHTML = '';
    let has = false;
    for (const p of Object.keys(allData).sort()) {
        for (const t of Object.keys(allData[p]).sort()) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                if (d.redAvg || d.blueAvg) {
                    has = true;
                    const card = document.createElement('div');
                    card.className = 'bg-gray-50 rounded-xl p-3 border';
                    const cv = document.createElement('canvas');
                    cv.width = 200; cv.height = 200;
                    cv.className = 'w-full rounded-lg border bg-white mb-2';
                    const cx = cv.getContext('2d');
                    cx.fillStyle = 'white'; cx.fillRect(0, 0, 200, 200);
                    const sc = 200 / CANVAS_SIZE;
                    // Traced shapes at SHAPE_OPACITY (background)
                    d.red.forEach(s => drawPreview(cx, s, COLORS.red, sc, SHAPE_OPACITY));
                    d.blue.forEach(s => drawPreview(cx, s, COLORS.blue, sc, SHAPE_OPACITY));
                    // Average shapes with darker colors at full opacity (foreground)
                    if (d.redAvg) drawPreview(cx, d.redAvg, '#991b1b', sc, 1, 3);
                    if (d.blueAvg) drawPreview(cx, d.blueAvg, '#1e3a8a', sc, 1, 3);
                    // Grid on top
                    drawMiniGrid(cx, 200);
                    card.appendChild(cv);
                    card.innerHTML += `<p class="text-xs font-semibold">${p} - ${t}</p><p class="text-xs text-gray-500">${fk}</p>`;
                    g.appendChild(card);
                }
            }
        }
    }
    if (!has) g.innerHTML = '<div class="border-2 border-dashed border-gray-200 rounded-xl p-8 text-center text-gray-400">No averages yet</div>';
}

function drawPreview(cx, s, clr, sc, op, lw = 2) {
    if (!s || s.length < 2) return;
    cx.save(); cx.globalAlpha = op; cx.strokeStyle = clr; cx.lineWidth = lw;
    cx.lineCap = 'round'; cx.lineJoin = 'round'; cx.beginPath();
    const st = unitToCanvas(s[0].x, s[0].y);
    cx.moveTo(st.x * sc, st.y * sc);
    for (let i = 1; i < s.length; i++) {
        const p = unitToCanvas(s[i].x, s[i].y);
        cx.lineTo(p.x * sc, p.y * sc);
    }
    cx.stroke(); cx.restore();
}

function drawMiniGrid(cx, sz) {
    const c = sz / 2;
    cx.strokeStyle = '#e5e7eb'; cx.lineWidth = 0.5;
    for (let i = 0; i <= sz; i += sz / 20) {
        cx.beginPath(); cx.moveTo(i, 0); cx.lineTo(i, sz); cx.stroke();
        cx.beginPath(); cx.moveTo(0, i); cx.lineTo(sz, i); cx.stroke();
    }
    cx.strokeStyle = '#6b7280'; cx.lineWidth = 1;
    cx.beginPath(); cx.moveTo(0, c); cx.lineTo(sz, c); cx.stroke();
    cx.beginPath(); cx.moveTo(c, 0); cx.lineTo(c, sz); cx.stroke();
}

// ============================================
// DATA TABLE
// ============================================
function updateTable() {
    const tb = document.getElementById('data-body');
    tb.innerHTML = '';
    let has = false;
    for (const p of Object.keys(allData).sort()) {
        for (const t of Object.keys(allData[p]).sort()) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                d.red.forEach((s, i) => {
                    has = true;
                    const sm = s.slice(0, 2).map(pt => `(${pt.x.toFixed(1)},${pt.y.toFixed(1)})`).join(' ');
                    tb.innerHTML += `<tr><td>${p}</td><td>${t}</td><td>${fk}</td><td class="text-red-500">‚óè</td><td>${i + 1}</td><td>${s.length}</td><td>${sm}...</td></tr>`;
                });
                d.blue.forEach((s, i) => {
                    has = true;
                    const sm = s.slice(0, 2).map(pt => `(${pt.x.toFixed(1)},${pt.y.toFixed(1)})`).join(' ');
                    tb.innerHTML += `<tr><td>${p}</td><td>${t}</td><td>${fk}</td><td class="text-blue-500">‚óè</td><td>${i + 1}</td><td>${s.length}</td><td>${sm}...</td></tr>`;
                });
            }
        }
    }
    if (!has) tb.innerHTML = '<tr><td colspan="7" class="text-center text-gray-400 py-8">No data</td></tr>';
}

// ============================================
// EXPORTS
// ============================================
function expCSV() {
    let csv = 'Participant,Trial,Frequency,Color,Shape,Point,X,Y,IsAvg\n';
    for (const p of Object.keys(allData)) {
        for (const t of Object.keys(allData[p])) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                d.red.forEach((s, si) => s.forEach((pt, pi) => { csv += `${p},${t},${fk},Red,${si + 1},${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},false\n`; }));
                d.blue.forEach((s, si) => s.forEach((pt, pi) => { csv += `${p},${t},${fk},Blue,${si + 1},${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},false\n`; }));
                if (d.redAvg) d.redAvg.forEach((pt, pi) => { csv += `${p},${t},${fk},Red,Avg,${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},true\n`; });
                if (d.blueAvg) d.blueAvg.forEach((pt, pi) => { csv += `${p},${t},${fk},Blue,Avg,${pi + 1},${pt.x.toFixed(6)},${pt.y.toFixed(6)},true\n`; });
            }
        }
    }
    saveAs(new Blob([csv], { type: 'text/csv' }), `contour_${new Date().toISOString().slice(0, 10)}.csv`);
    status('CSV exported');
}

function expJSON() {
    const ex = { exportDate: new Date().toISOString(), version: '4.0', settings: { resampleRate, imageOpacity: Math.round(IMAGE_OPACITY * 100), shapeOpacity: Math.round(SHAPE_OPACITY * 100), brushSize }, allData };
    saveAs(new Blob([JSON.stringify(ex, null, 2)], { type: 'application/json' }), `contour_${new Date().toISOString().slice(0, 10)}.json`);
    status('JSON exported');
}

async function expSheets() {
    const url = document.getElementById('sheets-url').value.trim();
    if (!url) return status('Enter URL');
    localStorage.setItem('sheetsUrl', url);
    try {
        status('Exporting...');
        await fetch(url, { method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'text/plain' }, body: JSON.stringify({ action: 'export', allData, settings: { resampleRate, imageOpacity: Math.round(IMAGE_OPACITY * 100), shapeOpacity: Math.round(SHAPE_OPACITY * 100), brushSize } }) });
        status('Sent to Sheets');
    } catch (e) { status('Error: ' + e.message); }
}

async function impSheets() {
    const url = document.getElementById('sheets-url').value.trim();
    if (!url) return status('Enter URL');
    try {
        status('Importing...');
        const res = await fetch(url + '?action=import');
        const d = await res.json();
        if (d.allData) {
            allData = d.allData;
            const parts = new Map();
            for (const p of Object.keys(allData)) {
                parts.set(p, new Map());
                for (const t of Object.keys(allData[p])) {
                    parts.get(p).set(t, new Set());
                    for (const fk of Object.keys(allData[p][t])) {
                        const hz = parseFloat(fk);
                        if (!isNaN(hz)) parts.get(p).get(t).add(hz);
                    }
                }
            }
            buildTabs(parts);
            updateGallery();
            status('Imported');
        }
    } catch (e) { status('Error: ' + e.message); }
}

async function expDrive() {
    const url = document.getElementById('drive-url').value.trim();
    if (!url) return status('Enter URL');
    localStorage.setItem('driveUrl', url);
    const imgs = [];
    for (const p of Object.keys(allData)) {
        for (const t of Object.keys(allData[p])) {
            for (const fk of Object.keys(allData[p][t])) {
                const d = allData[p][t][fk];
                if (d.redAvg || d.blueAvg) {
                    imgs.push({ filename: `${p}_${t}_${fk}_avg.png`, data: genImg(p, t, fk, d).split(',')[1] });
                }
            }
        }
    }
    if (!imgs.length) return status('No averages');
    try {
        status('Uploading...');
        await fetch(url, { method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ images: imgs }) });
        status(`${imgs.length} images sent`);
    } catch (e) { status('Error: ' + e.message); }
}

function genImg(p, t, fk, d) {
    const tc = document.createElement('canvas');
    tc.width = tc.height = CANVAS_SIZE;
    const cx = tc.getContext('2d');
    cx.fillStyle = 'white'; cx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
    
    // Layer 1: Reference circle
    cx.save();
    cx.strokeStyle = '#e5e7eb';
    cx.lineWidth = 2;
    cx.beginPath();
    cx.arc(CENTER, CENTER, BACKGROUND_CIRCLE_RADIUS * SCALE_FACTOR, 0, Math.PI * 2);
    cx.stroke();
    cx.restore();
    
    // Layer 2: Traced shapes at SHAPE_OPACITY (background)
    d.red.forEach(s => { 
        if (s.length < 2) return; 
        cx.save();
        cx.globalAlpha = SHAPE_OPACITY;
        cx.strokeStyle = COLORS.red; 
        cx.lineWidth = brushSize; 
        cx.lineCap = 'round'; 
        cx.beginPath(); 
        const st = unitToCanvas(s[0].x, s[0].y); 
        cx.moveTo(st.x, st.y); 
        for (let i = 1; i < s.length; i++) { 
            const pt = unitToCanvas(s[i].x, s[i].y); 
            cx.lineTo(pt.x, pt.y); 
        } 
        cx.stroke(); 
        cx.restore();
    });
    d.blue.forEach(s => { 
        if (s.length < 2) return; 
        cx.save();
        cx.globalAlpha = SHAPE_OPACITY;
        cx.strokeStyle = COLORS.blue; 
        cx.lineWidth = brushSize; 
        cx.lineCap = 'round'; 
        cx.beginPath(); 
        const st = unitToCanvas(s[0].x, s[0].y); 
        cx.moveTo(st.x, st.y); 
        for (let i = 1; i < s.length; i++) { 
            const pt = unitToCanvas(s[i].x, s[i].y); 
            cx.lineTo(pt.x, pt.y); 
        } 
        cx.stroke(); 
        cx.restore();
    });
    
    // Layer 3: Average shapes at full opacity (foreground)
    if (d.redAvg?.length >= 2) { cx.strokeStyle = '#991b1b'; cx.lineWidth = 4; cx.lineCap = 'round'; cx.beginPath(); const st = unitToCanvas(d.redAvg[0].x, d.redAvg[0].y); cx.moveTo(st.x, st.y); for (let i = 1; i < d.redAvg.length; i++) { const pt = unitToCanvas(d.redAvg[i].x, d.redAvg[i].y); cx.lineTo(pt.x, pt.y); } cx.stroke(); }
    if (d.blueAvg?.length >= 2) { cx.strokeStyle = '#1e3a8a'; cx.lineWidth = 4; cx.lineCap = 'round'; cx.beginPath(); const st = unitToCanvas(d.blueAvg[0].x, d.blueAvg[0].y); cx.moveTo(st.x, st.y); for (let i = 1; i < d.blueAvg.length; i++) { const pt = unitToCanvas(d.blueAvg[i].x, d.blueAvg[i].y); cx.lineTo(pt.x, pt.y); } cx.stroke(); }
    
    // Layer 4: Grid on top
    cx.strokeStyle = '#e5e7eb'; cx.lineWidth = 1;
    for (let i = -UNIT_RANGE + 1; i < UNIT_RANGE; i++) { if (i === 0) continue; const c = unitToCanvas(i, i); cx.beginPath(); cx.moveTo(0, c.y); cx.lineTo(CANVAS_SIZE, c.y); cx.stroke(); cx.beginPath(); cx.moveTo(c.x, 0); cx.lineTo(c.x, CANVAS_SIZE); cx.stroke(); }
    cx.strokeStyle = '#6b7280'; cx.lineWidth = 2;
    cx.beginPath(); cx.moveTo(0, CENTER); cx.lineTo(CANVAS_SIZE, CENTER); cx.stroke();
    cx.beginPath(); cx.moveTo(CENTER, 0); cx.lineTo(CENTER, CANVAS_SIZE); cx.stroke();
    
    cx.fillStyle = '#1f2937'; cx.font = 'bold 24px sans-serif'; cx.textAlign = 'center';
    cx.fillText(`${p} - ${t} - ${fk}`, CENTER, 40);
    
    return tc.toDataURL('image/png');
}

// ============================================
// CLOUD COLLABORATION - GOOGLE SHEETS
// ============================================
let autoCloudSave = false;
let cloudSaveTimeout = null;

function getCloudUrl() {
    return document.getElementById('cloud-url').value.trim();
}

function getTracerName() {
    return document.getElementById('tracer-name').value.trim();
}

function setCloudStatus(msg, isError = false) {
    const el = document.getElementById('cloud-status');
    el.textContent = msg;
    el.className = isError ? 'text-xs text-red-600 mt-3' : 'text-xs text-green-600 mt-3';
}

async function saveToCloud() {
    const url = getCloudUrl();
    const tracerName = getTracerName();
    
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    if (!tracerName) {
        setCloudStatus('‚ùå Enter your tracer name', true);
        return;
    }
    
    // Save settings locally
    localStorage.setItem('cloudUrl', url);
    localStorage.setItem('tracerName', tracerName);
    
    const saveData = {
        action: 'saveProgress',
        tracerName: tracerName,
        savedAt: new Date().toISOString(),
        allData: allData,
        settings: { resampleRate, imageOpacity: Math.round(IMAGE_OPACITY * 100), shapeOpacity: Math.round(SHAPE_OPACITY * 100), brushSize }
    };
    
    try {
        setCloudStatus('Saving to cloud...');
        status('Saving to cloud...');
        
        // Use no-cors mode since Google Apps Script redirects
        // The actual save happens on the server side
        await fetch(url, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(saveData)
        });
        
        // Since no-cors doesn't return response, we assume success if no error thrown
        // Verify by doing a quick load check
        setTimeout(async () => {
            try {
                const checkUrl = `${url}?action=listTracers`;
                const checkResp = await fetch(checkUrl);
                if (checkResp.ok) {
                    const data = await checkResp.json();
                    const found = data.tracers?.find(t => t.name === tracerName);
                    if (found) {
                        setCloudStatus(`Saved as "${tracerName}" at ${new Date().toLocaleTimeString()} (${found.totalShapes} shapes)`);
                    } else {
                        setCloudStatus(`Saved as "${tracerName}" at ${new Date().toLocaleTimeString()}`);
                    }
                }
            } catch (e) {
                // Verification failed but save may have worked
                setCloudStatus(`Saved as "${tracerName}" at ${new Date().toLocaleTimeString()}`);
            }
        }, 1500);
        
        status('Saved to cloud');
    } catch (e) {
        setCloudStatus('Save failed: ' + e.message, true);
        status('Cloud save failed');
    }
}

async function loadFromCloud(tracerNameOverride = null) {
    const url = getCloudUrl();
    const tracerName = tracerNameOverride || getTracerName();
    
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    if (!tracerName) {
        setCloudStatus('‚ùå Enter tracer name to load', true);
        return;
    }
    
    try {
        setCloudStatus('‚òÅÔ∏è Loading from cloud...');
        status('Loading from cloud...');
        
        const response = await fetch(`${url}?action=loadProgress&tracerName=${encodeURIComponent(tracerName)}`);
        const data = await response.json();
        
        if (data.error) {
            setCloudStatus('‚ùå ' + data.error, true);
            status('Load failed: ' + data.error);
            return;
        }
        
        if (data.allData) {
            allData = data.allData;
            
            if (data.settings) {
                if (data.settings.resampleRate) {
                    resampleRate = data.settings.resampleRate;
                    document.getElementById('resample-slider').value = resampleRate;
                    document.getElementById('resample-val').textContent = resampleRate;
                }
                if (data.settings.imageOpacity !== undefined) {
                    IMAGE_OPACITY = data.settings.imageOpacity / 100;
                    document.getElementById('img-opacity-slider').value = data.settings.imageOpacity;
                    document.getElementById('img-opacity-val').textContent = data.settings.imageOpacity + '%';
                }
                if (data.settings.shapeOpacity !== undefined) {
                    SHAPE_OPACITY = data.settings.shapeOpacity / 100;
                    document.getElementById('shape-opacity-slider').value = data.settings.shapeOpacity;
                    document.getElementById('shape-opacity-val').textContent = data.settings.shapeOpacity + '%';
                }
                if (data.settings.brushSize) {
                    brushSize = data.settings.brushSize;
                    document.getElementById('brush-slider').value = brushSize;
                    document.getElementById('brush-val').textContent = brushSize;
                }
            }
            
            // Rebuild tabs
            rebuildTabsFromData();
            
            const savedTime = data.savedAt ? new Date(data.savedAt).toLocaleString() : 'unknown time';
            setCloudStatus(`‚úÖ Loaded "${tracerName}" (saved ${savedTime})`);
            status('Loaded from cloud');
        } else {
            setCloudStatus('‚ö†Ô∏è No data found for ' + tracerName);
        }
    } catch (e) {
        setCloudStatus('‚ùå Load failed: ' + e.message, true);
        status('Cloud load failed');
    }
}

async function listTracers() {
    const url = getCloudUrl();
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    
    try {
        setCloudStatus('‚òÅÔ∏è Fetching tracer list...');
        
        const response = await fetch(`${url}?action=listTracers`);
        const data = await response.json();
        
        const select = document.getElementById('tracer-select');
        select.innerHTML = '<option value="">-- Select tracer to load --</option>';
        
        if (data.tracers && data.tracers.length > 0) {
            data.tracers.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.name;
                opt.textContent = `${t.name} (${t.shapeCount} shapes, saved ${new Date(t.savedAt).toLocaleDateString()})`;
                select.appendChild(opt);
            });
            setCloudStatus(`‚úÖ Found ${data.tracers.length} tracers`);
        } else {
            setCloudStatus('‚ö†Ô∏è No tracers found');
        }
    } catch (e) {
        setCloudStatus('‚ùå Failed to list tracers: ' + e.message, true);
    }
}

async function mergeAllData() {
    const url = getCloudUrl();
    if (!url) {
        setCloudStatus('‚ùå Enter Apps Script URL', true);
        return;
    }
    
    if (!confirm('This will load and merge ALL tracers\' data. Your current unsaved work will be replaced. Continue?')) {
        return;
    }
    
    try {
        setCloudStatus('‚òÅÔ∏è Merging all tracer data...');
        status('Merging all data...');
        
        const response = await fetch(`${url}?action=mergeAll`);
        const data = await response.json();
        
        if (data.error) {
            setCloudStatus('‚ùå ' + data.error, true);
            return;
        }
        
        if (data.allData) {
            allData = data.allData;
            rebuildTabsFromData();
            setCloudStatus(`‚úÖ Merged data from ${data.tracerCount} tracers`);
            status('All data merged');
        }
    } catch (e) {
        setCloudStatus('‚ùå Merge failed: ' + e.message, true);
    }
}

function loadSelectedTracer() {
    const select = document.getElementById('tracer-select');
    const tracerName = select.value;
    if (tracerName) {
        loadFromCloud(tracerName);
    }
}

function toggleAutoCloudSave() {
    autoCloudSave = !autoCloudSave;
    const btn = document.getElementById('auto-cloud-toggle');
    btn.textContent = autoCloudSave ? '‚ö° Auto-Save: ON' : '‚ö° Auto-Save: OFF';
    btn.className = autoCloudSave 
        ? 'px-4 py-2 rounded-xl font-bold text-sm bg-green-500 text-white shadow'
        : 'px-4 py-2 rounded-xl font-bold text-sm bg-amber-500 text-white shadow';
    
    localStorage.setItem('autoCloudSave', autoCloudSave);
    status(autoCloudSave ? 'Auto-save to cloud enabled' : 'Auto-save disabled');
}

function triggerAutoSave() {
    if (!autoCloudSave) return;
    if (!getCloudUrl() || !getTracerName()) return;
    
    if (cloudSaveTimeout) clearTimeout(cloudSaveTimeout);
    cloudSaveTimeout = setTimeout(() => {
        saveToCloud();
    }, 2000); // Save 2 seconds after last shape
}

function rebuildTabsFromData() {
    const parts = new Map();
    for (const p of Object.keys(allData)) {
        parts.set(p, new Map());
        for (const t of Object.keys(allData[p])) {
            parts.get(p).set(t, new Set());
            for (const fk of Object.keys(allData[p][t])) {
                const hz = parseFloat(fk);
                if (!isNaN(hz)) parts.get(p).get(t).add(hz);
            }
        }
    }
    
    if (parts.size > 0) {
        buildTabs(parts);
        updateGallery();
        updateTable();
    }
}

function loadCloudSettings() {
    const url = localStorage.getItem('cloudUrl');
    const name = localStorage.getItem('tracerName');
    const autoSave = localStorage.getItem('autoCloudSave') === 'true';
    
    if (url) document.getElementById('cloud-url').value = url;
    if (name) document.getElementById('tracer-name').value = name;
    
    if (autoSave) {
        autoCloudSave = true;
        const btn = document.getElementById('auto-cloud-toggle');
        btn.textContent = '‚ö° Auto-Save: ON';
        btn.className = 'px-4 py-2 rounded-xl font-bold text-sm bg-green-500 text-white shadow';
    }
}

// ============================================
// INIT
// ============================================
function init() {
    canvas = document.getElementById('drawing-canvas');
    ctx = canvas.getContext('2d');
    canvas.width = canvas.height = CANVAS_SIZE;
    
    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', doDraw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseleave', endDraw);
    canvas.addEventListener('touchstart', startDraw, { passive: false });
    canvas.addEventListener('touchmove', doDraw, { passive: false });
    canvas.addEventListener('touchend', endDraw);
    
    document.getElementById('color-red').onclick = () => { selColor = 'red'; document.getElementById('color-red').classList.add('selected'); document.getElementById('color-blue').classList.remove('selected'); };
    document.getElementById('color-blue').onclick = () => { selColor = 'blue'; document.getElementById('color-blue').classList.add('selected'); document.getElementById('color-red').classList.remove('selected'); };
    
    document.getElementById('brush-slider').oninput = e => { brushSize = +e.target.value; document.getElementById('brush-val').textContent = brushSize; };
    document.getElementById('resample-slider').oninput = e => { resampleRate = +e.target.value; document.getElementById('resample-val').textContent = resampleRate; };
    document.getElementById('img-opacity-slider').oninput = e => { IMAGE_OPACITY = +e.target.value / 100; document.getElementById('img-opacity-val').textContent = e.target.value + '%'; redraw(); };
    document.getElementById('shape-opacity-slider').oninput = e => { SHAPE_OPACITY = +e.target.value / 100; document.getElementById('shape-opacity-val').textContent = e.target.value + '%'; redraw(); };
    
    document.getElementById('toggle-draw').onclick = () => { drawingOn = !drawingOn; const b = document.getElementById('toggle-draw'); b.textContent = drawingOn ? '‚úèÔ∏è Drawing: ON' : '‚úèÔ∏è Drawing: OFF'; b.className = b.className.replace(drawingOn ? 'bg-red' : 'bg-green', drawingOn ? 'bg-green' : 'bg-red'); canvas.style.cursor = drawingOn ? 'crosshair' : 'default'; };
    document.getElementById('undo-btn').onclick = undo;
    document.getElementById('redo-btn').onclick = redo;
    document.getElementById('clear-btn').onclick = () => { if (confirm('Clear all?')) { const d = curData(); if (d) { undoStack.push({ key: dataKey(), data: JSON.parse(JSON.stringify(d)) }); d.red = []; d.blue = []; d.redAvg = null; d.blueAvg = null; } redraw(); updateTable(); updateGallery(); document.getElementById('undo-btn').disabled = false; } };
    document.getElementById('grid-btn').onclick = () => { showGrid = !showGrid; redraw(); };
    
    document.getElementById('zip-upload').onchange = e => { if (e.target.files[0]) handleZip(e.target.files[0]); };
    document.getElementById('single-upload').onchange = e => { if (e.target.files[0]) handleSingle(e.target.files[0]); };
    document.getElementById('json-import').onchange = e => { if (e.target.files[0]) handleJson(e.target.files[0]); };
    
    document.getElementById('gen-avg').onclick = genAvgCur;
    document.getElementById('bulk-avg').onclick = openModal;
    document.getElementById('clear-avg').onclick = clearAvgCur;
    document.getElementById('gen-freq-avg').onclick = generateFrequencyAverages;
    document.getElementById('export-freq-png').onclick = exportFrequencyPNGs;
    
    document.getElementById('close-modal').onclick = () => document.getElementById('modal').classList.remove('active');
    document.getElementById('cancel-modal').onclick = () => document.getElementById('modal').classList.remove('active');
    document.getElementById('do-bulk').onclick = doBulk;
    document.getElementById('sel-all-p').onclick = () => document.querySelectorAll('#mod-p input').forEach(c => c.checked = true);
    document.getElementById('sel-all-t').onclick = () => document.querySelectorAll('#mod-t input').forEach(c => c.checked = true);
    document.getElementById('sel-all-f').onclick = () => document.querySelectorAll('#mod-f input').forEach(c => c.checked = true);
    
    document.getElementById('toggle-data').onclick = () => document.getElementById('data-box').classList.toggle('hidden');
    
    document.getElementById('exp-csv').onclick = expCSV;
    document.getElementById('exp-json').onclick = expJSON;
    document.getElementById('exp-sheets').onclick = expSheets;
    document.getElementById('imp-sheets').onclick = impSheets;
    document.getElementById('exp-drive').onclick = expDrive;
    
    const ss = localStorage.getItem('sheetsUrl'); if (ss) document.getElementById('sheets-url').value = ss;
    const sd = localStorage.getItem('driveUrl'); if (sd) document.getElementById('drive-url').value = sd;
    
    // Cloud collaboration
    document.getElementById('cloud-save').onclick = saveToCloud;
    document.getElementById('cloud-load').onclick = () => loadFromCloud();
    document.getElementById('cloud-list').onclick = listTracers;
    document.getElementById('cloud-merge').onclick = mergeAllData;
    document.getElementById('cloud-load-other').onclick = loadSelectedTracer;
    document.getElementById('auto-cloud-toggle').onclick = toggleAutoCloudSave;
    
    // Load saved cloud settings
    loadCloudSettings();
    
    drawGrid();
}

window.addEventListener('load', init);
</script>
</body>
</html>
