/**
 * Sound Object Contour Tracer - Cloud Collaboration Script v4.1
 * UCI Hearing & Speech Lab
 * Last Updated: January 13, 2026
 * 
 * This script receives traced contour data from the Contour Tracer web tool
 * and stores it in a Google Sheet for collaborative work.
 * 
 * IMPORTANT: Large JSON data is automatically split across multiple cells
 * (Google Sheets has a 50,000 character limit per cell). The load function
 * automatically reassembles these chunks.
 * 
 * Setup Instructions:
 * 1. Create a new Google Sheet
 * 2. Go to Extensions > Apps Script
 * 3. Delete any existing code and paste this entire script
 * 4. Update SHEET_ID below with your Google Sheet ID (from URL)
 * 5. Click "Deploy" > "New Deployment"
 * 6. Choose type: "Web app"
 * 7. Execute as: "Me"
 * 8. Who has access: "Anyone"
 * 9. Deploy and copy the Web App URL
 * 10. Use this URL in the Contour Tracer tool
 */

// ============================================
// CONFIGURATION - UPDATE THIS
// ============================================
const SHEET_ID = '171gBcPHKi8AUmLK03vwPz9OH6vkg0fCS0M_eTP1ijo8'; // Get this from your sheet's URL: docs.google.com/spreadsheets/d/YOUR_ID_HERE/edit

// Sheet names
const TRACERS_SHEET = 'TracerProgress';
const COORDS_SHEET = 'CoordinateData';
const SUMMARY_SHEET = 'Summary';
const LOG_SHEET = 'ActivityLog';

// Valid frequencies for the study
const VALID_FREQUENCIES = [62.5, 125, 250, 500, 1000, 2000];

// ============================================
// MAIN POST HANDLER
// ============================================

function doPost(e) {
  try {
    // Log incoming data size
    const rawData = e.postData.contents;
    Logger.log('Received POST data size: ' + rawData.length + ' chars');
    
    // Parse the incoming data
    const data = JSON.parse(rawData);
    
    // Log parsed data stats
    if (data.allData) {
      const participants = Object.keys(data.allData);
      Logger.log('Parsed data: ' + participants.length + ' participants');
      let shapeCount = 0;
      for (const p of participants) {
        for (const t of Object.keys(data.allData[p])) {
          for (const f of Object.keys(data.allData[p][t])) {
            const d = data.allData[p][t][f];
            if (d.red) shapeCount += d.red.length;
            if (d.blue) shapeCount += d.blue.length;
          }
        }
      }
      Logger.log('Total shapes in received data: ' + shapeCount);
    }
    
    // Open the spreadsheet
    const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    
    // Ensure all sheets exist
    ensureSheetExists(spreadsheet, TRACERS_SHEET, getTracerHeaders());
    ensureSheetExists(spreadsheet, COORDS_SHEET, getCoordHeaders());
    ensureSheetExists(spreadsheet, SUMMARY_SHEET, getSummaryHeaders());
    ensureSheetExists(spreadsheet, LOG_SHEET, getLogHeaders());
    
    // Handle different actions
    switch(data.action) {
      case 'saveProgress':
        return saveTracerProgress(spreadsheet, data);
      case 'export':
        data.tracerName = data.tracerName || 'default';
        return saveTracerProgress(spreadsheet, data);
      default:
        return jsonResponse({ error: 'Unknown action. Use: saveProgress' });
    }
    
  } catch (error) {
    Logger.log('doPost Error: ' + error.toString());
    return jsonResponse({
      result: 'error',
      error: error.toString()
    });
  }
}

// ============================================
// MAIN GET HANDLER
// ============================================

function doGet(e) {
  try {
    const params = e.parameter;
    
    // If no parameters, return API documentation
    if (!params || !params.action) {
      return jsonResponse({
        api: 'Contour Tracer Cloud Collaboration API',
        version: '4.0',
        status: SHEET_ID ? 'configured' : 'NOT CONFIGURED - Set SHEET_ID',
        usage: {
          loadProgress: '?action=loadProgress&tracerName=YourName',
          listTracers: '?action=listTracers',
          mergeAll: '?action=mergeAll',
          getSummary: '?action=getSummary'
        }
      });
    }
    
    // Open the spreadsheet
    const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    
    // Ensure sheets exist
    ensureSheetExists(spreadsheet, TRACERS_SHEET, getTracerHeaders());
    ensureSheetExists(spreadsheet, COORDS_SHEET, getCoordHeaders());
    ensureSheetExists(spreadsheet, SUMMARY_SHEET, getSummaryHeaders());
    ensureSheetExists(spreadsheet, LOG_SHEET, getLogHeaders());
    
    switch(params.action) {
      case 'loadProgress':
        return loadTracerProgress(spreadsheet, params.tracerName);
      case 'loadAllFromCoordinates':
        return loadAllFromCoordinates(spreadsheet, params.tracerName);
      case 'loadAllCoordinates':
        return loadAllCoordinatesData(spreadsheet);
      case 'listTracers':
        return listAllTracers(spreadsheet);
      case 'mergeAll':
        return mergeAllTracers(spreadsheet);
      case 'getSummary':
        return getSummary(spreadsheet);
      default:
        return jsonResponse({ error: 'Unknown action' });
    }
    
  } catch (error) {
    Logger.log('doGet Error: ' + error.toString());
    return jsonResponse({
      result: 'error',
      error: error.toString()
    });
  }
}

// ============================================
// SHEET CREATION HELPERS
// ============================================

function getTracerHeaders() {
  return ['TracerName', 'SavedAt', 'Version', 'ParticipantCount', 'TrialCount', 'TotalShapes', 'Settings_JSON', 'AllData_JSON'];
}

function getCoordHeaders() {
  return ['TracerName', 'Participant', 'Trial', 'Frequency_Hz', 'Color', 'ShapeType', 'ShapeNumber', 'PointIndex', 'X', 'Y'];
}

function getSummaryHeaders() {
  return ['Participant', 'Trial', 'Frequency', 'RedShapes', 'BlueShapes', 'RedAvg', 'BlueAvg', 'TotalPoints', 'LastUpdatedBy', 'LastUpdatedAt'];
}

function getLogHeaders() {
  return ['Timestamp', 'TracerName', 'Action', 'Details'];
}

/**
 * Ensure a sheet exists with proper headers
 */
function ensureSheetExists(spreadsheet, sheetName, headers) {
  let sheet = spreadsheet.getSheetByName(sheetName);
  
  if (!sheet) {
    sheet = spreadsheet.insertSheet(sheetName);
    
    // Set headers
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    
    // Format headers
    const headerRange = sheet.getRange(1, 1, 1, headers.length);
    headerRange.setFontWeight('bold');
    headerRange.setHorizontalAlignment('center');
    
    // Set background color based on sheet type
    let bgColor = '#4285f4'; // Default blue
    if (sheetName === COORDS_SHEET) bgColor = '#34a853'; // Green
    if (sheetName === SUMMARY_SHEET) bgColor = '#fbbc04'; // Yellow
    if (sheetName === LOG_SHEET) bgColor = '#ea4335'; // Red
    
    headerRange.setBackground(bgColor);
    headerRange.setFontColor('#ffffff');
    
    // Freeze header row
    sheet.setFrozenRows(1);
    
    Logger.log('Created sheet: ' + sheetName);
  }
  
  return sheet;
}

// ============================================
// SAVE FUNCTIONS
// ============================================

/**
 * Save a tracer's progress
 * Uses LockService to prevent concurrent modification issues
 */
function saveTracerProgress(spreadsheet, data) {
  const lock = LockService.getScriptLock();
  
  try {
    // Wait up to 30 seconds for the lock
    lock.waitLock(30000);
    
    const sheet = spreadsheet.getSheetByName(TRACERS_SHEET);
    
    const tracerName = data.tracerName || 'anonymous';
    const savedAt = new Date().toISOString();
    const version = data.version || '4.1';
    const allData = data.allData || {};
    const settings = data.settings || {};
    
    // Count participants, trials, and shapes
    let participantCount = 0;
    let trialCount = 0;
    let totalShapes = 0;
    
    const participants = Object.keys(allData);
    participantCount = participants.length;
    
    const trialSet = new Set();
    for (const p of participants) {
      for (const t of Object.keys(allData[p])) {
        trialSet.add(p + '|' + t);
        for (const f of Object.keys(allData[p][t])) {
          const d = allData[p][t][f];
          if (d.red) totalShapes += d.red.length;
          if (d.blue) totalShapes += d.blue.length;
          if (d.redAvg) totalShapes++;
          if (d.blueAvg) totalShapes++;
        }
      }
    }
    trialCount = trialSet.size;
    
    // Find existing row for this tracer
    const lastRow = sheet.getLastRow();
    let rowIndex = -1;
    
    if (lastRow > 1) {
      const existingData = sheet.getRange(2, 1, lastRow - 1, 1).getValues();
      for (let i = 0; i < existingData.length; i++) {
        if (existingData[i][0] === tracerName) {
          rowIndex = i + 2; // +2 because we start from row 2
          break;
        }
      }
    }
    
    const rowData = [
      tracerName,
      savedAt,
      version,
      participantCount,
      trialCount,
      totalShapes,
      JSON.stringify(settings),
      '' // Placeholder - we'll handle AllData separately
    ];
    
    // Google Sheets has a 50,000 character limit per cell
    // Split large JSON across multiple cells if needed
    const MAX_CELL_SIZE = 49000; // Leave some margin
    const allDataJson = JSON.stringify(allData);
    const chunks = [];
    
    for (let i = 0; i < allDataJson.length; i += MAX_CELL_SIZE) {
      chunks.push(allDataJson.substring(i, i + MAX_CELL_SIZE));
    }
    
    Logger.log('AllData size: ' + allDataJson.length + ' chars, split into ' + chunks.length + ' chunks');
    
    // Prepare full row with all chunks
    const fullRowData = rowData.slice(0, 7); // First 7 columns
    for (let i = 0; i < chunks.length; i++) {
      fullRowData.push(chunks[i]);
    }
    
    if (rowIndex > 0) {
      // Update existing row - first clear any old chunk columns
      const lastCol = sheet.getLastColumn();
      if (lastCol > 7) {
        sheet.getRange(rowIndex, 8, 1, lastCol - 7).clearContent();
      }
      
      // Write entire row at once (much faster than cell by cell)
      sheet.getRange(rowIndex, 1, 1, fullRowData.length).setValues([fullRowData]);
      
      Logger.log('Updated existing tracer: ' + tracerName);
    } else {
      // Append new row with all data at once
      sheet.appendRow(fullRowData);
      
      Logger.log('Added new tracer: ' + tracerName);
    }
    
    // Release lock before updating coordinate sheet (it has its own lock)
    lock.releaseLock();
    
    // Update coordinate data sheet (has its own locking)
    updateCoordinateSheet(spreadsheet, tracerName, allData);
    
    // Log activity
    logActivity(spreadsheet, tracerName, 'SAVE', participantCount + ' participants, ' + trialCount + ' trials, ' + totalShapes + ' shapes + ' + chunks.length + ' JSON chunks');
    
    return jsonResponse({
      result: 'success',
      tracerName: tracerName,
      savedAt: savedAt,
      participantCount: participantCount,
      trialCount: trialCount,
      totalShapes: totalShapes,
      jsonChunks: chunks.length
    });
    
  } catch (e) {
    Logger.log('Error in saveTracerProgress: ' + e.toString());
    return jsonResponse({
      result: 'error',
      error: e.toString()
    });
  }
}

/**
 * Update the flattened coordinate data sheet
 * Old data is NEVER replaced or deleted. Only truly new rows are added.
 * A row is considered duplicate if ALL 10 columns match exactly.
 * Uses LockService to prevent concurrent modification issues
 */
function updateCoordinateSheet(spreadsheet, tracerName, allData) {
  const lock = LockService.getScriptLock();
  
  try {
    // Wait up to 30 seconds for the lock
    lock.waitLock(30000);
    
    const sheet = spreadsheet.getSheetByName(COORDS_SHEET);
    
    // Get all existing rows and create a set of exact row signatures
    const lastRow = sheet.getLastRow();
    const existingRowSignatures = new Set();
    
    if (lastRow > 1) {
      const allRows = sheet.getRange(2, 1, lastRow - 1, 10).getValues();
      allRows.forEach(row => {
        // Create signature from ALL 10 columns for exact match
        const signature = row.map(cell => String(cell)).join('|');
        existingRowSignatures.add(signature);
      });
    }
    
    // Build new rows from this tracer's data
    const newRows = [];
    
    const participants = Object.keys(allData).sort();
    for (const participant of participants) {
      const trials = Object.keys(allData[participant]).sort();
      for (const trial of trials) {
        const freqKeys = Object.keys(allData[participant][trial]).sort();
        for (const freqKey of freqKeys) {
          const d = allData[participant][trial][freqKey];
          
          // Parse frequency from key (e.g., "62.5Hz_80dB" -> "62.5")
          const freqMatch = freqKey.match(/^(\d+(?:\.\d+)?)/);
          const freqHz = freqMatch ? freqMatch[1] : freqKey;
          
          // Red traced shapes
          if (d.red && d.red.length > 0) {
            d.red.forEach((shape, shapeIdx) => {
              if (shape && shape.length > 0) {
                shape.forEach((pt, ptIdx) => {
                  const row = [
                    tracerName,
                    participant,
                    trial,
                    freqHz,
                    'Red',
                    'Traced',
                    shapeIdx + 1,
                    ptIdx + 1,
                    pt.x,
                    pt.y
                  ];
                  const signature = row.map(cell => String(cell)).join('|');
                  if (!existingRowSignatures.has(signature)) {
                    newRows.push(row);
                    existingRowSignatures.add(signature); // Prevent duplicates within this export
                  }
                });
              }
            });
          }
          
          // Blue traced shapes
          if (d.blue && d.blue.length > 0) {
            d.blue.forEach((shape, shapeIdx) => {
              if (shape && shape.length > 0) {
                shape.forEach((pt, ptIdx) => {
                  const row = [
                    tracerName,
                    participant,
                    trial,
                    freqHz,
                    'Blue',
                    'Traced',
                    shapeIdx + 1,
                    ptIdx + 1,
                    pt.x,
                    pt.y
                  ];
                  const signature = row.map(cell => String(cell)).join('|');
                  if (!existingRowSignatures.has(signature)) {
                    newRows.push(row);
                    existingRowSignatures.add(signature);
                  }
                });
              }
            });
          }
          
          // Red average shape
          if (d.redAvg && d.redAvg.length > 0) {
            d.redAvg.forEach((pt, ptIdx) => {
              const row = [
                tracerName,
                participant,
                trial,
                freqHz,
                'Red',
                'Average',
                1,
                ptIdx + 1,
                pt.x,
                pt.y
              ];
              const signature = row.map(cell => String(cell)).join('|');
              if (!existingRowSignatures.has(signature)) {
                newRows.push(row);
                existingRowSignatures.add(signature);
              }
            });
          }
          
          // Blue average shape
          if (d.blueAvg && d.blueAvg.length > 0) {
            d.blueAvg.forEach((pt, ptIdx) => {
              const row = [
                tracerName,
                participant,
                trial,
                freqHz,
                'Blue',
                'Average',
                1,
                ptIdx + 1,
                pt.x,
                pt.y
              ];
              const signature = row.map(cell => String(cell)).join('|');
              if (!existingRowSignatures.has(signature)) {
                newRows.push(row);
                existingRowSignatures.add(signature);
              }
            });
          }
        }
      }
    }
    
    // Only append truly new rows - never modify existing data
    if (newRows.length > 0) {
      const startRow = sheet.getLastRow() + 1;
      sheet.getRange(startRow, 1, newRows.length, 10).setValues(newRows);
      Logger.log('Added ' + newRows.length + ' new rows for ' + tracerName);
    } else {
      Logger.log('No new rows to add for ' + tracerName + ' - all data already exists');
    }
    
  } catch (e) {
    Logger.log('Error in updateCoordinateSheet: ' + e.toString());
    throw e;
  } finally {
    // Always release the lock
    lock.releaseLock();
  }
}

/**
 * Update summary sheet
 */
function updateSummarySheet(spreadsheet, tracerName, allData) {
  const sheet = spreadsheet.getSheetByName(SUMMARY_SHEET);
  const now = new Date().toISOString();
  
  // Get existing data to find/update rows
  const lastRow = sheet.getLastRow();
  const existingKeys = {};
  
  if (lastRow > 1) {
    const existingData = sheet.getRange(2, 1, lastRow - 1, 3).getValues();
    for (let i = 0; i < existingData.length; i++) {
      const key = existingData[i][0] + '|' + existingData[i][1] + '|' + existingData[i][2];
      existingKeys[key] = i + 2; // Row number
    }
  }
  
  // Process each participant/trial/frequency
  for (const participant of Object.keys(allData)) {
    for (const trial of Object.keys(allData[participant])) {
      for (const freqKey of Object.keys(allData[participant][trial])) {
        const d = allData[participant][trial][freqKey];
        const key = participant + '|' + trial + '|' + freqKey;
        
        const redShapes = d.red ? d.red.length : 0;
        const blueShapes = d.blue ? d.blue.length : 0;
        const hasRedAvg = d.redAvg ? 'Yes' : 'No';
        const hasBlueAvg = d.blueAvg ? 'Yes' : 'No';
        
        let totalPoints = 0;
        if (d.red) d.red.forEach(s => { if (s) totalPoints += s.length; });
        if (d.blue) d.blue.forEach(s => { if (s) totalPoints += s.length; });
        if (d.redAvg) totalPoints += d.redAvg.length;
        if (d.blueAvg) totalPoints += d.blueAvg.length;
        
        const rowData = [
          participant,
          trial,
          freqKey,
          redShapes,
          blueShapes,
          hasRedAvg,
          hasBlueAvg,
          totalPoints,
          tracerName,
          now
        ];
        
        if (existingKeys[key]) {
          // Update existing row
          sheet.getRange(existingKeys[key], 1, 1, 10).setValues([rowData]);
        } else {
          // Append new row
          sheet.appendRow(rowData);
          existingKeys[key] = sheet.getLastRow();
        }
      }
    }
  }
}

// ============================================
// LOAD FUNCTIONS
// ============================================

/**
 * Load a tracer's progress
 */
function loadTracerProgress(spreadsheet, tracerName) {
  if (!tracerName) {
    return jsonResponse({ error: 'tracerName is required' });
  }
  
  const sheet = spreadsheet.getSheetByName(TRACERS_SHEET);
  
  if (!sheet) {
    return jsonResponse({ error: 'No data found. Save some progress first.' });
  }
  
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow <= 1) {
    return jsonResponse({ error: 'No tracer data found' });
  }
  
  // Get all columns (including potential JSON chunks beyond column 8)
  const maxCols = Math.max(lastCol, 20); // Get at least 20 columns to capture chunks
  const data = sheet.getRange(2, 1, lastRow - 1, maxCols).getValues();
  
  for (let i = 0; i < data.length; i++) {
    if (data[i][0] === tracerName) {
      try {
        // Reassemble JSON chunks from column 8 onwards
        let allDataJson = '';
        for (let col = 7; col < data[i].length; col++) {
          if (data[i][col] && typeof data[i][col] === 'string' && data[i][col].length > 0) {
            allDataJson += data[i][col];
          }
        }
        
        const allData = JSON.parse(allDataJson || '{}');
        const settings = JSON.parse(data[i][6] || '{}');
        
        Logger.log('Loaded ' + tracerName + ': JSON size = ' + allDataJson.length + ' chars');
        
        // Log activity
        logActivity(spreadsheet, tracerName, 'LOAD', data[i][3] + ' participants loaded');
        
        return jsonResponse({
          success: true,
          tracerName: tracerName,
          savedAt: data[i][1],
          version: data[i][2],
          participantCount: data[i][3],
          trialCount: data[i][4],
          totalShapes: data[i][5],
          settings: settings,
          allData: allData
        });
      } catch (e) {
        Logger.log('Parse error for ' + tracerName + ': ' + e.toString());
        return jsonResponse({ error: 'Failed to parse saved data: ' + e.toString() });
      }
    }
  }
  
  return jsonResponse({
    found: false,
    error: 'Tracer not found: ' + tracerName
  });
}

/**
 * Load ALL data for a specific tracer from the CoordinateData sheet
 * This includes all historical exports, not just the latest
 */
function loadAllFromCoordinates(spreadsheet, tracerName) {
  if (!tracerName) {
    return jsonResponse({ error: 'tracerName is required' });
  }
  
  const sheet = spreadsheet.getSheetByName(COORDS_SHEET);
  
  if (!sheet) {
    return jsonResponse({ error: 'No coordinate data found' });
  }
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) {
    return jsonResponse({ error: 'No coordinate data found' });
  }
  
  // Frequency to dB mapping (must match the app's FREQUENCIES constant)
  const freqToDb = {
    '62.5': 100,
    '125': 90,
    '250': 85,
    '500': 80,
    '1000': 80,
    '2000': 80
  };
  
  // Get all data from CoordinateData sheet
  const data = sheet.getRange(2, 1, lastRow - 1, 10).getValues();
  
  // Build allData structure from coordinates
  const allData = {};
  let pointCount = 0;
  
  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const rowTracer = String(row[0]);
    
    // Filter by tracer name if specified
    if (rowTracer !== tracerName) continue;
    
    const participant = String(row[1]);
    const trial = String(row[2]);
    const freqHz = String(row[3]);
    const color = String(row[4]); // 'Red' or 'Blue'
    const shapeType = String(row[5]); // 'Traced' or 'Average'
    const shapeNum = parseInt(row[6]) || 1;
    const pointIdx = parseInt(row[7]) || 1;
    const x = parseFloat(row[8]);
    const y = parseFloat(row[9]);
    
    // Skip invalid data
    if (isNaN(x) || isNaN(y)) continue;
    
    // Build frequency key to match app format: "62.5Hz_100dB"
    const db = freqToDb[freqHz] || 80;
    const freqKey = freqHz + 'Hz_' + db + 'dB';
    
    // Initialize structure
    if (!allData[participant]) allData[participant] = {};
    if (!allData[participant][trial]) allData[participant][trial] = {};
    if (!allData[participant][trial][freqKey]) {
      allData[participant][trial][freqKey] = { red: [], blue: [], redAvg: null, blueAvg: null };
    }
    
    const freqData = allData[participant][trial][freqKey];
    
    if (shapeType === 'Traced') {
      const shapeArray = color === 'Red' ? freqData.red : freqData.blue;
      // Ensure shape array has enough slots
      while (shapeArray.length < shapeNum) {
        shapeArray.push([]);
      }
      // Add point to the shape
      if (!shapeArray[shapeNum - 1]) shapeArray[shapeNum - 1] = [];
      shapeArray[shapeNum - 1].push({ x: x, y: y });
    } else if (shapeType === 'Average') {
      const avgKey = color === 'Red' ? 'redAvg' : 'blueAvg';
      if (!freqData[avgKey]) freqData[avgKey] = [];
      freqData[avgKey].push({ x: x, y: y });
    }
    
    pointCount++;
  }
  
  Logger.log('Loaded ' + pointCount + ' points for tracer: ' + tracerName);
  logActivity(spreadsheet, tracerName, 'LOAD_COORDS', pointCount + ' points from CoordinateData');
  
  return jsonResponse({
    success: true,
    tracerName: tracerName,
    pointCount: pointCount,
    allData: allData
  });
}

/**
 * Load ALL coordinate data from all tracers
 * Returns combined data from the CoordinateData sheet
 */
function loadAllCoordinatesData(spreadsheet) {
  const sheet = spreadsheet.getSheetByName(COORDS_SHEET);
  
  if (!sheet) {
    return jsonResponse({ error: 'No coordinate data found' });
  }
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) {
    return jsonResponse({ error: 'No coordinate data found' });
  }
  
  // Frequency to dB mapping (must match the app's FREQUENCIES constant)
  const freqToDb = {
    '62.5': 100,
    '125': 90,
    '250': 85,
    '500': 80,
    '1000': 80,
    '2000': 80
  };
  
  // Get all data from CoordinateData sheet
  const data = sheet.getRange(2, 1, lastRow - 1, 10).getValues();
  
  // Build allData structure from all coordinates
  const allData = {};
  let pointCount = 0;
  const tracerSet = new Set();
  
  for (let i = 0; i < data.length; i++) {
    const row = data[i];
    const tracer = String(row[0]);
    const participant = String(row[1]);
    const trial = String(row[2]);
    const freqHz = String(row[3]);
    const color = String(row[4]);
    const shapeType = String(row[5]);
    const shapeNum = parseInt(row[6]) || 1;
    const pointIdx = parseInt(row[7]) || 1;
    const x = parseFloat(row[8]);
    const y = parseFloat(row[9]);
    
    // Skip invalid data
    if (isNaN(x) || isNaN(y)) continue;
    
    tracerSet.add(tracer);
    
    // Build frequency key to match app format: "62.5Hz_100dB"
    const db = freqToDb[freqHz] || 80;
    const freqKey = freqHz + 'Hz_' + db + 'dB';
    
    // Initialize structure
    if (!allData[participant]) allData[participant] = {};
    if (!allData[participant][trial]) allData[participant][trial] = {};
    if (!allData[participant][trial][freqKey]) {
      allData[participant][trial][freqKey] = { red: [], blue: [], redAvg: null, blueAvg: null };
    }
    
    const freqData = allData[participant][trial][freqKey];
    
    if (shapeType === 'Traced') {
      const shapeArray = color === 'Red' ? freqData.red : freqData.blue;
      while (shapeArray.length < shapeNum) {
        shapeArray.push([]);
      }
      if (!shapeArray[shapeNum - 1]) shapeArray[shapeNum - 1] = [];
      shapeArray[shapeNum - 1].push({ x: x, y: y });
    } else if (shapeType === 'Average') {
      const avgKey = color === 'Red' ? 'redAvg' : 'blueAvg';
      if (!freqData[avgKey]) freqData[avgKey] = [];
      freqData[avgKey].push({ x: x, y: y });
    }
    
    pointCount++;
  }
  
  Logger.log('Loaded ' + pointCount + ' total points from ' + tracerSet.size + ' tracers');
  logActivity(spreadsheet, 'ALL', 'LOAD_ALL_COORDS', pointCount + ' points from ' + tracerSet.size + ' tracers');
  
  return jsonResponse({
    success: true,
    tracerCount: tracerSet.size,
    tracers: Array.from(tracerSet),
    pointCount: pointCount,
    allData: allData
  });
}

/**
 * List all tracers
 */
function listAllTracers(spreadsheet) {
  const sheet = spreadsheet.getSheetByName(TRACERS_SHEET);
  
  if (!sheet) {
    return jsonResponse({ tracers: [], message: 'No data saved yet' });
  }
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) {
    return jsonResponse({ tracers: [], message: 'No tracers found' });
  }
  
  const data = sheet.getRange(2, 1, lastRow - 1, 6).getValues();
  const tracers = [];
  
  for (let i = 0; i < data.length; i++) {
    if (data[i][0]) {
      tracers.push({
        name: data[i][0],
        savedAt: data[i][1],
        version: data[i][2],
        participantCount: data[i][3],
        trialCount: data[i][4],
        totalShapes: data[i][5]
      });
    }
  }
  
  // Sort by most recent first
  tracers.sort((a, b) => new Date(b.savedAt) - new Date(a.savedAt));
  
  return jsonResponse({
    tracers: tracers,
    count: tracers.length
  });
}

/**
 * Merge all tracers' data
 */
function mergeAllTracers(spreadsheet) {
  const sheet = spreadsheet.getSheetByName(TRACERS_SHEET);
  
  if (!sheet) {
    return jsonResponse({ error: 'No data found' });
  }
  
  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow <= 1) {
    return jsonResponse({ error: 'No tracer data found' });
  }
  
  // Get all columns to capture JSON chunks
  const maxCols = Math.max(lastCol, 20);
  const data = sheet.getRange(2, 1, lastRow - 1, maxCols).getValues();
  
  const mergedData = {};
  const mergedSettings = { resampleRate: 1000, imageOpacity: 10, brushSize: 5 };
  let tracerCount = 0;
  const tracerNames = [];
  
  for (let i = 0; i < data.length; i++) {
    if (data[i][0]) {
      // Reassemble JSON chunks from column 8 onwards
      let allDataJson = '';
      for (let col = 7; col < data[i].length; col++) {
        if (data[i][col] && typeof data[i][col] === 'string' && data[i][col].length > 0) {
          allDataJson += data[i][col];
        }
      }
      
      if (allDataJson.length > 0) {
        tracerCount++;
        tracerNames.push(data[i][0]);
        
        try {
          const tracerData = JSON.parse(allDataJson);
          const tracerSettings = JSON.parse(data[i][6] || '{}');
        
          // Use latest settings
          if (tracerSettings.resampleRate) mergedSettings.resampleRate = tracerSettings.resampleRate;
          if (tracerSettings.imageOpacity !== undefined) mergedSettings.imageOpacity = tracerSettings.imageOpacity;
          if (tracerSettings.brushSize) mergedSettings.brushSize = tracerSettings.brushSize;
          
          // Merge data
          for (const p of Object.keys(tracerData)) {
            if (!mergedData[p]) mergedData[p] = {};
            
            for (const t of Object.keys(tracerData[p])) {
              if (!mergedData[p][t]) mergedData[p][t] = {};
              
              for (const f of Object.keys(tracerData[p][t])) {
                if (!mergedData[p][t][f]) {
                  mergedData[p][t][f] = { red: [], blue: [], redAvg: null, blueAvg: null };
                }
                
                const src = tracerData[p][t][f];
                const dst = mergedData[p][t][f];
                
                // Concatenate shapes
                if (src.red && src.red.length > 0) {
                  dst.red = dst.red.concat(src.red);
                }
                if (src.blue && src.blue.length > 0) {
                  dst.blue = dst.blue.concat(src.blue);
                }
                
                // Keep most recent average
                if (src.redAvg) dst.redAvg = src.redAvg;
                if (src.blueAvg) dst.blueAvg = src.blueAvg;
              }
            }
          }
        } catch (e) {
          Logger.log('Error parsing tracer ' + data[i][0] + ': ' + e);
        }
      }
    }
  }
  
  // Count merged stats
  let totalParticipants = Object.keys(mergedData).length;
  let totalTrials = 0;
  let totalShapes = 0;
  
  for (const p of Object.keys(mergedData)) {
    for (const t of Object.keys(mergedData[p])) {
      totalTrials++;
      for (const f of Object.keys(mergedData[p][t])) {
        const d = mergedData[p][t][f];
        if (d.red) totalShapes += d.red.length;
        if (d.blue) totalShapes += d.blue.length;
      }
    }
  }
  
  logActivity(spreadsheet, 'SYSTEM', 'MERGE', tracerCount + ' tracers merged: ' + tracerNames.join(', '));
  
  return jsonResponse({
    success: true,
    tracerCount: tracerCount,
    tracerNames: tracerNames,
    participantCount: totalParticipants,
    trialCount: totalTrials,
    totalShapes: totalShapes,
    settings: mergedSettings,
    allData: mergedData
  });
}

/**
 * Get summary
 */
function getSummary(spreadsheet) {
  const sheet = spreadsheet.getSheetByName(SUMMARY_SHEET);
  
  if (!sheet) {
    return jsonResponse({ error: 'No summary data available' });
  }
  
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) {
    return jsonResponse({ summary: { participants: {}, totalEntries: 0 } });
  }
  
  const data = sheet.getRange(2, 1, lastRow - 1, 10).getValues();
  
  const summary = {
    participants: {},
    totalEntries: data.length
  };
  
  for (let i = 0; i < data.length; i++) {
    const participant = data[i][0];
    const trial = data[i][1];
    const freq = data[i][2];
    
    if (!summary.participants[participant]) {
      summary.participants[participant] = { trials: {} };
    }
    if (!summary.participants[participant].trials[trial]) {
      summary.participants[participant].trials[trial] = { frequencies: [] };
    }
    
    summary.participants[participant].trials[trial].frequencies.push({
      frequency: freq,
      redShapes: data[i][3],
      blueShapes: data[i][4],
      redAvg: data[i][5],
      blueAvg: data[i][6],
      totalPoints: data[i][7],
      lastUpdatedBy: data[i][8],
      lastUpdatedAt: data[i][9]
    });
  }
  
  return jsonResponse({ summary: summary });
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

/**
 * Log activity
 */
function logActivity(spreadsheet, tracerName, action, details) {
  const sheet = spreadsheet.getSheetByName(LOG_SHEET);
  
  if (sheet) {
    sheet.appendRow([
      new Date().toISOString(),
      tracerName,
      action,
      details
    ]);
    
    // Keep only last 1000 entries
    const numRows = sheet.getLastRow();
    if (numRows > 1001) {
      sheet.deleteRows(2, numRows - 1001);
    }
  }
}

/**
 * Create JSON response
 */
function jsonResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}

// ============================================
// SETUP AND TEST FUNCTIONS
// ============================================

/**
 * Initial setup function - Run this FIRST
 * Go to Run > Run function > setupSheets
 */
function setupSheets() {
  Logger.log('='.repeat(60));
  Logger.log('Setting up Contour Tracer Cloud Collaboration');
  Logger.log('='.repeat(60));
  
  if (!SHEET_ID || SHEET_ID === '') {
    Logger.log('');
    Logger.log('ERROR: SHEET_ID is not set!');
    Logger.log('');
    Logger.log('To fix this:');
    Logger.log('1. Open your Google Sheet');
    Logger.log('2. Copy the ID from the URL:');
    Logger.log('   https://docs.google.com/spreadsheets/d/YOUR_ID_HERE/edit');
    Logger.log('3. Paste it into the SHEET_ID variable at the top of this script');
    Logger.log('4. Run this function again');
    return;
  }
  
  try {
    const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
    Logger.log('Opened spreadsheet: ' + spreadsheet.getName());
    Logger.log('');
    
    // Create all sheets
    Logger.log('Creating sheets...');
    ensureSheetExists(spreadsheet, TRACERS_SHEET, getTracerHeaders());
    ensureSheetExists(spreadsheet, COORDS_SHEET, getCoordHeaders());
    ensureSheetExists(spreadsheet, SUMMARY_SHEET, getSummaryHeaders());
    ensureSheetExists(spreadsheet, LOG_SHEET, getLogHeaders());
    
    // Remove default Sheet1 if it exists and we have other sheets
    const defaultSheet = spreadsheet.getSheetByName('Sheet1');
    if (defaultSheet && spreadsheet.getSheets().length > 1) {
      spreadsheet.deleteSheet(defaultSheet);
      Logger.log('Removed default Sheet1');
    }
    
    Logger.log('');
    Logger.log('Sheets created:');
    spreadsheet.getSheets().forEach(sheet => {
      Logger.log('  - ' + sheet.getName());
    });
    
    Logger.log('');
    Logger.log('='.repeat(60));
    Logger.log('SETUP COMPLETE!');
    Logger.log('='.repeat(60));
    Logger.log('');
    Logger.log('Next steps:');
    Logger.log('1. Click Deploy > New deployment');
    Logger.log('2. Click the gear icon and select "Web app"');
    Logger.log('3. Set "Execute as" to "Me"');
    Logger.log('4. Set "Who has access" to "Anyone"');
    Logger.log('5. Click Deploy');
    Logger.log('6. Copy the Web App URL');
    Logger.log('7. Paste it into the Contour Tracer app');
    
  } catch (error) {
    Logger.log('');
    Logger.log('ERROR: ' + error.toString());
    Logger.log('');
    Logger.log('Make sure:');
    Logger.log('1. SHEET_ID is correct');
    Logger.log('2. You have edit access to the spreadsheet');
  }
}

/**
 * Test the save function
 */
function testSave() {
  Logger.log('Testing save function...');
  
  if (!SHEET_ID || SHEET_ID === '') {
    Logger.log('ERROR: SHEET_ID not configured');
    return;
  }
  
  const testData = {
    postData: {
      contents: JSON.stringify({
        action: 'saveProgress',
        tracerName: 'TEST_USER',
        version: '4.0',
        allData: {
          'Test Participant': {
            'Trial 1': {
              '500Hz_80dB': {
                red: [[{x: -2, y: 3}, {x: -1, y: 4}, {x: 0, y: 4.5}, {x: 1, y: 4}, {x: 2, y: 3}]],
                blue: [[{x: -2, y: -3}, {x: -1, y: -4}, {x: 0, y: -4.5}, {x: 1, y: -4}, {x: 2, y: -3}]],
                redAvg: [{x: -2, y: 3}, {x: 0, y: 4.5}, {x: 2, y: 3}],
                blueAvg: null
              }
            }
          }
        },
        settings: {
          resampleRate: 1000,
          imageOpacity: 10,
          brushSize: 5
        }
      })
    }
  };
  
  const result = doPost(testData);
  Logger.log('Result: ' + result.getContent());
}

/**
 * Test the list function
 */
function testList() {
  Logger.log('Testing list function...');
  
  if (!SHEET_ID || SHEET_ID === '') {
    Logger.log('ERROR: SHEET_ID not configured');
    return;
  }
  
  const testParams = {
    parameter: {
      action: 'listTracers'
    }
  };
  
  const result = doGet(testParams);
  Logger.log('Result: ' + result.getContent());
}

/**
 * Clean up test data
 */
function cleanupTestData() {
  if (!SHEET_ID || SHEET_ID === '') {
    Logger.log('ERROR: SHEET_ID not configured');
    return;
  }
  
  const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
  
  // Remove TEST_USER from TracerProgress
  const tracersSheet = spreadsheet.getSheetByName(TRACERS_SHEET);
  if (tracersSheet) {
    const lastRow = tracersSheet.getLastRow();
    if (lastRow > 1) {
      const data = tracersSheet.getRange(2, 1, lastRow - 1, 1).getValues();
      for (let i = data.length - 1; i >= 0; i--) {
        if (data[i][0] === 'TEST_USER') {
          tracersSheet.deleteRow(i + 2);
        }
      }
    }
  }
  
  // Remove TEST_USER from CoordinateData
  const coordsSheet = spreadsheet.getSheetByName(COORDS_SHEET);
  if (coordsSheet) {
    const lastRow = coordsSheet.getLastRow();
    if (lastRow > 1) {
      const data = coordsSheet.getRange(2, 1, lastRow - 1, 1).getValues();
      for (let i = data.length - 1; i >= 0; i--) {
        if (data[i][0] === 'TEST_USER') {
          coordsSheet.deleteRow(i + 2);
        }
      }
    }
  }
  
  // Remove test entries from Summary
  const summarySheet = spreadsheet.getSheetByName(SUMMARY_SHEET);
  if (summarySheet) {
    const lastRow = summarySheet.getLastRow();
    if (lastRow > 1) {
      const data = summarySheet.getRange(2, 1, lastRow - 1, 1).getValues();
      for (let i = data.length - 1; i >= 0; i--) {
        if (data[i][0] === 'Test Participant') {
          summarySheet.deleteRow(i + 2);
        }
      }
    }
  }
  
  Logger.log('Test data cleaned up');
}

/**
 * Create custom menu
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('Contour Tracer')
    .addItem('Setup Sheets (Run First)', 'setupSheets')
    .addSeparator()
    .addItem('Test Save', 'testSave')
    .addItem('Test List Tracers', 'testList')
    .addItem('Cleanup Test Data', 'cleanupTestData')
    .addToUi();
}
